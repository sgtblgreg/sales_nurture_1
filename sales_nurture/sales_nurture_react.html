<!doctype html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SegFlow â€” Sales Nurture</title>
    <link rel="icon" type="image/jpeg" href="../../logo_sgtbl.jpg" />
    <style>
      :root {
        color-scheme: light;
        --bg0: #f6f8fc;
        --bg1: #ffffff;
        --card: #ffffff;
        --card2: rgba(15, 23, 42, 0.03);
        --border: rgba(15, 23, 42, 0.12);
        --border2: rgba(15, 23, 42, 0.08);
        --text: rgba(15, 23, 42, 0.92);
        --muted: rgba(15, 23, 42, 0.65);
        --shadow: 0 18px 48px rgba(15, 23, 42, 0.10);
        --accent: #1a73e8;
        --accent2: #34a853;
        --warn: #f9ab00;
        --danger: #ea4335;
        --link: #1a73e8;
        --linkUnderline: rgba(26, 115, 232, 0.35);
      }

      * {
        box-sizing: border-box;
      }

      html,
      body {
        height: 100%;
      }

      body {
        margin: 0;
        background: var(--bg0);
        color: var(--text);
        font-family:
          ui-sans-serif,
          system-ui,
          -apple-system,
          Segoe UI,
          Roboto,
          Helvetica,
          Arial,
          "Apple Color Emoji",
          "Segoe UI Emoji";
      }

      a {
        color: inherit;
      }

      .app {
        height: 100%;
        display: flex;
        flex-direction: column;
      }

      .header {
        padding: 16px 16px 12px;
        border-bottom: 1px solid var(--border);
        background:
          radial-gradient(700px 180px at 85% -40%, rgba(26, 115, 232, 0.20), transparent 60%),
          radial-gradient(620px 180px at 10% -30%, rgba(52, 168, 83, 0.14), transparent 55%),
          var(--bg1);
        backdrop-filter: blur(10px);
        position: sticky;
        top: 0;
        z-index: 10;
      }

      .header.headerCollapsed {
        padding: 10px 12px;
      }

      .titleRow {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
      }

      .brand {
        display: flex;
        gap: 12px;
        align-items: center;
      }

      .brandLogo {
        width: 38px;
        height: 38px;
        border-radius: 10px;
        object-fit: cover;
        border: 1px solid var(--border);
        background: var(--card2);
      }

      .title {
        font-size: 16px;
        font-weight: 900;
        letter-spacing: 0.2px;
      }

      .sub {
        margin-top: 3px;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.3;
      }

      .toolbar {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .headerSelect {
        min-width: 220px;
        max-width: 340px;
        padding: 8px 10px;
        border-radius: 999px;
        font-weight: 850;
        font-size: 12px;
      }

      .touchBar {
        margin-top: 12px;
        display: flex;
        gap: 8px;
        align-items: center;
        overflow-x: auto;
        padding-bottom: 2px;
        -webkit-overflow-scrolling: touch;
      }

      .touchBar::-webkit-scrollbar {
        height: 8px;
      }

      .touchBar::-webkit-scrollbar-thumb {
        background: rgba(15, 23, 42, 0.12);
        border-radius: 999px;
      }

      /* Touch trajectory (visual flow) */
      .flowHint {
        margin-top: 10px;
        font-size: 12px;
        color: rgba(15, 23, 42, 0.70);
        line-height: 1.3;
      }

      .flowBar {
        margin-top: 12px;
        display: flex;
        align-items: center;
        overflow-x: auto;
        padding: 12px 10px;
        -webkit-overflow-scrolling: touch;
        gap: 12px;
        border: 1px solid var(--border2);
        border-radius: 18px;
        background: rgba(255, 255, 255, 0.62);
      }

      .flowBar::-webkit-scrollbar {
        height: 10px;
      }

      .flowBar::-webkit-scrollbar-thumb {
        background: rgba(15, 23, 42, 0.12);
        border-radius: 999px;
      }

      .flowNode {
        flex: 0 0 auto;
        width: 380px;
        height: 168px;
        border: 1px solid var(--border);
        background: var(--card);
        color: var(--text);
        border-radius: 14px;
        padding: 16px 16px;
        cursor: pointer;
        text-align: left;
        clip-path: polygon(6% 0%, 94% 0%, 100% 10%, 100% 90%, 94% 100%, 6% 100%, 0% 90%, 0% 10%);
        transition: transform 120ms ease, background 120ms ease, border-color 120ms ease, box-shadow 120ms ease;
        display: flex;
        flex-direction: column;
        gap: 4px;
        box-shadow: inset 0 4px 0 rgba(15, 23, 42, 0.10);
      }

      .flowNode:hover {
        background: var(--card2);
        transform: translateY(-1px);
        box-shadow:
          inset 0 4px 0 var(--flowAccent, rgba(26, 115, 232, 0.62)),
          0 14px 30px rgba(15, 23, 42, 0.10);
      }

      .flowNode.active {
        border-color: rgba(26, 115, 232, 0.45);
        background: rgba(26, 115, 232, 0.10);
        box-shadow:
          inset 0 4px 0 var(--flowAccent, rgba(26, 115, 232, 0.78)),
          0 14px 30px rgba(15, 23, 42, 0.10);
      }

      .flowNodeId {
        font-weight: 950;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        font-size: 12px;
        color: rgba(15, 23, 42, 0.92);
      }

      .flowNodeTitle {
        margin-top: 6px;
        font-weight: 900;
        font-size: 15px;
        line-height: 1.15;
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .flowNodeGoal {
        margin-top: 7px;
        font-size: 13px;
        color: rgba(15, 23, 42, 0.68);
        line-height: 1.15;
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .flowNodeDay {
        margin-top: auto;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
        font-weight: 950;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: rgba(15, 23, 42, 0.70);
        border: 1px solid var(--border2);
        background: rgba(15, 23, 42, 0.02);
        border-radius: 999px;
        padding: 6px 10px;
        width: fit-content;
      }

      .flowLink {
        flex: 0 0 78px;
        height: 6px;
        background: linear-gradient(90deg, var(--flowFrom, rgba(15, 23, 42, 0.22)), var(--flowTo, rgba(15, 23, 42, 0.22)));
        position: relative;
        border-radius: 999px;
      }

      .flowLink::after {
        content: "";
        position: absolute;
        right: -1px;
        top: 50%;
        transform: translateY(-50%);
        width: 0;
        height: 0;
        border-top: 7px solid transparent;
        border-bottom: 7px solid transparent;
        border-left: 10px solid var(--flowTo, rgba(15, 23, 42, 0.22));
      }

      .flowLinkLabel {
        position: absolute;
        left: 50%;
        top: -18px;
        transform: translateX(-50%);
        font-size: 11px;
        font-weight: 950;
        letter-spacing: 0.04em;
        color: rgba(15, 23, 42, 0.72);
        background: rgba(255, 255, 255, 0.85);
        border: 1px solid var(--border2);
        border-radius: 999px;
        padding: 4px 8px;
        white-space: nowrap;
      }

      .touchPill {
        flex: 0 0 auto;
        display: inline-flex;
        align-items: center;
        gap: 8px;
        max-width: 420px;
        border: 1px solid var(--border);
        background: var(--card);
        color: var(--text);
        border-radius: 999px;
        padding: 8px 10px;
        cursor: pointer;
        font-size: 12px;
        line-height: 1.1;
        white-space: nowrap;
      }

      .touchPill:hover {
        background: var(--card2);
      }

      .touchPill.active {
        border-color: rgba(26, 115, 232, 0.45);
        background: rgba(26, 115, 232, 0.10);
      }

      .touchPillId {
        font-weight: 950;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(15, 23, 42, 0.92);
      }

      .touchPillDay {
        font-size: 11px;
        color: rgba(15, 23, 42, 0.60);
      }

      .touchPillTitle {
        overflow: hidden;
        text-overflow: ellipsis;
        max-width: 280px;
        font-weight: 800;
      }

      .btn {
        border: 1px solid var(--border);
        background: var(--bg1);
        color: var(--text);
        border-radius: 12px;
        padding: 9px 12px;
        cursor: pointer;
        font-size: 12px;
      }

      .btn:hover {
        background: var(--card2);
      }

      .btn.primary {
        border-color: rgba(26, 115, 232, 0.38);
        background: rgba(26, 115, 232, 0.10);
      }

      .btn.primary:hover {
        background: rgba(26, 115, 232, 0.14);
      }

      .btn.activeTab {
        border-color: rgba(26, 115, 232, 0.35);
        background: rgba(26, 115, 232, 0.10);
      }

      .btn.activeTab:hover {
        background: rgba(26, 115, 232, 0.14);
      }

      .expertOnly {
        display: none;
      }

      .expertMode .expertOnly {
        display: block;
      }

      .main {
        display: grid;
        grid-template-columns: 1fr;
        gap: 14px;
        padding: 14px;
        max-width: 1400px;
        margin: 0 auto;
        width: 100%;
      }

      @media (max-width: 980px) {
        .main {
          grid-template-columns: 1fr;
        }
      }

      .panel {
        border: 1px solid var(--border);
        border-radius: 16px;
        background: var(--card);
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      .panelHeader {
        padding: 12px 12px;
        border-bottom: 1px solid var(--border2);
        background: var(--card2);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .panelTitle {
        font-size: 12px;
        font-weight: 900;
        text-transform: uppercase;
        letter-spacing: 0.08em;
        color: rgba(15, 23, 42, 0.72);
      }

      .panelBody {
        padding: 12px;
      }

      .formGrid {
        display: grid;
        gap: 8px;
      }

      .input,
      textarea.input {
        width: 100%;
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px 12px;
        background: var(--bg1);
        color: var(--text);
        outline: none;
        font-size: 13px;
      }

      .input:focus,
      textarea.input:focus {
        border-color: rgba(26, 115, 232, 0.55);
        box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.12);
      }

      textarea.input {
        resize: vertical;
        min-height: 72px;
      }

      .help {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.35;
      }

      .touchList {
        display: grid;
        gap: 10px;
      }

      .touchCard {
        border: 1px solid var(--border);
        background: var(--bg1);
        border-radius: 14px;
        padding: 10px 12px;
        cursor: pointer;
      }

      .touchCard:hover {
        background: var(--card2);
      }

      .touchCard.active {
        border-color: rgba(26, 115, 232, 0.35);
        background: rgba(26, 115, 232, 0.10);
      }

      .touchTop {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 10px;
      }

      .touchId {
        font-weight: 950;
        letter-spacing: 0.3px;
        font-size: 12px;
      }

      .touchDay {
        color: rgba(15, 23, 42, 0.65);
        font-size: 12px;
      }

      .touchTitle {
        margin-top: 6px;
        font-weight: 900;
        font-size: 13px;
        line-height: 1.25;
      }

      .touchGoal {
        margin-top: 6px;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.35;
      }

      .tabs {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 10px;
      }

      .tab {
        border: 1px solid var(--border);
        background: var(--bg1);
        color: var(--text);
        border-radius: 999px;
        padding: 8px 12px;
        cursor: pointer;
        font-size: 12px;
      }

      .tab.active {
        border-color: rgba(26, 115, 232, 0.35);
        background: rgba(26, 115, 232, 0.10);
      }

      .doc {
        margin-top: 12px;
        border: 1px solid var(--border);
        background: var(--bg1);
        border-radius: 14px;
        padding: 14px;
        overflow: hidden;
      }

      .doc .md {
        line-height: 1.55;
        font-size: 14px;
      }

      .doc .md h1,
      .doc .md h2,
      .doc .md h3 {
        margin: 16px 0 10px;
        line-height: 1.2;
      }

      .doc .md h1 {
        font-size: 22px;
        font-weight: 950;
        margin-top: 0;
      }

      .doc .md h2 {
        font-size: 16px;
        font-weight: 900;
      }

      .doc .md h3 {
        font-size: 14px;
        font-weight: 850;
      }

      .doc .md p {
        margin: 8px 0;
      }

      .doc .md ul,
      .doc .md ol {
        margin: 8px 0 8px 18px;
      }

      .doc .md li {
        margin: 4px 0;
      }

      .doc .md blockquote {
        margin: 10px 0;
        padding: 10px 12px;
        border-left: 3px solid rgba(26, 115, 232, 0.45);
        background: rgba(26, 115, 232, 0.08);
        border-radius: 12px;
        color: var(--text);
      }

      .doc .md a {
        color: var(--link);
        text-decoration: none;
        border-bottom: 1px solid var(--linkUnderline);
      }

      .doc .md a:hover {
        border-bottom-color: rgba(26, 115, 232, 0.55);
      }

      .doc .md code {
        border: 1px solid var(--border);
        background: rgba(26, 115, 232, 0.06);
        border-radius: 8px;
        padding: 2px 6px;
      }

      .doc .md pre {
        border: 1px solid var(--border);
        background: var(--card2);
        border-radius: 14px;
        padding: 12px;
        overflow: auto;
      }

      .doc .md pre code {
        border: none;
        background: transparent;
        padding: 0;
      }

      /* Magazine layout (optional) */
      .magazineMode .panel {
        border: none;
        background: transparent;
        box-shadow: none;
      }

      .magazineMode .panelBody {
        padding: 0;
      }

      .magazineMode .doc {
        border: none;
        background: transparent;
        padding: 0;
      }

      .magazineMode .doc .md {
        max-width: 1040px;
        margin: 0 auto;
        background: var(--bg1);
        border: 1px solid var(--border);
        border-radius: 22px;
        padding: 26px 30px;
        box-shadow: var(--shadow);
        line-height: 1.68;
        font-size: 15px;
      }

      .magazineMode .doc .md h1 {
        font-size: 26px;
        letter-spacing: -0.01em;
      }

      .magazineMode .doc .md h2 {
        font-size: 18px;
      }

      .magazineMode .doc .md h3 {
        font-size: 15px;
      }

      .magazineMode .doc .md .reportHeader {
        flex-direction: column;
        align-items: flex-start;
        gap: 10px;
        border-bottom: 1px solid var(--border2);
        padding-bottom: 16px;
        margin-bottom: 16px;
      }

      .magazineMode .doc .md .reportTitle {
        font-size: 22px;
        line-height: 1.06;
        letter-spacing: -0.01em;
      }

      .magazineMode .doc .md .metaChips {
        justify-content: flex-start;
        max-width: none;
      }

      .magazineMode .doc .md .kpiGrid,
      .magazineMode .doc .md .vizGrid,
      .magazineMode .doc .md .vizGrid3 {
        gap: 12px;
      }

      .magazineMode .doc .md .kpiCard,
      .magazineMode .doc .md .chartCard {
        border-radius: 18px;
      }

      .magazineMode .doc .md .sfTable th,
      .magazineMode .doc .md .sfTable td {
        padding: 12px 12px;
      }

      @media (max-width: 980px) {
        .magazineMode .doc .md {
          border-radius: 16px;
          padding: 18px 16px;
        }
      }

      /* Consulting-style visual blocks (used in DEMO reports) */
      .doc .md .reportHeader {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 12px;
        padding-bottom: 12px;
        border-bottom: 1px solid var(--border2);
        margin-bottom: 12px;
      }

      .printRoot .doc .md .reportHeader {
        border-bottom-color: rgba(15, 23, 42, 0.14);
      }

      .doc .md .reportTitle {
        font-size: 18px;
        font-weight: 950;
        line-height: 1.15;
        margin: 0;
      }

      .doc .md .reportSub {
        margin-top: 6px;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.35;
      }

      .printRoot .doc .md .reportSub {
        color: rgba(15, 23, 42, 0.70);
      }

      .doc .md .metaChips {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        justify-content: flex-end;
        max-width: 520px;
      }

      .doc .md .chip {
        display: inline-flex;
        align-items: baseline;
        gap: 6px;
        border: 1px solid var(--border);
        background: var(--card2);
        border-radius: 999px;
        padding: 6px 10px;
        font-size: 12px;
        color: var(--text);
        white-space: nowrap;
      }

      .printRoot .doc .md .chip {
        border-color: rgba(15, 23, 42, 0.14);
        background: rgba(15, 23, 42, 0.03);
        color: rgba(15, 23, 42, 0.92);
      }

      .doc .md .chipLabel {
        color: var(--muted);
        font-size: 11px;
        font-weight: 850;
        letter-spacing: 0.06em;
        text-transform: uppercase;
      }

      .printRoot .doc .md .chipLabel {
        color: rgba(15, 23, 42, 0.65);
      }

      .doc .md .kpiGrid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 10px;
        margin: 12px 0;
      }

      .doc .md .kpiCard {
        border: 1px solid var(--border);
        background: var(--card2);
        border-radius: 14px;
        padding: 12px 12px;
      }

      .printRoot .doc .md .kpiCard {
        border-color: rgba(15, 23, 42, 0.14);
        background: rgba(15, 23, 42, 0.03);
      }

      .doc .md .kpiLabel {
        font-size: 11px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.06em;
        font-weight: 900;
      }

      .printRoot .doc .md .kpiLabel {
        color: rgba(15, 23, 42, 0.65);
      }

      .doc .md .kpiValue {
        margin-top: 8px;
        font-size: 14px;
        font-weight: 950;
        line-height: 1.25;
      }

      .doc .md .kpiNote {
        margin-top: 6px;
        font-size: 12px;
        color: var(--muted);
        line-height: 1.35;
      }

      .printRoot .doc .md .kpiNote {
        color: rgba(15, 23, 42, 0.75);
      }

      .doc .md .vizGrid {
        display: grid;
        grid-template-columns: 1.15fr 0.85fr;
        gap: 10px;
        margin: 12px 0;
      }

      .doc .md .vizGrid3 {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 10px;
        margin: 12px 0;
      }

      .doc .md .vizStack {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        margin: 12px 0;
      }

      .doc .md .vizGrid3 table.heatTable {
        min-width: 640px;
      }

      .doc .md .chartCard {
        border: 1px solid var(--border);
        background: var(--card2);
        border-radius: 14px;
        padding: 12px 12px;
      }

      .printRoot .doc .md .chartCard {
        border-color: rgba(15, 23, 42, 0.14);
        background: rgba(15, 23, 42, 0.02);
      }

      .doc .md .chartTitle {
        font-size: 12px;
        font-weight: 950;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: rgba(15, 23, 42, 0.72);
      }

      .printRoot .doc .md .chartTitle {
        color: rgba(15, 23, 42, 0.78);
      }

      .doc .md .chartNote {
        margin-top: 8px;
        font-size: 12px;
        color: var(--muted);
        line-height: 1.35;
      }

      .printRoot .doc .md .chartNote {
        color: rgba(15, 23, 42, 0.65);
      }

      .doc .md .sfKpiLinks {
        margin-top: 10px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .doc .md .sfInlineLink {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        border: 1px solid rgba(26, 115, 232, 0.30);
        background: rgba(26, 115, 232, 0.08);
        border-radius: 999px;
        padding: 7px 10px;
        color: rgba(26, 115, 232, 0.95);
        text-decoration: none;
        border-bottom: none;
        font-size: 12px;
        font-weight: 800;
      }

      .doc .md .sfInlineLink:hover {
        background: rgba(26, 115, 232, 0.12);
      }

      .doc .md .sfInlineBtn {
        border: 1px solid var(--border);
        background: var(--bg1);
        color: var(--text);
        border-radius: 999px;
        padding: 7px 10px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 850;
      }

      .doc .md .sfInlineBtn:hover {
        background: var(--card2);
      }

      .doc .md .sfDetails {
        margin-top: 10px;
        border: 1px solid var(--border);
        border-radius: 14px;
        background: var(--bg1);
        overflow: hidden;
      }

      .doc .md .sfDetails > summary {
        cursor: pointer;
        padding: 10px 12px;
        font-size: 12px;
        font-weight: 900;
        color: var(--text);
        letter-spacing: 0.04em;
      }

      .doc .md .sfDetailsBody {
        padding: 0 12px 12px;
        font-size: 12px;
        color: rgba(15, 23, 42, 0.82);
        line-height: 1.35;
      }

      .doc .md .sfLegend {
        display: grid;
        gap: 8px;
        min-width: 320px;
      }

      .doc .md .sfLegendRow {
        width: 100%;
        display: flex;
        gap: 10px;
        align-items: flex-start;
        text-align: left;
        border: 1px solid var(--border);
        background: var(--bg1);
        color: var(--text);
        border-radius: 12px;
        padding: 10px 10px;
        cursor: pointer;
        font-size: 12px;
        line-height: 1.2;
        transition: transform 120ms ease, background 120ms ease;
      }

      .doc .md .sfLegendRow.sfActive {
        transform: translateY(-1px) scale(1.03);
        border-color: rgba(26, 115, 232, 0.35);
        background: rgba(26, 115, 232, 0.08);
        box-shadow: 0 14px 30px rgba(15, 23, 42, 0.10);
      }

      .doc .md .sfLegendRow:hover {
        background: var(--card2);
        transform: translateY(-1px);
      }

      .doc .md .sfLegendSwatch {
        width: 11px;
        height: 11px;
        border-radius: 3px;
        flex: 0 0 auto;
      }

      .doc .md .sfPieSeg {
        cursor: pointer;
        pointer-events: stroke;
        opacity: 0.94;
        transition: stroke-width 120ms ease, opacity 120ms ease, filter 120ms ease;
      }

      .doc .md .sfPieSeg.sfActive {
        stroke-width: 38;
        opacity: 1;
        filter: drop-shadow(0 10px 18px rgba(15, 23, 42, 0.18));
      }

      .doc .md .sfPieSeg:hover {
        stroke-width: 38;
        opacity: 1;
        filter: drop-shadow(0 10px 18px rgba(15, 23, 42, 0.18));
      }

      .doc .md .sfMixRow {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 320px minmax(360px, 1fr);
        gap: 18px;
        align-items: start;
      }

      .doc .md .sfMixRow.sfMixRow3 {
        grid-template-columns: 320px minmax(420px, 1fr) minmax(420px, 1fr);
      }

      .doc .md .sfMixRow.sfMixRow3 .sfLegend {
        min-width: 0;
      }

      .doc .md .sfLegendText {
        display: grid;
        gap: 4px;
      }

      .doc .md .sfLegendDesc {
        color: var(--muted);
        font-size: 11px;
        line-height: 1.25;
      }

      .doc .md .sfMixSide {
        display: grid;
        gap: 10px;
        align-items: start;
      }

      .doc .md .sfSummary {
        margin-top: 12px;
        border-top: 1px solid var(--border2);
        padding-top: 10px;
      }

      .doc .md .sfSummary.sfSummaryCard {
        margin-top: 0;
        border: 1px solid var(--border);
        padding: 12px 12px;
        border-radius: 14px;
        background: rgba(255, 255, 255, 0.62);
      }

      .doc .md .sfSummaryTitle {
        font-size: 12px;
        font-weight: 950;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: rgba(15, 23, 42, 0.72);
        margin-bottom: 8px;
      }

      .doc .md .sfSummaryBody p {
        margin: 8px 0;
        font-size: 13px;
        line-height: 1.4;
      }

      @media (max-width: 980px) {
        .doc .md .sfMixRow {
          grid-template-columns: 1fr;
        }
        .doc .md .sfLegend {
          min-width: 0;
        }
      }

      .doc .md .sfChainRow {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 1fr 34px 1fr 34px 1fr;
        gap: 10px;
        align-items: stretch;
      }

      .doc .md .sfChainBox {
        border: 1px solid var(--border);
        background: var(--bg1);
        border-radius: 14px;
        padding: 12px 12px;
      }

      .printRoot .doc .md .sfChainBox {
        border-color: rgba(15, 23, 42, 0.14);
        background: rgba(15, 23, 42, 0.03);
      }

      .doc .md .sfChainTitle {
        font-size: 11px;
        font-weight: 950;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: rgba(15, 23, 42, 0.72);
      }

      .printRoot .doc .md .sfChainTitle {
        color: rgba(15, 23, 42, 0.78);
      }

      .doc .md .sfChainBody {
        margin-top: 6px;
        font-size: 12px;
        color: rgba(15, 23, 42, 0.82);
        line-height: 1.35;
      }

      .printRoot .doc .md .sfChainBody {
        color: rgba(15, 23, 42, 0.82);
      }

      .doc .md .sfChainArrow {
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        font-weight: 950;
        color: rgba(15, 23, 42, 0.55);
        user-select: none;
      }

      .printRoot .doc .md .sfChainArrow {
        color: rgba(15, 23, 42, 0.65);
      }

      .doc .md .sfHScroll {
        margin-top: 10px;
        display: flex;
        gap: 10px;
        overflow-x: auto;
        padding-bottom: 6px;
        -webkit-overflow-scrolling: touch;
      }

      .doc .md .sfHScroll::-webkit-scrollbar {
        height: 10px;
      }

      .doc .md .sfHScroll::-webkit-scrollbar-thumb {
        background: rgba(15, 23, 42, 0.12);
        border-radius: 999px;
      }

      .doc .md .sfNeedCard {
        flex: 0 0 360px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.62);
        border-radius: 14px;
        padding: 12px 12px;
      }

      .doc .md .sfNeedTitle {
        font-weight: 950;
        font-size: 13px;
        line-height: 1.2;
      }

      .doc .md .sfNeedDesc {
        margin-top: 6px;
        font-size: 12px;
        color: rgba(15, 23, 42, 0.72);
        line-height: 1.35;
      }

      .doc .md .sfCreativeMock {
        margin-top: 10px;
        border: 1px solid var(--border);
        background: radial-gradient(520px 220px at 0% 0%, rgba(26, 115, 232, 0.18), transparent 60%),
          radial-gradient(520px 220px at 100% 0%, rgba(52, 168, 83, 0.14), transparent 60%),
          rgba(255, 255, 255, 0.80);
        border-radius: 16px;
        padding: 12px 12px;
      }

      .doc .md .sfCreativeKicker {
        font-size: 11px;
        font-weight: 950;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: rgba(15, 23, 42, 0.70);
      }

      .doc .md .sfCreativeHeadline {
        margin-top: 8px;
        font-size: 18px;
        font-weight: 950;
        letter-spacing: -0.01em;
        line-height: 1.1;
        color: rgba(15, 23, 42, 0.95);
      }

      .doc .md .sfCreativeBody {
        margin-top: 8px;
        font-size: 12px;
        color: rgba(15, 23, 42, 0.78);
        line-height: 1.35;
      }

      .doc .md .sfCreativeCta {
        margin-top: 10px;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border: 1px solid rgba(26, 115, 232, 0.35);
        background: rgba(26, 115, 232, 0.10);
        color: rgba(15, 23, 42, 0.92);
        border-radius: 999px;
        padding: 7px 10px;
        font-size: 12px;
        font-weight: 950;
        letter-spacing: 0.02em;
        user-select: none;
      }

      @media (max-width: 860px) {
        .doc .md .sfChainRow {
          grid-template-columns: 1fr;
        }
        .doc .md .sfChainArrow {
          display: none;
        }
      }

      .doc .md .sfImagePlaceholder {
        margin-top: 10px;
        border-radius: 18px;
        overflow: hidden;
      }

      .doc .md .sfCardGrid {
        margin-top: 10px;
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }

      @media (max-width: 780px) {
        .doc .md .sfCardGrid {
          grid-template-columns: 1fr;
        }
      }

      .doc .md .sfSourceCard {
        display: grid;
        grid-template-columns: 92px 1fr;
        gap: 12px;
        align-items: stretch;
        border: 1px solid var(--border);
        background: var(--bg1);
        border-radius: 14px;
        overflow: hidden;
        color: var(--text);
        text-decoration: none;
        border-bottom: none;
        transition: transform 120ms ease, background 120ms ease;
      }

      .doc .md .sfSourceCard:hover {
        background: var(--card2);
        transform: translateY(-1px);
      }

      .doc .md .sfSourceShot {
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 950;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: rgba(255, 255, 255, 0.94);
        background: linear-gradient(135deg, rgba(26, 115, 232, 0.35), rgba(52, 168, 83, 0.20));
      }

      .doc .md .sfSourceCard.sfSourceCardPdf {
        grid-template-columns: 140px 1fr;
      }

      @media (max-width: 520px) {
        .doc .md .sfSourceCard.sfSourceCardPdf {
          grid-template-columns: 120px 1fr;
        }
      }

      .doc .md .sfSourceShot.sfSourceShotImg {
        padding: 0;
        background: rgba(15, 23, 42, 0.06);
        letter-spacing: 0;
        text-transform: none;
      }

      .doc .md .sfSourceShotBtn {
        border: none;
        padding: 0;
        width: 100%;
        cursor: pointer;
      }

      .doc .md .sfSourceShotBtn:focus-visible {
        outline: none;
        box-shadow: inset 0 0 0 2px rgba(26, 115, 232, 0.45);
      }

      .doc .md .sfSourceThumb {
        width: 100%;
        height: 100%;
        display: block;
        object-fit: cover;
      }

      .doc .md .sfSourceCardBody {
        padding: 10px 10px 10px 0;
      }

      .doc .md .sfSourceTitle {
        font-weight: 900;
        font-size: 13px;
        line-height: 1.25;
      }

      .doc .md .sfSourceActions {
        margin-top: 10px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .doc .md .sfEvidenceImg {
        width: 100%;
        border-radius: 14px;
        border: 1px solid var(--border);
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.10);
        display: block;
      }

      .doc .md .sfAnalyzerRow {
        margin-top: 10px;
        display: grid;
        grid-template-columns: minmax(260px, 360px) minmax(0, 1fr);
        gap: 14px;
        align-items: start;
      }

      @media (max-width: 860px) {
        .doc .md .sfAnalyzerRow {
          grid-template-columns: 1fr;
        }
      }

      .doc .md .sfAnalyzerDoc {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
      }

      .doc .md .sfDocAnalyzerFrame {
        position: relative;
        width: 100%;
      }

      @keyframes sfTypeSwitchDown {
        from {
          opacity: 0.0;
          transform: translateY(-6px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      .doc .md .sfDocAnalyzerFrame.sfTypeSwitching .sfAnalyzerTableWrap,
      .doc .md .sfDocAnalyzerFrame.sfTypeSwitching .sfAnalyzerLists,
      .doc .md .sfDocAnalyzerFrame.sfTypeSwitching .sfAnalyzerStatus {
        animation: sfTypeSwitchDown 160ms ease both;
      }

      .doc .md .sfAnalyzerViewer {
        width: 100%;
        max-width: 360px;
        position: relative;
      }

      .doc .md .sfAnalyzerPageImg {
        width: 100%;
        border-radius: 14px;
        border: 1px solid var(--border);
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.10);
        display: block;
        background: rgba(255, 255, 255, 0.6);
        user-select: none;
      }

      .doc .md .sfAnalyzerOverlay {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 2;
      }

	      .doc .md .sfHitBox {
	        position: absolute;
	        transform: translate(-50%, -50%);
	        border-radius: 10px;
	        border: 2px solid var(--sfHitColor, rgba(15, 23, 42, 0.55));
	        background: var(--sfHitBg, rgba(15, 23, 42, 0.08));
	        box-shadow: 0 10px 24px rgba(15, 23, 42, 0.10);
	      }
	
	      .doc .md .sfHitRect {
	        position: absolute;
	        border-radius: 6px;
	        border: 2px solid var(--sfHitColor, rgba(15, 23, 42, 0.55));
	        background: var(--sfHitBg, rgba(15, 23, 42, 0.06));
	        box-shadow: 0 10px 24px rgba(15, 23, 42, 0.10);
	      }

	      .doc .md .sfHitBox[data-type="segment"] {
	        --sfHitColor: rgba(245, 158, 11, 0.92);
	        --sfHitBg: rgba(245, 158, 11, 0.12);
	      }
	
	      .doc .md .sfHitRect[data-type="segment"] {
	        --sfHitColor: rgba(245, 158, 11, 0.92);
	        --sfHitBg: rgba(245, 158, 11, 0.10);
	      }

	      .doc .md .sfHitBox[data-type="need"] {
	        --sfHitColor: rgba(236, 72, 153, 0.88);
	        --sfHitBg: rgba(236, 72, 153, 0.10);
	      }
	
	      .doc .md .sfHitRect[data-type="need"] {
	        --sfHitColor: rgba(236, 72, 153, 0.88);
	        --sfHitBg: rgba(236, 72, 153, 0.08);
	      }

	      .doc .md .sfHitBox[data-type="feature"] {
	        --sfHitColor: rgba(26, 115, 232, 0.90);
	        --sfHitBg: rgba(26, 115, 232, 0.10);
	      }
	
	      .doc .md .sfHitRect[data-type="feature"] {
	        --sfHitColor: rgba(26, 115, 232, 0.90);
	        --sfHitBg: rgba(26, 115, 232, 0.08);
	      }

	      .doc .md .sfHitBox[data-type="channel"] {
	        --sfHitColor: rgba(52, 168, 83, 0.86);
	        --sfHitBg: rgba(52, 168, 83, 0.10);
	      }
	
	      .doc .md .sfHitRect[data-type="channel"] {
	        --sfHitColor: rgba(52, 168, 83, 0.86);
	        --sfHitBg: rgba(52, 168, 83, 0.08);
	      }

	      .doc .md .sfHitBox[data-type="sales_best_practice"] {
	        --sfHitColor: rgba(124, 58, 237, 0.84);
	        --sfHitBg: rgba(124, 58, 237, 0.10);
	      }
	
	      .doc .md .sfHitRect[data-type="sales_best_practice"] {
	        --sfHitColor: rgba(124, 58, 237, 0.84);
	        --sfHitBg: rgba(124, 58, 237, 0.08);
	      }

	      .doc .md .sfHitBox[data-type="trigger"] {
	        --sfHitColor: rgba(234, 67, 53, 0.86);
	        --sfHitBg: rgba(234, 67, 53, 0.10);
	      }
	
	      .doc .md .sfHitRect[data-type="trigger"] {
	        --sfHitColor: rgba(234, 67, 53, 0.86);
	        --sfHitBg: rgba(234, 67, 53, 0.08);
	      }

      .doc .md .sfHitBox.sfHitMuted {
        opacity: 0.38;
      }

      .doc .md .sfHitCode {
        position: absolute;
        left: 8px;
        top: -12px;
        height: 20px;
        display: inline-flex;
        align-items: center;
        padding: 0 8px;
        border-radius: 999px;
        font-size: 11px;
        font-weight: 950;
        letter-spacing: 0.02em;
        color: rgba(255, 255, 255, 0.96);
        background: var(--sfHitColor, rgba(15, 23, 42, 0.70));
        box-shadow: 0 10px 24px rgba(15, 23, 42, 0.14);
        user-select: none;
        white-space: nowrap;
      }

      .doc .md .sfDocAnalyzerFrame.sfIsScanning .sfAnalyzerPageImg {
        filter: grayscale(0.08) saturate(1.05) brightness(1.02);
      }

      .doc .md .sfAnalyzerScanline {
        position: absolute;
        left: 10px;
        right: 10px;
        top: 0;
        height: 6px;
        border-radius: 999px;
        background: linear-gradient(90deg, transparent, rgba(26, 115, 232, 0.36), rgba(236, 72, 153, 0.26), transparent);
        opacity: 0;
        box-shadow: 0 0 0 1px rgba(15, 23, 42, 0.08), 0 16px 32px rgba(26, 115, 232, 0.14);
        pointer-events: none;
      }

      @keyframes sfScanline {
        0% {
          top: 10px;
          opacity: 0;
        }
        10% {
          opacity: 1;
        }
        90% {
          opacity: 1;
        }
        100% {
          top: calc(100% - 16px);
          opacity: 0;
        }
      }

      .doc .md .sfDocAnalyzerFrame.sfIsScanning .sfAnalyzerScanline {
        opacity: 1;
        animation: sfScanline 650ms linear both;
      }

      .doc .md .sfAnalyzerNav {
        width: 100%;
        max-width: 360px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 10px;
      }

      .doc .md .sfAnalyzerNavLabel {
        font-size: 12px;
        font-weight: 850;
        color: rgba(15, 23, 42, 0.82);
      }

      .doc .md .sfAnalyzerNavBtn {
        width: 34px;
        height: 34px;
        padding: 0;
        display: inline-flex;
        align-items: center;
        justify-content: center;
      }

      .doc .md .sfAnalyzerThumbStrip {
        width: 100%;
        max-width: 360px;
        display: flex;
        gap: 8px;
        overflow-x: auto;
        padding: 6px 2px 8px;
        scrollbar-width: thin;
      }

      .doc .md .sfAnalyzerThumb {
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.65);
        border-radius: 12px;
        padding: 0;
        cursor: pointer;
        flex: 0 0 78px;
        overflow: hidden;
        position: relative;
      }

      .doc .md .sfAnalyzerThumb:hover {
        background: rgba(15, 23, 42, 0.03);
      }

      .doc .md .sfAnalyzerThumbActive {
        border-color: rgba(26, 115, 232, 0.55);
        box-shadow: 0 0 0 2px rgba(26, 115, 232, 0.16);
      }

      .doc .md .sfAnalyzerThumbImg {
        width: 100%;
        height: 56px;
        object-fit: cover;
        display: block;
        filter: saturate(0.92);
      }

      .doc .md .sfAnalyzerThumbNum {
        position: absolute;
        top: 6px;
        left: 6px;
        font-size: 11px;
        font-weight: 950;
        color: rgba(15, 23, 42, 0.85);
        background: rgba(255, 255, 255, 0.85);
        border: 1px solid rgba(15, 23, 42, 0.12);
        border-radius: 10px;
        padding: 2px 6px;
      }

      .doc .md .sfAnalyzerStatus {
        font-size: 12px;
        font-weight: 850;
        color: rgba(15, 23, 42, 0.82);
        margin-top: 10px;
        margin-bottom: 10px;
      }

      .doc .md .sfAnalyzerArrows {
        position: absolute;
        inset: 0;
        pointer-events: none;
        z-index: 6;
      }

      .doc .md .sfAnalyzerArrowPath {
        fill: none;
        stroke-width: 2;
        stroke-linecap: round;
        stroke-linejoin: round;
        opacity: 0.95;
      }

      .doc .md .sfAnalyzerShot {
        width: 100%;
        max-width: 360px;
        border-radius: 14px;
        border: 1px solid var(--border);
        box-shadow: 0 18px 40px rgba(15, 23, 42, 0.10);
        display: block;
        background: rgba(255, 255, 255, 0.6);
      }

      .doc .md .sfFootnotes {
        border: 1px solid var(--border);
        background: var(--bg1);
        border-radius: 14px;
        padding: 12px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .doc .md .sfFootnote {
        display: flex;
        align-items: flex-start;
        gap: 10px;
      }

      .doc .md .sfFootnoteNum {
        width: 24px;
        height: 24px;
        flex: 0 0 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 8px;
        border: 1px solid rgba(15, 23, 42, 0.16);
        background: rgba(15, 23, 42, 0.04);
        font-weight: 950;
        font-size: 12px;
      }

      .doc .md .sfFootnoteMeta {
        margin-top: 6px;
        font-size: 12px;
        line-height: 1.35;
        color: rgba(15, 23, 42, 0.82);
      }

      .doc .md .sfAnalyzerLists {
        margin-top: 10px;
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
      }

      @media (max-width: 780px) {
        .doc .md .sfAnalyzerLists {
          grid-template-columns: 1fr;
        }
      }

      .doc .md .sfAnalyzerList {
        border: 1px solid var(--border);
        background: var(--bg1);
        border-radius: 14px;
        padding: 10px;
      }

      .doc .md .sfAnalyzerListTitle {
        font-weight: 950;
        font-size: 12px;
        color: rgba(15, 23, 42, 0.86);
      }

      .doc .md .sfAnalyzerTableWrap {
        margin-top: 0;
        max-height: 240px;
        overflow: auto;
        scrollbar-gutter: stable;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.65);
        position: relative;
      }

      .doc .md .sfAnalyzerTableWrap .sfTable {
        margin-top: 0;
      }

      .doc .md .sfAnalyzerTableWrap[data-sf-scrollhint="1"]::after {
        content: "";
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        height: 42px;
        background: linear-gradient(to bottom, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.96));
        pointer-events: none;
      }

      .doc .md .sfAnalyzerTableHint {
        position: absolute;
        right: 10px;
        bottom: 10px;
        font-size: 11px;
        font-weight: 950;
        color: rgba(15, 23, 42, 0.75);
        border: 1px solid rgba(15, 23, 42, 0.12);
        background: rgba(255, 255, 255, 0.92);
        border-radius: 999px;
        padding: 4px 8px;
        opacity: 0;
        transform: translateY(4px);
        transition: opacity 120ms ease, transform 120ms ease;
        pointer-events: none;
      }

      .doc .md .sfAnalyzerTableWrap[data-sf-scrollhint="1"] .sfAnalyzerTableHint {
        opacity: 1;
        transform: translateY(0);
      }

      .doc .md .sfTagRow {
        margin-top: 8px;
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        align-items: center;
      }

      .doc .md .sfTag {
        display: inline-flex;
        align-items: center;
        border: 1px solid var(--border);
        background: var(--card2);
        color: rgba(15, 23, 42, 0.78);
        border-radius: 999px;
        padding: 5px 8px;
        font-size: 11px;
        font-weight: 850;
        letter-spacing: 0.02em;
      }

      .doc .md .sfTable {
        width: 100%;
        border-collapse: collapse;
        margin-top: 10px;
        font-size: 12px;
      }

      .doc .md .sfScrollY {
        margin-top: 10px;
        max-height: 360px;
        overflow: auto;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: var(--bg1);
      }

      .doc .md .sfScrollY .sfTable {
        margin-top: 0;
      }

      .doc .md .sfTable th,
      .doc .md .sfTable td {
        padding: 10px 10px;
        border-bottom: 1px solid var(--border2);
        vertical-align: top;
      }

      .doc .md .sfRowLink td {
        cursor: pointer;
      }

      .doc .md .sfRowLink:hover td {
        background: rgba(15, 23, 42, 0.03);
      }

      .doc .md .sfTable th {
        text-align: left;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: rgba(15, 23, 42, 0.62);
      }

      .doc .md .barChart {
        margin-top: 10px;
        display: grid;
        gap: 10px;
      }

      .doc .md .barItem {
        display: grid;
        grid-template-columns: 180px 1fr 40px;
        gap: 10px;
        align-items: center;
      }

      .doc .md .barLabel {
        font-size: 12px;
        color: rgba(15, 23, 42, 0.88);
        line-height: 1.2;
      }

      .printRoot .doc .md .barLabel {
        color: rgba(15, 23, 42, 0.88);
      }

      .doc .md .barTrack {
        height: 10px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.04);
        border: 1px solid var(--border2);
        overflow: hidden;
      }

      .printRoot .doc .md .barTrack {
        background: rgba(15, 23, 42, 0.06);
        border-color: rgba(15, 23, 42, 0.12);
      }

      .doc .md .barFill {
        height: 100%;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(26, 115, 232, 0.95), rgba(52, 168, 83, 0.95));
      }

      .doc .md .barValue {
        font-variant-numeric: tabular-nums;
        font-size: 12px;
        color: rgba(15, 23, 42, 0.65);
        text-align: right;
      }

      .printRoot .doc .md .barValue {
        color: rgba(15, 23, 42, 0.78);
      }

      .doc .md .matrix2x2 {
        margin-top: 10px;
        position: relative;
        height: 260px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.65);
        overflow: hidden;
        isolation: isolate;
      }

      .doc .md .matrix2x2.matrixLarge {
        height: 360px;
      }

      .doc .md .sfBubblePlot {
        margin-top: 10px;
        position: relative;
        height: 360px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.65);
        overflow: hidden;
        isolation: isolate;
      }

      .doc .md .sfBubblePlot::before {
        content: "";
        position: absolute;
        inset: 0;
        background:
          linear-gradient(to right, rgba(15, 23, 42, 0.08) 1px, transparent 1px) 0 0 / 20% 100%,
          linear-gradient(to bottom, rgba(15, 23, 42, 0.08) 1px, transparent 1px) 0 0 / 100% 20%;
        pointer-events: none;
        z-index: 0;
      }

      .doc .md .sfBubblePlot::after {
        content: "";
        position: absolute;
        inset: 0;
        background: linear-gradient(rgba(15, 23, 42, 0.10), rgba(15, 23, 42, 0.10)) 0 0 / 100% 1px no-repeat;
        pointer-events: none;
        opacity: 0;
      }

      .doc .md .sfBubblePoint {
        width: var(--sfSize, 18px);
        height: var(--sfSize, 18px);
      }

      .doc .md .sfConstellationPlot {
        margin-top: 10px;
        position: relative;
        height: 420px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.65);
        overflow: hidden;
        isolation: isolate;
      }

      .doc .md .sfConstellationPlot::before {
        content: "";
        position: absolute;
        inset: 0;
        /* 4 quadrants only: top-left niche (blue), top-right strong (green), bottom-right noisy (orange), bottom-left weak (red) */
        background: conic-gradient(
          from 0deg at 50% 50%,
          rgba(52, 168, 83, 0.12) 0 90deg,
          rgba(245, 158, 11, 0.10) 90deg 180deg,
          rgba(234, 67, 53, 0.10) 180deg 270deg,
          rgba(26, 115, 232, 0.10) 270deg 360deg
        );
        pointer-events: none;
        z-index: 0;
      }

      .doc .md .sfConstellationPlot::after {
        content: "";
        position: absolute;
        inset: 0;
        background:
          linear-gradient(
            to right,
            transparent calc(50% - 0.5px),
            rgba(15, 23, 42, 0.18) calc(50% - 0.5px),
            rgba(15, 23, 42, 0.18) calc(50% + 0.5px),
            transparent calc(50% + 0.5px)
          ),
          linear-gradient(
            to bottom,
            transparent calc(50% - 0.5px),
            rgba(15, 23, 42, 0.18) calc(50% - 0.5px),
            rgba(15, 23, 42, 0.18) calc(50% + 0.5px),
            transparent calc(50% + 0.5px)
          );
        pointer-events: none;
        z-index: 1;
      }

      .doc .md .sfConstellationLinks {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        z-index: 1;
        pointer-events: none;
      }

      .doc .md .sfConstellationLinks line {
        opacity: 0.12;
      }

      .doc .md .sfConstellationPlot.sfHasHover .sfConstellationLinks line {
        opacity: 0.05;
      }

      .doc .md .sfConstellationLinks line.sfHover {
        opacity: 0.88 !important;
        stroke-width: 3;
      }

      .doc .md .matrixPoint.sfConstellationPoint {
        width: 12px;
        height: 12px;
        border-width: 2px;
        box-shadow: 0 0 0 4px var(--sfPointGlow), 0 10px 22px rgba(15, 23, 42, 0.10);
      }

      .doc .md .sfConstellationPlot.sfHasHover .matrixPoint.sfConstellationPoint {
        opacity: 0.55;
      }

      .doc .md .matrixPoint.sfConstellationPoint.sfHover {
        opacity: 1 !important;
        transform: translate(-50%, -50%) scale(1.55);
        z-index: 6;
        box-shadow: 0 0 0 6px var(--sfPointGlow), 0 14px 28px rgba(15, 23, 42, 0.14);
      }

      .doc .md .matrixPoint.sfConstellationPoint:hover {
        transform: translate(-50%, -50%) scale(1.18);
      }

      .doc .md .sfConstellationChip {
        --sfPointColor: rgba(15, 23, 42, 0.70);
        --sfPointGlow: rgba(15, 23, 42, 0.12);
        position: absolute;
        transform: translate(-50%, -50%);
        display: inline-flex;
        align-items: center;
        gap: 8px;
        max-width: min(360px, calc(100% - 24px));
        border-radius: 999px;
        padding: 6px 10px;
        border: 1px solid rgba(15, 23, 42, 0.14);
        background: rgba(255, 255, 255, 0.92);
        box-shadow: 0 12px 26px rgba(15, 23, 42, 0.10);
        cursor: pointer;
        z-index: 2;
        text-align: left;
      }

      .doc .md .sfConstellationPlot.sfHasHover .sfConstellationChip {
        opacity: 0.55;
      }

      .doc .md .sfConstellationChip.sfHover {
        opacity: 1 !important;
        transform: translate(-50%, -50%) scale(1.06);
        z-index: 6;
      }

      .doc .md .sfConstellationChip:hover {
        transform: translate(-50%, -50%) scale(1.03);
        box-shadow: 0 16px 34px rgba(15, 23, 42, 0.12);
      }

      .doc .md .sfConstellationChip.sfQuadBest {
        --sfPointColor: rgba(52, 168, 83, 0.95);
        --sfPointGlow: rgba(52, 168, 83, 0.18);
        border-color: rgba(52, 168, 83, 0.28);
      }

      .doc .md .sfConstellationChip.sfQuadNoisy {
        --sfPointColor: rgba(245, 158, 11, 0.95);
        --sfPointGlow: rgba(245, 158, 11, 0.18);
        border-color: rgba(245, 158, 11, 0.28);
      }

      .doc .md .sfConstellationChip.sfQuadNiche {
        --sfPointColor: rgba(26, 115, 232, 0.95);
        --sfPointGlow: rgba(26, 115, 232, 0.18);
        border-color: rgba(26, 115, 232, 0.28);
      }

      .doc .md .sfConstellationChip.sfQuadLow {
        --sfPointColor: rgba(234, 67, 53, 0.95);
        --sfPointGlow: rgba(234, 67, 53, 0.18);
        border-color: rgba(234, 67, 53, 0.28);
      }

      .doc .md .sfConstellationDot {
        width: var(--sfDot, 10px);
        height: var(--sfDot, 10px);
        border-radius: 999px;
        background: var(--sfPointColor);
        box-shadow: 0 0 0 4px var(--sfPointGlow);
        flex: 0 0 auto;
      }

      .doc .md .sfConstellationLabel {
        min-width: 0;
        font-weight: 950;
        font-size: 12px;
        line-height: 1.2;
        color: rgba(15, 23, 42, 0.92);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .doc .md .sfConstellationMeta {
        flex: 0 0 auto;
        font-weight: 900;
        font-size: 11px;
        color: rgba(15, 23, 42, 0.72);
        font-variant-numeric: tabular-nums;
        padding: 3px 7px;
        border-radius: 999px;
        border: 1px solid rgba(15, 23, 42, 0.14);
        background: rgba(15, 23, 42, 0.02);
      }

      .doc .md .sfConstellationChip::after {
        content: attr(data-tooltip);
        position: absolute;
        left: 50%;
        top: -10px;
        transform: translate(-50%, -100%);
        opacity: 0;
        pointer-events: none;
        transition: opacity 120ms ease, transform 120ms ease;
        font-size: 11px;
        font-weight: 900;
        color: rgba(15, 23, 42, 0.92);
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(15, 23, 42, 0.14);
        border-radius: 14px;
        padding: 10px 12px;
        white-space: pre;
        max-width: 280px;
        box-shadow: 0 16px 34px rgba(15, 23, 42, 0.14);
        z-index: 4;
      }

      .doc .md .sfConstellationChip:hover::after {
        opacity: 1;
        transform: translate(-50%, -112%);
      }

      .doc .md .sfQuadDeck {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 12px;
      }

      @media (max-width: 900px) {
        .doc .md .sfQuadDeck {
          grid-template-columns: 1fr;
        }
      }

      .doc .md .sfQuadPanel {
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.65);
        border-radius: 14px;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        min-height: 190px;
      }

      .doc .md .sfQuadPanel.sfQuadBest {
        border-color: rgba(52, 168, 83, 0.25);
      }
      .doc .md .sfQuadPanel.sfQuadNoisy {
        border-color: rgba(245, 158, 11, 0.25);
      }
      .doc .md .sfQuadPanel.sfQuadNiche {
        border-color: rgba(26, 115, 232, 0.25);
      }
      .doc .md .sfQuadPanel.sfQuadLow {
        border-color: rgba(234, 67, 53, 0.22);
      }

      .doc .md .sfQuadPanelHeader {
        padding: 10px 12px;
        border-bottom: 1px solid var(--border2);
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 10px;
      }

      .doc .md .sfQuadTitle {
        font-weight: 950;
        font-size: 13px;
        line-height: 1.2;
        color: rgba(15, 23, 42, 0.92);
      }

      .doc .md .sfQuadSubtitle {
        margin-top: 4px;
        font-size: 12px;
        line-height: 1.25;
        color: rgba(15, 23, 42, 0.70);
      }

      .doc .md .sfQuadPanelList {
        padding: 10px 12px;
        display: flex;
        flex-direction: column;
        gap: 8px;
        overflow: auto;
        max-height: 320px;
      }

      .doc .md .sfQuadCard {
        width: 100%;
        border: 1px solid var(--border2);
        background: rgba(255, 255, 255, 0.92);
        border-radius: 14px;
        padding: 10px 10px;
        cursor: pointer;
        text-align: left;
      }

      .doc .md .sfQuadCard:hover {
        background: rgba(15, 23, 42, 0.02);
      }

      .doc .md .sfQuadCard.sfQuadBest {
        border-left: 4px solid rgba(52, 168, 83, 0.95);
      }
      .doc .md .sfQuadCard.sfQuadNoisy {
        border-left: 4px solid rgba(245, 158, 11, 0.95);
      }
      .doc .md .sfQuadCard.sfQuadNiche {
        border-left: 4px solid rgba(26, 115, 232, 0.95);
      }
      .doc .md .sfQuadCard.sfQuadLow {
        border-left: 4px solid rgba(234, 67, 53, 0.95);
      }

      .doc .md .sfQuadCardTitle {
        font-weight: 950;
        font-size: 12px;
        line-height: 1.25;
        color: rgba(15, 23, 42, 0.92);
      }

      .doc .md .sfBump {
        margin-top: 10px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.65);
        border-radius: 14px;
        overflow: hidden;
      }

      .doc .md .sfBumpHeader {
        padding: 10px 12px;
        border-bottom: 1px solid var(--border2);
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        font-weight: 950;
        color: rgba(15, 23, 42, 0.78);
      }

      .doc .md .sfBumpBody {
        position: relative;
        padding: 12px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 16px;
        min-height: 380px;
      }

      .doc .md .sfBumpSvg {
        position: absolute;
        inset: 0;
        z-index: 0;
        pointer-events: none;
      }

      .doc .md .sfBumpCol {
        z-index: 1;
        display: flex;
        flex-direction: column;
        gap: 8px;
        min-width: 0;
      }

      .doc .md .sfBumpItem {
        width: 100%;
        border: 1px solid var(--border2);
        background: rgba(255, 255, 255, 0.92);
        border-radius: 14px;
        padding: 10px 10px;
        cursor: pointer;
        text-align: left;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
      }

      .doc .md .sfBumpItem:hover {
        background: rgba(15, 23, 42, 0.02);
      }

      .doc .md .sfBumpItem.sfQuadBest {
        border-left: 4px solid rgba(52, 168, 83, 0.95);
      }
      .doc .md .sfBumpItem.sfQuadNoisy {
        border-left: 4px solid rgba(245, 158, 11, 0.95);
      }
      .doc .md .sfBumpItem.sfQuadNiche {
        border-left: 4px solid rgba(26, 115, 232, 0.95);
      }
      .doc .md .sfBumpItem.sfQuadLow {
        border-left: 4px solid rgba(234, 67, 53, 0.95);
      }

      .doc .md .sfBumpItemMain {
        min-width: 0;
      }

      .doc .md .sfBumpItemTitle {
        font-weight: 950;
        font-size: 12px;
        line-height: 1.25;
        color: rgba(15, 23, 42, 0.92);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .doc .md .sfBumpItemSub {
        margin-top: 4px;
        font-size: 11px;
        line-height: 1.25;
        color: rgba(15, 23, 42, 0.68);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .doc .md .sfBumpMetric {
        flex: 0 0 auto;
        font-weight: 950;
        font-size: 12px;
        color: rgba(15, 23, 42, 0.78);
        font-variant-numeric: tabular-nums;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid rgba(15, 23, 42, 0.14);
        background: rgba(15, 23, 42, 0.02);
      }

      .doc .md .sfSwarmPlot {
        margin-top: 10px;
        position: relative;
        height: 420px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.65);
        overflow: hidden;
        isolation: isolate;
      }

      .doc .md .sfSwarmPlot::before {
        content: "";
        position: absolute;
        inset: 0;
        background:
          linear-gradient(to bottom, rgba(15, 23, 42, 0.10) 1px, transparent 1px) 0 0 / 100% 33.333%,
          linear-gradient(to right, rgba(15, 23, 42, 0.08) 1px, transparent 1px) 0 0 / 20% 100%;
        pointer-events: none;
        z-index: 0;
      }

      .doc .md .sfSwarmLaneLabel {
        position: absolute;
        left: 12px;
        transform: translateY(-50%);
        font-size: 11px;
        font-weight: 950;
        color: rgba(15, 23, 42, 0.82);
        border: 1px solid rgba(15, 23, 42, 0.14);
        background: rgba(255, 255, 255, 0.88);
        padding: 4px 8px;
        border-radius: 999px;
        z-index: 2;
      }

      .doc .md .matrixPoint.sfSwarmDot {
        width: var(--sfSize, 16px);
        height: var(--sfSize, 16px);
        box-shadow: none;
      }

      .doc .md .matrixPoint.sfSwarmDot:hover {
        transform: translate(-50%, -50%) scale(1.12);
        box-shadow: none;
      }

      .doc .md .sfTreemap {
        margin-top: 10px;
        position: relative;
        height: 420px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.65);
        overflow: hidden;
        isolation: isolate;
      }

      .doc .md .sfTreemapLegend {
        position: absolute;
        top: 10px;
        left: 12px;
        right: 12px;
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        z-index: 2;
      }

      .doc .md .sfTreeTile {
        position: absolute;
        border-radius: 14px;
        border: 1px solid rgba(15, 23, 42, 0.14);
        padding: 10px 10px;
        text-align: left;
        cursor: pointer;
        overflow: hidden;
        background: rgba(255, 255, 255, 0.92);
      }

      .doc .md .sfTreeTile:hover {
        filter: brightness(0.985);
      }

      .doc .md .sfTreeTile[data-trust="A"] {
        background: linear-gradient(135deg, rgba(52, 168, 83, 0.18), rgba(52, 168, 83, 0.06));
        border-color: rgba(52, 168, 83, 0.28);
      }

      .doc .md .sfTreeTile[data-trust="B"] {
        background: linear-gradient(135deg, rgba(26, 115, 232, 0.14), rgba(26, 115, 232, 0.05));
        border-color: rgba(26, 115, 232, 0.25);
      }

      .doc .md .sfTreeTile[data-trust="C"] {
        background: linear-gradient(135deg, rgba(245, 158, 11, 0.16), rgba(245, 158, 11, 0.05));
        border-color: rgba(245, 158, 11, 0.25);
      }

      .doc .md .sfTreeTitle {
        font-weight: 950;
        font-size: 12px;
        line-height: 1.25;
        color: rgba(15, 23, 42, 0.92);
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .doc .md .sfBands {
        margin-top: 10px;
        display: flex;
        flex-direction: column;
        gap: 12px;
      }

      .doc .md .sfBandGroup {
        border: 1px solid var(--border);
        background: var(--bg1);
        border-radius: 14px;
        overflow: hidden;
      }

      .doc .md .sfBandHeader {
        padding: 10px 12px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        font-weight: 950;
      }

      .doc .md .sfBandRows {
        border-top: 1px solid var(--border2);
      }

      .doc .md .sfBandDetails {
        border-top: 1px solid var(--border2);
      }

      .doc .md .sfBandDetails:first-child {
        border-top: none;
      }

      .doc .md .sfBandDetails > summary {
        list-style: none;
      }

      .doc .md .sfBandDetails > summary::-webkit-details-marker {
        display: none;
      }

      .doc .md .sfBandDetails[open] > summary {
        background: rgba(15, 23, 42, 0.02);
      }

      .doc .md .sfBandDetails > summary .sfExpandCaret {
        transition: transform 160ms ease;
      }

      .doc .md .sfBandDetails[open] > summary .sfExpandCaret {
        transform: rotate(180deg);
      }

      .doc .md .sfBandRow {
        width: 100%;
        border: 0;
        background: transparent;
        padding: 10px 12px;
        text-align: left;
        display: grid;
        grid-template-columns: minmax(180px, 1.35fr) minmax(160px, 2fr) minmax(130px, 0.9fr);
        gap: 10px;
        align-items: center;
        cursor: pointer;
      }

      .doc .md .sfBandRow:hover {
        background: rgba(15, 23, 42, 0.03);
      }

      .doc .md .sfBandRow.sfQuadBest {
        border-left: 4px solid rgba(52, 168, 83, 0.95);
      }
      .doc .md .sfBandRow.sfQuadNoisy {
        border-left: 4px solid rgba(245, 158, 11, 0.95);
      }
      .doc .md .sfBandRow.sfQuadNiche {
        border-left: 4px solid rgba(26, 115, 232, 0.95);
      }
      .doc .md .sfBandRow.sfQuadLow {
        border-left: 4px solid rgba(234, 67, 53, 0.95);
      }

      .doc .md .sfBandName {
        font-weight: 950;
        font-size: 12px;
        line-height: 1.2;
        color: rgba(15, 23, 42, 0.92);
      }

      .doc .md .sfBandBar {
        height: 10px;
        border-radius: 999px;
        background: rgba(15, 23, 42, 0.05);
        border: 1px solid var(--border2);
        overflow: hidden;
      }

      .doc .md .sfBandBarFill {
        height: 100%;
        border-radius: 999px;
        background: linear-gradient(90deg, rgba(26, 115, 232, 0.95), rgba(52, 168, 83, 0.95));
      }

      .doc .md .sfBandMeta {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        justify-content: flex-end;
        align-items: center;
      }

      .doc .md .sfGroupList {
        margin-top: 10px;
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .doc .md .sfGroup {
        border: 1px solid var(--border);
        background: var(--bg1);
        border-radius: 14px;
        overflow: hidden;
      }

      .doc .md .sfGroup > summary {
        list-style: none;
        cursor: pointer;
        padding: 12px 12px;
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 10px;
      }

      .doc .md .sfGroup > summary::-webkit-details-marker {
        display: none;
      }

      .doc .md .sfGroupTitle {
        font-weight: 950;
        font-size: 13px;
        line-height: 1.25;
        color: rgba(15, 23, 42, 0.92);
      }

      .doc .md .sfGroupDesc {
        margin-top: 6px;
        font-size: 12px;
        line-height: 1.35;
        color: rgba(15, 23, 42, 0.72);
      }

      .doc .md .sfGroupBody {
        border-top: 1px solid var(--border2);
        padding: 10px 12px;
      }

      .doc .md .sfVariantRow {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 10px;
        padding: 10px 0;
        border-top: 1px solid var(--border2);
      }

      .doc .md .sfVariantRow:first-of-type {
        border-top: none;
        padding-top: 0;
      }

      .doc .md .sfVariantName {
        font-weight: 900;
        font-size: 12px;
        line-height: 1.2;
        color: rgba(15, 23, 42, 0.90);
      }

      .doc .md .sfVariantMeta {
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        justify-content: flex-end;
        align-items: center;
      }

      .doc .md .sfSegCardGrid {
        margin-top: 10px;
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 10px;
      }

      .doc .md .sfSegCard {
        width: 100%;
        border: 1px solid var(--border);
        background: var(--bg1);
        border-radius: 14px;
        padding: 12px;
        cursor: pointer;
        text-align: left;
      }

      .doc .md .sfSegCard:hover {
        background: rgba(15, 23, 42, 0.02);
      }

      .doc .md .sfSegCard.sfQuadBest {
        border-left: 4px solid rgba(52, 168, 83, 0.95);
      }
      .doc .md .sfSegCard.sfQuadNoisy {
        border-left: 4px solid rgba(245, 158, 11, 0.95);
      }
      .doc .md .sfSegCard.sfQuadNiche {
        border-left: 4px solid rgba(26, 115, 232, 0.95);
      }
      .doc .md .sfSegCard.sfQuadLow {
        border-left: 4px solid rgba(234, 67, 53, 0.95);
      }

      .doc .md .sfSegCardTop {
        display: flex;
        align-items: flex-start;
        justify-content: space-between;
        gap: 10px;
      }

      .doc .md .sfSegCardTitle {
        margin-top: 8px;
        font-weight: 950;
        font-size: 13px;
        line-height: 1.25;
        color: rgba(15, 23, 42, 0.92);
      }

      .doc .md .sfSegCardContext {
        margin-top: 10px;
        font-size: 12px;
        line-height: 1.35;
        color: rgba(15, 23, 42, 0.72);
        display: -webkit-box;
        -webkit-line-clamp: 3;
        -webkit-box-orient: vertical;
        overflow: hidden;
      }

      .printRoot .doc .md .matrix2x2 {
        border-color: rgba(15, 23, 42, 0.14);
        background: rgba(15, 23, 42, 0.02);
      }

      .doc .md .matrix2x2::before {
        content: "";
        position: absolute;
        inset: 0;
        background:
          linear-gradient(
            to right,
            transparent calc(50% - 0.5px),
            rgba(15, 23, 42, 0.18) calc(50% - 0.5px),
            rgba(15, 23, 42, 0.18) calc(50% + 0.5px),
            transparent calc(50% + 0.5px)
          ),
          linear-gradient(
            to bottom,
            transparent calc(50% - 0.5px),
            rgba(15, 23, 42, 0.18) calc(50% - 0.5px),
            rgba(15, 23, 42, 0.18) calc(50% + 0.5px),
            transparent calc(50% + 0.5px)
          );
        pointer-events: none;
        z-index: 1;
      }

      .doc .md .matrix2x2::after {
        content: "";
        position: absolute;
        inset: 0;
        background:
          linear-gradient(rgba(26, 115, 232, 0.10), rgba(26, 115, 232, 0.10)) 0 0 / 50% 50% no-repeat,
          linear-gradient(rgba(52, 168, 83, 0.12), rgba(52, 168, 83, 0.12)) 50% 0 / 50% 50% no-repeat,
          linear-gradient(rgba(234, 67, 53, 0.10), rgba(234, 67, 53, 0.10)) 0 50% / 50% 50% no-repeat,
          linear-gradient(rgba(245, 158, 11, 0.10), rgba(245, 158, 11, 0.10)) 50% 50% / 50% 50% no-repeat;
        pointer-events: none;
        z-index: 0;
      }

      .printRoot .doc .md .matrix2x2::before {
        background:
          linear-gradient(
            to right,
            transparent calc(50% - 0.5px),
            rgba(15, 23, 42, 0.18) calc(50% - 0.5px),
            rgba(15, 23, 42, 0.18) calc(50% + 0.5px),
            transparent calc(50% + 0.5px)
          ),
          linear-gradient(
            to bottom,
            transparent calc(50% - 0.5px),
            rgba(15, 23, 42, 0.18) calc(50% - 0.5px),
            rgba(15, 23, 42, 0.18) calc(50% + 0.5px),
            transparent calc(50% + 0.5px)
          );
      }

      .doc .md .matrixAxisX,
      .doc .md .matrixAxisY {
        position: absolute;
        font-size: 12px;
        color: rgba(15, 23, 42, 0.72);
        letter-spacing: 0;
        text-transform: none;
        font-weight: 950;
        z-index: 3;
      }

      .printRoot .doc .md .matrixAxisX,
      .printRoot .doc .md .matrixAxisY {
        color: rgba(15, 23, 42, 0.65);
      }

      .doc .md .matrixAxisX {
        left: 12px;
        right: 12px;
        bottom: 10px;
        display: flex;
        justify-content: space-between;
      }

      .doc .md .matrixAxisX span,
      .doc .md .matrixAxisY span {
        display: inline-flex;
        align-items: center;
        padding: 4px 8px;
        border-radius: 999px;
        border: 1px solid rgba(15, 23, 42, 0.14);
        background: rgba(255, 255, 255, 0.86);
        box-shadow: none;
      }

      .doc .md .matrixAxisY {
        top: 10px;
        left: 12px;
        bottom: 34px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      .doc .md .sfMatrixLegend {
        position: absolute;
        top: 10px;
        right: 12px;
        z-index: 3;
        display: flex;
        gap: 6px;
        flex-wrap: wrap;
        justify-content: flex-end;
        max-width: min(420px, calc(100% - 24px));
      }

      .doc .md .sfMatrixLegendItem {
        display: inline-flex;
        align-items: center;
        gap: 8px;
        font-size: 11px;
        font-weight: 900;
        color: rgba(15, 23, 42, 0.78);
        border: 1px solid rgba(15, 23, 42, 0.14);
        background: rgba(255, 255, 255, 0.88);
        border-radius: 999px;
        padding: 4px 8px;
        white-space: nowrap;
      }

      .doc .md .sfMatrixLegendItem::before {
        content: "";
        width: 10px;
        height: 10px;
        border-radius: 4px;
        background: rgba(15, 23, 42, 0.12);
      }

      .doc .md .sfMatrixLegendItem.sfQuadBest::before {
        background: rgba(52, 168, 83, 0.95);
      }

      .doc .md .sfMatrixLegendItem.sfQuadNoisy::before {
        background: rgba(245, 158, 11, 0.95);
      }

      .doc .md .sfMatrixLegendItem.sfQuadNiche::before {
        background: rgba(26, 115, 232, 0.95);
      }

      .doc .md .sfMatrixLegendItem.sfQuadLow::before {
        background: rgba(234, 67, 53, 0.95);
      }

      .doc .md .matrixMarker {
        position: absolute;
        transform: translate(-50%, -50%);
        display: inline-flex;
        align-items: center;
        gap: 8px;
        border-radius: 999px;
        padding: 6px 10px;
        border: 1px solid var(--border);
        background: rgba(255, 255, 255, 0.92);
        box-shadow: 0 10px 22px rgba(15, 23, 42, 0.08);
        max-width: 220px;
      }

      .doc .md .matrixPoint {
        --sfPointColor: rgba(26, 115, 232, 0.95);
        --sfPointGlow: rgba(26, 115, 232, 0.16);
        position: absolute;
        transform: translate(-50%, -50%);
        width: 18px;
        height: 18px;
        border-radius: 999px;
        border: 2px solid rgba(255, 255, 255, 0.95);
        background: var(--sfPointColor);
        box-shadow: 0 0 0 4px var(--sfPointGlow), 0 10px 22px rgba(15, 23, 42, 0.10);
        cursor: pointer;
        padding: 0;
        z-index: 2;
      }

      .doc .md .matrixPoint.sfQuadBest {
        --sfPointColor: rgba(52, 168, 83, 0.95);
        --sfPointGlow: rgba(52, 168, 83, 0.18);
      }

      .doc .md .matrixPoint.sfQuadNoisy {
        --sfPointColor: rgba(245, 158, 11, 0.95);
        --sfPointGlow: rgba(245, 158, 11, 0.18);
      }

      .doc .md .matrixPoint.sfQuadNiche {
        --sfPointColor: rgba(26, 115, 232, 0.95);
        --sfPointGlow: rgba(26, 115, 232, 0.18);
      }

      .doc .md .matrixPoint.sfQuadLow {
        --sfPointColor: rgba(234, 67, 53, 0.95);
        --sfPointGlow: rgba(234, 67, 53, 0.18);
      }

      .doc .md .matrixPoint:hover {
        transform: translate(-50%, -50%) scale(1.12);
        box-shadow: 0 0 0 5px var(--sfPointGlow), 0 14px 30px rgba(15, 23, 42, 0.12);
      }

      .doc .md .matrixPoint.sfBubblePoint {
        border: 1.5px solid rgba(255, 255, 255, 0.92);
        box-shadow: 0 10px 22px rgba(15, 23, 42, 0.12);
      }

      .doc .md .matrixPoint.sfBubblePoint:hover {
        transform: translate(-50%, -50%) scale(1.08);
        box-shadow: 0 14px 28px rgba(15, 23, 42, 0.14);
      }

      .doc .md .matrixPoint::after {
        content: attr(data-tooltip);
        position: absolute;
        left: 50%;
        top: -12px;
        transform: translate(-50%, -100%);
        opacity: 0;
        pointer-events: none;
        transition: opacity 120ms ease, transform 120ms ease;
        font-size: 11px;
        font-weight: 900;
        color: rgba(15, 23, 42, 0.92);
        background: rgba(255, 255, 255, 0.92);
        border: 1px solid rgba(15, 23, 42, 0.14);
        border-radius: 14px;
        padding: 10px 12px;
        white-space: pre;
        max-width: 260px;
        box-shadow: 0 16px 34px rgba(15, 23, 42, 0.14);
      }

      .doc .md .matrixPoint:hover::after {
        opacity: 1;
        transform: translate(-50%, -108%);
      }

      .printRoot .doc .md .matrixMarker {
        background: rgba(255, 255, 255, 0.92);
        border-color: rgba(15, 23, 42, 0.16);
        box-shadow: 0 10px 22px rgba(15, 23, 42, 0.08);
      }

      .doc .md .matrixDot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: rgba(26, 115, 232, 0.95);
        box-shadow: 0 0 0 4px rgba(26, 115, 232, 0.16);
        flex: 0 0 auto;
      }

      .doc .md .matrixDot.green {
        background: rgba(52, 168, 83, 0.95);
        box-shadow: 0 0 0 4px rgba(52, 168, 83, 0.16);
      }

      .doc .md .matrixLabel {
        font-size: 12px;
        font-weight: 900;
        color: rgba(15, 23, 42, 0.92);
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }

      .printRoot .doc .md .matrixLabel {
        color: rgba(15, 23, 42, 0.92);
      }

      .doc .md .callout {
        margin-top: 12px;
        border-radius: 14px;
        border: 1px solid rgba(26, 115, 232, 0.22);
        background: rgba(26, 115, 232, 0.06);
        padding: 12px 12px;
      }

      .printRoot .doc .md .callout {
        border-color: rgba(26, 115, 232, 0.22);
        background: rgba(26, 115, 232, 0.06);
      }

      .doc .md .calloutTitle {
        font-weight: 950;
        margin: 0 0 6px;
      }

      /* Funnel / playbook visuals (used in T04â€“T05) */
      .doc .md .funnelRow {
        margin-top: 10px;
        display: grid;
        grid-template-columns: repeat(4, minmax(0, 1fr));
        gap: 10px;
      }

      .doc .md .funnelStep {
        border: 1px solid var(--border);
        background: var(--card2);
        border-radius: 14px;
        padding: 12px 12px;
        min-height: 140px;
      }

      .printRoot .doc .md .funnelStep {
        border-color: rgba(15, 23, 42, 0.14);
        background: rgba(15, 23, 42, 0.02);
      }

      .doc .md .funnelStepTitle {
        font-size: 12px;
        font-weight: 950;
        text-transform: uppercase;
        letter-spacing: 0.06em;
        color: rgba(15, 23, 42, 0.72);
      }

      .printRoot .doc .md .funnelStepTitle {
        color: rgba(15, 23, 42, 0.78);
      }

      .doc .md .funnelStepBody {
        margin-top: 8px;
        font-size: 12px;
        line-height: 1.35;
        color: rgba(15, 23, 42, 0.88);
      }

      .printRoot .doc .md .funnelStepBody {
        color: rgba(15, 23, 42, 0.88);
      }

      .doc .md .funnelChipRow {
        display: flex;
        flex-wrap: wrap;
        gap: 6px;
        margin-top: 10px;
      }

      .doc .md .funnelChip {
        font-size: 11px;
        border: 1px solid var(--border);
        background: var(--bg1);
        border-radius: 999px;
        padding: 5px 9px;
        color: rgba(15, 23, 42, 0.82);
        white-space: nowrap;
      }

      .printRoot .doc .md .funnelChip {
        border-color: rgba(15, 23, 42, 0.14);
        background: rgba(15, 23, 42, 0.03);
        color: rgba(15, 23, 42, 0.88);
      }

      @media (max-width: 980px) {
        .doc .md .funnelRow {
          grid-template-columns: 1fr;
        }
      }

      .doc .md .heatTableWrap {
        margin-top: 10px;
        overflow: auto;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: var(--bg1);
      }

	      .doc .md .heatTableWrap.heatTableWrapLimited {
	        max-height: 720px;
	      }

      .printRoot .doc .md .heatTableWrap {
        border-color: rgba(15, 23, 42, 0.14);
        background: transparent;
      }

      .doc .md table.heatTable {
        margin: 0;
        border: none;
        border-radius: 0;
        width: 100%;
        min-width: 980px;
        table-layout: fixed;
      }

      .printRoot .doc .md table.heatTable {
        min-width: 0;
      }

      .doc .md table.heatTable th,
      .doc .md table.heatTable td {
        padding: 8px 8px;
        font-size: 12px;
        overflow-wrap: anywhere;
      }

      .doc .md table.heatTable.heatTableCompact th,
      .doc .md table.heatTable.heatTableCompact td {
        padding: 6px 6px;
        font-size: 11px;
      }

      .doc .md table.heatTable th {
        position: sticky;
        top: 0;
        z-index: 2;
        background: rgba(246, 248, 252, 0.96);
        color: rgba(15, 23, 42, 0.72);
        border-bottom: 1px solid var(--border2);
      }

      .printRoot .doc .md table.heatTable th {
        position: static;
        background: rgba(15, 23, 42, 0.03);
      }

      .doc .md .heatRowHeader {
        font-weight: 950;
        white-space: nowrap;
      }

      /* Keep row headers visible when scrolling wide matrices */
      .doc .md table.heatTable th.heatRowHeader {
        position: sticky;
        left: 0;
        z-index: 3;
        background: rgba(246, 248, 252, 0.96);
      }

      .doc .md table.heatTable thead th:first-child {
        position: sticky;
        left: 0;
        z-index: 4;
        background: rgba(246, 248, 252, 0.98);
      }

      .printRoot .doc .md table.heatTable th.heatRowHeader,
      .printRoot .doc .md table.heatTable thead th:first-child {
        position: static;
      }

      .doc .md .heatCell {
        font-variant-numeric: tabular-nums;
        vertical-align: top;
      }

      .doc .md .heatTop {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 8px;
      }

      .doc .md .heatValue {
        font-weight: 950;
      }

      .doc .md .heatTag {
        font-size: 10px;
        color: rgba(15, 23, 42, 0.60);
        border: 1px solid var(--border2);
        background: rgba(255, 255, 255, 0.55);
        border-radius: 999px;
        padding: 2px 6px;
        white-space: nowrap;
      }

      .printRoot .doc .md .heatTag {
        color: rgba(15, 23, 42, 0.65);
        border-color: rgba(15, 23, 42, 0.14);
      }

      .doc .md .heatNote {
        margin-top: 6px;
        font-size: 11px;
        color: rgba(15, 23, 42, 0.70);
        line-height: 1.25;
      }

      .printRoot .doc .md .heatNote {
        color: rgba(15, 23, 42, 0.70);
      }

	      .doc .md .heatHdrBtn {
	        border: none;
	        background: transparent;
	        padding: 0;
	        margin: 0;
	        text-align: left;
	        cursor: pointer;
	        color: inherit;
	        font: inherit;
	        display: block;
	        width: 100%;
	      }

	      .doc .md .heatHdrBtn:hover {
	        text-decoration: underline;
	      }
	
	      /* T02 demand map: make matrices more readable */
	      .doc .md table.heatTable.heatTableDemandMap th,
	      .doc .md table.heatTable.heatTableDemandMap td {
	        padding: 10px 10px;
	        font-size: 12px;
	      }
	
	      .doc .md table.heatTable.heatTableDemandMap th.heatRowHeader {
	        white-space: normal;
	        text-align: left;
	      }
	
	      .doc .md table.heatTable.heatTableDemandMap th.heatRowHeader .heatTop {
	        justify-content: flex-start;
	      }
	
	      .doc .md table.heatTable.heatTableDemandMap th.heatRowHeader .heatNote {
	        text-align: left;
	      }
	
	      .doc .md table.heatTable.heatTableDemandMap thead th {
	        text-align: center;
	      }
	
	      .doc .md table.heatTable.heatTableDemandMap thead .heatTop {
	        justify-content: center;
	      }
	
	      .doc .md table.heatTable.heatTableDemandMap thead .heatNote {
	        text-align: center;
	      }
	
	      .doc .md table.heatTable.heatTableDemandMap .heatNote {
	        display: -webkit-box;
	        -webkit-line-clamp: 2;
	        -webkit-box-orient: vertical;
	        overflow: hidden;
	        white-space: normal;
	      }
	
	      .doc .md table.heatTable.heatTableDemandMap thead .heatNote {
	        -webkit-line-clamp: 3;
	      }
	
	      .doc .md table.heatTable.heatTableDemandMap .heatCellInner {
	        display: flex;
	        flex-direction: column;
	        gap: 6px;
	        min-height: 44px;
	      }
	
	      .doc .md table.heatTable.heatTableDemandMap .heatComment {
	        font-size: 10.5px;
	        color: rgba(15, 23, 42, 0.72);
	        line-height: 1.25;
	        display: -webkit-box;
	        -webkit-line-clamp: 2;
	        -webkit-box-orient: vertical;
	        overflow: hidden;
	      }
	
	      .doc .md table.heatTable.heatTableDemandMap .heatComment--irrelevant {
	        color: rgba(15, 23, 42, 0.60);
	      }
	
	      .doc .md table.heatTable.heatTableDemandMap .heatBar {
	        height: 6px;
	        border-radius: 999px;
	        background: rgba(15, 23, 42, 0.10);
	        overflow: hidden;
	      }
	
	      .doc .md table.heatTable.heatTableDemandMap .heatBarFill {
	        display: block;
	        height: 100%;
	        border-radius: 999px;
	      }
	
	      .doc .md .heatBarFill--core {
	        background: rgba(52, 168, 83, 0.55);
	      }
	      .doc .md .heatBarFill--secondary {
	        background: rgba(26, 115, 232, 0.55);
	      }
	      .doc .md .heatBarFill--niche {
	        background: rgba(245, 158, 11, 0.60);
	      }
	      .doc .md .heatBarFill--irrelevant {
	        background: rgba(148, 163, 184, 0.60);
	      }
	
	      .doc .md .heatTag.heatTag--core {
	        border-color: rgba(52, 168, 83, 0.32);
	        background: rgba(52, 168, 83, 0.10);
	        color: rgba(20, 83, 45, 0.92);
	      }
	      .doc .md .heatTag.heatTag--secondary {
	        border-color: rgba(26, 115, 232, 0.32);
	        background: rgba(26, 115, 232, 0.10);
	        color: rgba(26, 115, 232, 0.95);
	      }
	      .doc .md .heatTag.heatTag--niche {
	        border-color: rgba(245, 158, 11, 0.32);
	        background: rgba(245, 158, 11, 0.10);
	        color: rgba(146, 64, 14, 0.92);
	      }
	      .doc .md .heatTag.heatTag--irrelevant {
	        border-color: rgba(148, 163, 184, 0.28);
	        background: rgba(148, 163, 184, 0.08);
	        color: rgba(15, 23, 42, 0.62);
	      }

      .doc .md .heatGroupHdr {
        background: rgba(15, 23, 42, 0.04);
      }

      .doc .md tr.heatGroupRow > th.heatRowHeader {
        background: rgba(15, 23, 42, 0.04);
      }

      .doc .md tr.heatGroupRow > td {
        background: rgba(15, 23, 42, 0.03);
      }

      /* Print: make dense heatmaps readable */
      .printRoot .doc .md table.heatTable th,
      .printRoot .doc .md table.heatTable td {
        padding: 6px 6px;
        font-size: 10px;
      }

      .heat0 {
        background: rgba(148, 163, 184, 0.05);
      }
      .heat1 {
        background: rgba(148, 163, 184, 0.08);
      }
      .heat2 {
        background: rgba(26, 115, 232, 0.10);
      }
      .heat3 {
        background: rgba(26, 115, 232, 0.16);
      }
      .heat4 {
        background: rgba(52, 168, 83, 0.12);
      }
      .heat5 {
        background: rgba(52, 168, 83, 0.18);
      }

      .printRoot .heat0 {
        background: rgba(15, 23, 42, 0.03);
      }
      .printRoot .heat1 {
        background: rgba(15, 23, 42, 0.05);
      }
      .printRoot .heat2 {
        background: rgba(26, 115, 232, 0.10);
      }
      .printRoot .heat3 {
        background: rgba(26, 115, 232, 0.14);
      }
      .printRoot .heat4 {
        background: rgba(52, 168, 83, 0.10);
      }
      .printRoot .heat5 {
        background: rgba(52, 168, 83, 0.14);
      }

      @media (max-width: 980px) {
        .doc .md .kpiGrid {
          grid-template-columns: 1fr;
        }
        .doc .md .vizGrid {
          grid-template-columns: 1fr;
        }
        .doc .md .vizGrid3 {
          grid-template-columns: 1fr;
        }
        .doc .md .barItem {
          grid-template-columns: 1fr;
          gap: 6px;
        }
        .doc .md .barValue {
          text-align: left;
        }
        .doc .md .reportHeader {
          flex-direction: column;
        }
        .doc .md .metaChips {
          justify-content: flex-start;
        }
      }

      .doc .md .redact {
        display: inline-block;
        position: relative;
        background: rgba(15, 23, 42, 0.86);
        color: transparent;
        border-radius: 10px;
        padding: 2px 10px;
        vertical-align: baseline;
      }

      .doc .md .redact::after {
        content: "Ñ‡Ð°ÑÑ‚ÑŒ ÑÐºÑ€Ñ‹Ñ‚Ð°";
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: rgba(255, 255, 255, 0.92);
        font-size: 11px;
        letter-spacing: 0.05em;
        text-transform: uppercase;
        pointer-events: none;
      }

      .doc .md table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
        border: 1px solid var(--border);
        border-radius: 14px;
        overflow: hidden;
        margin: 10px 0;
        background: var(--bg1);
      }

      .doc .md th,
      .doc .md td {
        padding: 10px 10px;
        border-bottom: 1px solid var(--border2);
        border-right: 1px solid var(--border2);
        vertical-align: top;
      }

      .doc .md th:last-child,
      .doc .md td:last-child {
        border-right: none;
      }

      .doc .md tr:last-child td {
        border-bottom: none;
      }

      .doc .md th {
        background: var(--card2);
        font-weight: 900;
      }

      .doc .md code.elementRef {
        cursor: pointer;
        border-color: rgba(26, 115, 232, 0.45);
        background: rgba(26, 115, 232, 0.10);
      }

      .badgeRow {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 10px;
      }

      .badge {
        padding: 6px 10px;
        border-radius: 999px;
        font-size: 12px;
        border: 1px solid var(--border);
        background: var(--card2);
        color: rgba(15, 23, 42, 0.82);
      }

      .badge.click {
        cursor: pointer;
      }

      .badge.click:hover {
        background: rgba(15, 23, 42, 0.06);
      }

      .empty {
        padding: 18px;
        color: var(--muted);
      }

      .modalOverlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 23, 42, 0.38);
        z-index: 100;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 18px;
      }

      .modal {
        width: min(1100px, 96vw);
        max-height: 90vh;
        overflow: auto;
        border-radius: 16px;
        border: 1px solid var(--border);
        background: var(--bg1);
        box-shadow: var(--shadow);
      }

      .modal.modalXL {
        width: min(1600px, 92vw);
        max-height: 88vh;
      }

      .modalXL .doc {
        margin-top: 0;
        padding: 0;
        border: 0;
        background: transparent;
        overflow: visible;
      }

      .modalXL .doc .md {
        font-size: 13px;
        line-height: 1.45;
      }

      .modalXL .doc .md .sfAnalyzerRow {
        grid-template-columns: minmax(340px, 30%) minmax(0, 1fr);
      }

      .modalXL .doc .md .sfAnalyzerViewer,
      .modalXL .doc .md .sfAnalyzerNav,
      .modalXL .doc .md .sfAnalyzerThumbStrip {
        max-width: none;
      }

      .sfModalTabs {
        display: flex;
        gap: 2px;
        flex-wrap: wrap;
        border-bottom: 1px solid var(--border2);
        padding-left: 2px;
      }

      .sfModalTab {
        border: 1px solid var(--border);
        border-bottom: none;
        background: rgba(255, 255, 255, 0.65);
        color: var(--text);
        border-top-left-radius: 12px;
        border-top-right-radius: 12px;
        padding: 9px 12px;
        cursor: pointer;
        font-size: 12px;
        font-weight: 900;
        transition: background 140ms ease, transform 140ms ease, border-color 140ms ease;
        position: relative;
        margin-bottom: -1px;
      }

      .sfModalTab:hover {
        background: var(--card2);
      }

      .sfModalTab.active {
        background: var(--bg1);
        border-color: rgba(26, 115, 232, 0.35);
        transform: translateY(1px);
      }

      .modalHeader {
        position: sticky;
        top: 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 12px;
        padding: 12px 14px;
        border-bottom: 1px solid var(--border2);
        background: rgba(255, 255, 255, 0.94);
        backdrop-filter: blur(10px);
      }

      .modalTitle {
        font-weight: 850;
        font-size: 14px;
      }

      .modalBody {
        padding: 14px;
      }

      /* Print view */
      .printRoot {
        --bg: #ffffff;
        --text: #0f172a;
        --muted: #334155;
        --border: rgba(15, 23, 42, 0.12);
        background: #ffffff;
        color: var(--text);
        min-height: 100vh;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }

      .printTopbar {
        position: sticky;
        top: 0;
        z-index: 5;
        background: rgba(255, 255, 255, 0.94);
        backdrop-filter: blur(8px);
        border-bottom: 1px solid var(--border);
        padding: 12px 16px;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 12px;
      }

      .printTitle {
        font-weight: 900;
        font-size: 14px;
      }

      .printMeta {
        color: var(--muted);
        font-size: 12px;
        margin-top: 3px;
      }

      .printBody {
        padding: 14px;
        max-width: 1040px;
        margin: 0 auto;
      }

      .printTouch {
        padding: 14px 0;
        border-bottom: 1px solid var(--border);
      }

      .printTouch:last-of-type {
        border-bottom: none;
      }

      .printCover {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 14px 14px;
        margin-bottom: 14px;
      }

      .printCoverTitle {
        font-size: 18px;
        font-weight: 950;
        margin: 0;
      }

      .printCoverSub {
        margin-top: 8px;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.4;
      }

      .printSectionTitle {
        margin: 12px 0 8px;
        font-weight: 900;
        font-size: 11px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.06em;
      }

      .printRoot .doc {
        border: 1px solid var(--border);
        background: #ffffff;
      }

      .printRoot .doc .md {
        line-height: 1.4;
        font-size: 12px;
      }

      .printRoot .doc .md h1,
      .printRoot .doc .md h2,
      .printRoot .doc .md h3 {
        margin: 14px 0 8px;
        line-height: 1.2;
      }

      .printRoot .doc .md h1 {
        font-size: 18px;
        font-weight: 950;
        margin-top: 0;
      }

      .printRoot .doc .md h2 {
        font-size: 14px;
        font-weight: 900;
      }

      .printRoot .doc .md h3 {
        font-size: 12px;
        font-weight: 850;
      }

      .printRoot .doc .md table {
        width: 100%;
        border-collapse: collapse;
        margin: 10px 0;
      }

      .printRoot .doc .md th,
      .printRoot .doc .md td {
        border: 1px solid rgba(15, 23, 42, 0.18);
        padding: 8px 9px;
        vertical-align: top;
      }

      .printRoot .doc .md blockquote {
        border-left: 3px solid rgba(15, 23, 42, 0.35);
        background: rgba(15, 23, 42, 0.04);
        padding: 10px 12px;
        border-radius: 10px;
        margin: 10px 0;
      }

      .printRoot .doc .md .redact {
        background: rgba(15, 23, 42, 0.90);
      }

      .printRoot .doc .md .redact::after {
        color: rgba(255, 255, 255, 0.92);
      }

      .noPrint {
        /* hidden by @media print */
      }

      @page {
        size: A4;
        margin: 12mm;
      }

      @media print {
        body {
          background: #ffffff !important;
        }
        .noPrint {
          display: none !important;
        }
        .printTopbar {
          position: static;
          backdrop-filter: none;
          background: #ffffff !important;
          border-bottom: 1px solid #e2e8f0;
        }
        .printBody {
          padding: 0;
          max-width: none;
        }
        .doc {
          box-shadow: none;
        }
        .printTouch {
          break-after: page;
          page-break-after: always;
          border-bottom: none;
          padding: 0;
        }
        .printTouch:last-of-type {
          break-after: auto;
          page-break-after: auto;
        }
        .doc,
        table,
        blockquote,
        pre {
          break-inside: avoid;
          page-break-inside: avoid;
        }

        /* Allow multi-page matrices */
        .heatTableWrap,
        table.heatTable {
          break-inside: auto !important;
          page-break-inside: auto !important;
        }

        .sfScrollY {
          max-height: none !important;
          overflow: visible !important;
        }

        .heatTableWrap {
          max-height: none !important;
          overflow: visible !important;
        }
      }
    </style>
    <link rel="stylesheet" href="./vendor/katex.min.css" />
  </head>
  <body>
    <div id="root"></div>
    <div id="boot" style="padding:18px;color:rgba(255,255,255,0.92);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;">
      Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹ÑÐ°â€¦
    </div>
    <script>
      (function () {
        const bootEl = document.getElementById("boot");
        const show = (msg) => {
          if (!bootEl) return;
          bootEl.style.display = "block";
          bootEl.textContent = String(msg || "");
        };
        window.__SEGFLOW_BOOT_SHOW = show;
        window.addEventListener(
          "error",
          (e) => {
            const message = (e && e.message) || "ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸";
            show(`ÐžÑˆÐ¸Ð±ÐºÐ°: ${message}. ÐžÑ‚ÐºÑ€Ð¾Ð¹ DevTools â†’ Console Ð´Ð»Ñ Ð´ÐµÑ‚Ð°Ð»ÐµÐ¹.`);
          },
          true
        );
        window.addEventListener(
          "unhandledrejection",
          (e) => {
            show("Unhandled promise rejection. ÐžÑ‚ÐºÑ€Ð¾Ð¹ DevTools â†’ Console Ð´Ð»Ñ Ð´ÐµÑ‚Ð°Ð»ÐµÐ¹.");
          },
          true
        );
      })();
    </script>

    <script src="./vendor/react.production.min.js"></script>
    <script src="./vendor/react-dom.production.min.js"></script>
    <script src="./vendor/marked.min.js"></script>
    <script src="./vendor/katex.min.js"></script>
    <script src="./vendor/auto-render.min.js"></script>

    <script src="./sales_nurture_data.js?v=20260118T105132Z"></script>
    <script src="./sales_nurture_bundle.js?v=20260118T105132Z"></script>
    <script src="./sales_nurture_doc_analyzers.js?v=20260118T105132Z"></script>

    <script>
      const { useEffect, useMemo, useRef, useState } = React;

      function safeGetData() {
        return window.SEGFLOW_SALES_NURTURE_DATA || { touches: [] };
      }

      function safeGetBundle() {
        return window.SEGFLOW_SALES_NURTURE_BUNDLE || {};
      }

      function escapeHtml(text) {
        return String(text || "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#39;");
      }

      function mdToHtml(md) {
        if (!md) return "";
        const text = String(md);
        const trimmed = text.trimStart();
        // Many â€œconsulting-styleâ€ reports are authored as HTML snippets (for precise layout).
        // Markdown parsing can accidentally turn indented HTML lines into code blocks.
        // If it looks like an HTML document fragment, render it as-is.
        if (trimmed.startsWith("<")) return trimmed;
        const mk = window.marked;
        if (mk && typeof mk.parse === "function") return mk.parse(text);
        return `<pre>${escapeHtml(text)}</pre>`;
      }

      function filterMarkdownHideJsonBlocks(mdText) {
        if (!mdText) return "";
        const lines = String(mdText).split("\n");
        const out = [];
        let skipping = false;
        let fence = null;

        for (const line of lines) {
          const t = line.trim();
          const fenceMatch = t.match(/^(```|~~~)\s*([a-zA-Z0-9_-]+)?\s*$/);
          if (fenceMatch) {
            const marker = fenceMatch[1];
            const lang = String(fenceMatch[2] || "").toLowerCase();
            if (!skipping) {
              if (lang.startsWith("json")) {
                skipping = true;
                fence = marker;
                continue;
              }
              out.push(line);
              continue;
            }
            if (marker === fence) {
              skipping = false;
              fence = null;
              continue;
            }
            continue;
          }
          if (skipping) continue;
          out.push(line);
        }

        return out.join("\n");
      }

      function renderMathInDom(rootEl) {
        if (!rootEl) return;
        const fn = window.renderMathInElement;
        if (typeof fn !== "function") return;
        try {
          fn(rootEl, {
            delimiters: [
              { left: "$$", right: "$$", display: true },
              { left: "\\\\[", right: "\\\\]", display: true },
              { left: "$", right: "$", display: false },
              { left: "\\\\(", right: "\\\\)", display: false },
            ],
            throwOnError: false,
            ignoredTags: ["script", "noscript", "style", "textarea", "pre", "code"],
          });
        } catch (_) {}
      }

      function safeGetDocAnalyzers() {
        return window.SEGFLOW_DOC_ANALYZERS || {};
      }

      function mountDocAnalyzer(hostEl, analyzer, opts) {
        if (!hostEl) return null;
        const options = opts && typeof opts === "object" ? opts : {};
        const data = analyzer || {};
        const pages = Array.isArray(data.pages) ? data.pages : [];
        const items = Array.isArray(data.items) ? data.items : [];
        const pageTotal = Math.max(1, Number(data.page_count) || pages.length || 1);
        const pdfUrl = String(data.pdf_url || "");

        hostEl.innerHTML = "";
        const abort = new AbortController();
        const state = { page: 1, timer: null, typeTimer: null, activeType: String(options.activeType || "segment") };

        const frame = document.createElement("div");
        frame.className = "sfDocAnalyzerFrame";
        frame.innerHTML = `
          <div class="sfAnalyzerRow sfAnalyzerRowInteractive">
              <div class="sfAnalyzerDoc">
              <div class="sfAnalyzerViewer">
                <img class="sfAnalyzerPageImg" data-role="page-img" alt="${escapeHtml(data.title || "PDF page")}" />
                <div class="sfAnalyzerOverlay" data-role="overlay" aria-hidden="true"></div>
                <div class="sfAnalyzerScanline" aria-hidden="true"></div>
              </div>
              <div class="sfAnalyzerNav">
                <button type="button" class="sfInlineBtn sfAnalyzerNavBtn" data-sf-docnav="prev">â†</button>
                <div class="sfAnalyzerNavLabel">Ð¡Ñ‚Ñ€. <span data-role="page-num">1</span>/<span data-role="page-total">${pageTotal}</span></div>
                <button type="button" class="sfInlineBtn sfAnalyzerNavBtn" data-sf-docnav="next">â†’</button>
              </div>
              <div class="sfAnalyzerThumbStrip" data-role="thumbs" aria-label="Ð¡Ñ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð°"></div>
              <div class="sfSourceActions">
                <a class="sfInlineLink" data-role="pdf-open" href="${escapeHtml(pdfUrl)}#page=1" target="_blank" rel="noopener noreferrer">ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ PDF</a>
                <a class="sfInlineLink" href="${escapeHtml(pdfUrl)}" download>Ð¡ÐºÐ°Ñ‡Ð°Ñ‚ÑŒ PDF</a>
              </div>
              <div class="sfTagRow" data-role="meta"></div>
            </div>

            <div class="sfAnalyzerSide">
              <div class="sfAnalyzerTableWrap" data-role="table-wrap">
                <div class="sfAnalyzerTableHint" data-role="table-hint">Ð¡ÐºÑ€Ð¾Ð»Ð» â†“</div>
                <table class="sfTable">
                  <thead>
                    <tr>
                      <th>Ð¢Ð¸Ð¿</th>
                      <th>ÐšÐ¾Ð´</th>
                      <th>Ð­Ð»ÐµÐ¼ÐµÐ½Ñ‚</th>
                      <th>ÐÐ° ÑÑ‚Ñ€.</th>
                      <th>Ð’ÑÐµÐ³Ð¾</th>
                    </tr>
                  </thead>
                  <tbody data-role="tbody"></tbody>
                </table>
              </div>
              <div class="sfAnalyzerStatus" data-role="status"></div>
              <div class="sfAnalyzerLists">
                <div class="sfAnalyzerList">
                  <div class="sfAnalyzerListTitle" data-role="list-title">Ð­Ð»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹ Ð½Ð° ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ðµ</div>
                  <div class="sfTagRow" data-role="items"></div>
                </div>
              </div>
              <div class="chartNote">Ð’Ð°Ð¶Ð½Ð¾: Ð² Ñ€ÐµÐ°Ð»ÑŒÐ½Ð¾Ð¼ Ð¿Ñ€Ð¾ÐµÐºÑ‚Ðµ extractor Ð¼Ð°Ñ‚Ñ‡Ð¸Ñ‚ÑÑ Ð½Ðµ â€œÐ¿Ð¾ ÑÐ»Ð¾Ð²Ð°Ð¼â€, Ð° Ð¿Ð¾ ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³Ñƒ (synonyms/aliases) + Ð½Ð¾Ñ€Ð¼Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸, Ð¸ ÐºÐ°Ð¶Ð´Ð¾Ðµ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ðµ Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ ÑÑÑ‹Ð»ÐºÑƒ Ð½Ð° evidence (doc+ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ð°+Ñ„Ñ€Ð°Ð³Ð¼ÐµÐ½Ñ‚).</div>
            </div>
          </div>
          <svg class="sfAnalyzerArrows" data-role="arrows" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"></svg>
        `;
        hostEl.appendChild(frame);

        const pageImg = frame.querySelector('[data-role="page-img"]');
        const pageNumEl = frame.querySelector('[data-role="page-num"]');
        const pdfOpenEl = frame.querySelector('[data-role="pdf-open"]');
        const metaEl = frame.querySelector('[data-role="meta"]');
        const statusEl = frame.querySelector('[data-role="status"]');
        const listTitleEl = frame.querySelector('[data-role="list-title"]');
        const itemsEl = frame.querySelector('[data-role="items"]');
        const tbodyEl = frame.querySelector('[data-role="tbody"]');
        const tableWrapEl = frame.querySelector('[data-role="table-wrap"]');
        const thumbsEl = frame.querySelector('[data-role="thumbs"]');
        const arrowsSvg = frame.querySelector('[data-role="arrows"]');
        const overlayEl = frame.querySelector('[data-role="overlay"]');

        const itemByKey = new Map(items.map((item) => [String(item.key || ""), item]));

        const setStatus = (text) => {
          if (!statusEl) return;
          statusEl.textContent = String(text || "");
        };

        const clearEl = (el) => {
          if (!el) return;
          while (el.firstChild) el.removeChild(el.firstChild);
        };

        const updateTableScrollHint = () => {
          if (!tableWrapEl || typeof tableWrapEl.scrollTop !== "number") return;
          const scrollable = tableWrapEl.scrollHeight - tableWrapEl.clientHeight > 6;
          const atBottom = tableWrapEl.scrollTop + tableWrapEl.clientHeight >= tableWrapEl.scrollHeight - 2;
          const show = scrollable && !atBottom;
          tableWrapEl.setAttribute("data-sf-scrollhint", show ? "1" : "0");
        };

        const fmtTag = (text) => `<span class="sfTag">${escapeHtml(text)}</span>`;

        const pageTotalAll = Math.max(pageTotal, Number(data.page_count_total) || 0);
        const countsByType = items.reduce((acc, item) => {
          const t = String((item && item.type) || "");
          if (!t) return acc;
          acc[t] = (acc[t] || 0) + 1;
          return acc;
        }, {});
        const foundSegments = countsByType.segment || 0;
        const foundNeeds = countsByType.need || 0;
        const foundFeatures = countsByType.feature || 0;
        const foundChannels = countsByType.channel || 0;
        const foundSales = countsByType.sales_best_practice || 0;
        const foundTriggers = countsByType.trigger || 0;
        const metaTags = []
          .concat(pageTotalAll > pageTotal ? [fmtTag(`Ð¿Ð¾ÐºÐ°Ð·Ð°Ð½Ð¾: ${pageTotal}/${pageTotalAll} ÑÑ‚Ñ€.`)] : [fmtTag(`ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†: ${pageTotal}`)])
          .concat([fmtTag(`segment: ${foundSegments}`), fmtTag(`need: ${foundNeeds}`)])
          .concat([fmtTag(`feature: ${foundFeatures}`), fmtTag(`channel: ${foundChannels}`), fmtTag(`sales: ${foundSales}`), fmtTag(`trigger: ${foundTriggers}`)])
          .concat([fmtTag(`ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³: ${Number(data.catalog_segments || 21)} ÑÐµÐ³Ð¼.`), fmtTag(`ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³: ${Number(data.catalog_needs || 52)} Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð½.`)]);
        if (metaEl) metaEl.innerHTML = metaTags.join("");

        const clampPage = (n) => Math.max(1, Math.min(pageTotal, Number(n) || 1));
        const getPageInfo = (n) => pages[clampPage(n) - 1] || null;

        const clearArrows = () => {
          if (!arrowsSvg) return;
          arrowsSvg.innerHTML = "";
        };

        const clearOverlay = () => {
          if (!overlayEl) return;
          overlayEl.innerHTML = "";
        };

        const drawArrows = () => {
          if (!arrowsSvg || !pageImg || frame.classList.contains("sfIsScanning")) return;
          const pageInfo = getPageInfo(state.page);
          if (!pageInfo) return;
          const hits = pageInfo.hits || {};

          const frameRect = frame.getBoundingClientRect();
          if (!frameRect.width || !frameRect.height) return;
          const imgRect = pageImg.getBoundingClientRect();

          const w = Math.max(1, frameRect.width);
          const h = Math.max(1, frameRect.height);
          arrowsSvg.setAttribute("viewBox", `0 0 ${w} ${h}`);
          arrowsSvg.setAttribute("width", String(w));
          arrowsSvg.setAttribute("height", String(h));

          const defs = `
            <defs>
              <marker id="sfArrowHead" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="rgba(15, 23, 42, 0.78)"></path>
              </marker>
            </defs>
          `;

          const paths = [];
          const tableRect = tableWrapEl ? tableWrapEl.getBoundingClientRect() : null;
          const rows = frame.querySelectorAll("[data-sf-analyzer-row]");
          rows.forEach((rowEl) => {
            const key = String(rowEl.getAttribute("data-sf-analyzer-row") || "");
            if (!key) return;
            const hit = hits[key];
            if (!hit || !hit.anchor) return;
            const anchor = hit.anchor;
            if (!Array.isArray(anchor) || anchor.length < 2) return;

            const rowRect = rowEl.getBoundingClientRect();
            if (tableRect && (rowRect.bottom < tableRect.top || rowRect.top > tableRect.bottom)) return;
            const startX = imgRect.left - frameRect.left + anchor[0] * imgRect.width;
            const startY = imgRect.top - frameRect.top + anchor[1] * imgRect.height;
            const endX = rowRect.left - frameRect.left - 10;
            const endY = rowRect.top - frameRect.top + rowRect.height / 2;

            const dx = Math.max(80, Math.min(220, (endX - startX) * 0.7));
            const c1x = startX + dx;
            const c2x = endX - Math.min(140, dx * 0.65);
            const d = `M ${startX.toFixed(1)} ${startY.toFixed(1)} C ${c1x.toFixed(1)} ${startY.toFixed(1)}, ${c2x.toFixed(1)} ${endY.toFixed(1)}, ${endX.toFixed(1)} ${endY.toFixed(1)}`;

            const item = itemByKey.get(key);
            const kind = String((item && item.type) || "");
            const stroke =
              {
                segment: "rgba(245, 158, 11, 0.88)",
                need: "rgba(236, 72, 153, 0.82)",
                feature: "rgba(26, 115, 232, 0.86)",
                channel: "rgba(52, 168, 83, 0.82)",
                sales_best_practice: "rgba(124, 58, 237, 0.78)",
                trigger: "rgba(234, 67, 53, 0.80)",
              }[kind] || "rgba(15, 23, 42, 0.55)";
            paths.push(`<path class="sfAnalyzerArrowPath" d="${d}" stroke="${stroke}" marker-end="url(#sfArrowHead)"></path>`);
          });

          arrowsSvg.innerHTML = defs + paths.join("");
        };

	        const renderOverlay = (foundRows, activeType) => {
	          if (!overlayEl || !pageImg || frame.classList.contains("sfIsScanning")) return;
	          const imgRect = pageImg.getBoundingClientRect();
	          if (!imgRect.width || !imgRect.height) return;

	          const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

	          clearOverlay();
	          const rows = Array.isArray(foundRows) ? foundRows : [];
	          const focus = String(activeType || "").trim();

	          const drawFallbackBox = ({ item, hit }) => {
	            if (!item || !hit || !hit.anchor) return;
	            const anchor = hit.anchor;
	            if (!Array.isArray(anchor) || anchor.length < 2) return;
	            const t = String(item.type || "");
	            if (!t) return;

	            const baseW = clamp(imgRect.width * 0.18, 72, 220);
	            const baseH = clamp(imgRect.height * 0.055, 24, 64);
	            const sizeK =
	              {
	                segment: 0.95,
	                need: 1.0,
	                feature: 0.92,
	                channel: 0.88,
	                sales_best_practice: 0.88,
	                trigger: 0.86,
	              }[t] || 0.9;
	            const w = clamp(baseW * sizeK, 64, imgRect.width - 16);
	            const h = clamp(baseH * sizeK, 22, imgRect.height - 16);
	            const x = clamp(anchor[0] * imgRect.width, w / 2 + 8, imgRect.width - w / 2 - 8);
	            const y = clamp(anchor[1] * imgRect.height, h / 2 + 10, imgRect.height - h / 2 - 10);

	            const el = document.createElement("div");
	            el.className = "sfHitBox" + (focus && t !== focus ? " sfHitMuted" : "");
	            el.setAttribute("data-type", t);
	            el.style.left = `${x.toFixed(1)}px`;
	            el.style.top = `${y.toFixed(1)}px`;
	            el.style.width = `${w.toFixed(1)}px`;
	            el.style.height = `${h.toFixed(1)}px`;

	            const code = String(item.code || "").trim();
	            if (code) {
	              const badge = document.createElement("div");
	              badge.className = "sfHitCode";
	              badge.textContent = code;
	              el.appendChild(badge);
	            }
	            overlayEl.appendChild(el);
	          };

	          rows.forEach(({ item, hit }) => {
	            const t = String(item && item.type ? item.type : "");
	            if (!item || !t || !hit) return;

	            const boxes = Array.isArray(hit.boxes) ? hit.boxes : [];
	            if (!boxes.length) {
	              drawFallbackBox({ item, hit });
	              return;
	            }

	            const code = String(item.code || "").trim();
	            boxes.forEach((b, i) => {
	              if (!Array.isArray(b) || b.length < 4) return;
	              const x0 = clamp(Number(b[0]) || 0, 0, 1) * imgRect.width;
	              const y0 = clamp(Number(b[1]) || 0, 0, 1) * imgRect.height;
	              const x1 = clamp(Number(b[2]) || 0, 0, 1) * imgRect.width;
	              const y1 = clamp(Number(b[3]) || 0, 0, 1) * imgRect.height;
	              const w = Math.max(2, x1 - x0);
	              const h = Math.max(2, y1 - y0);

	              const el = document.createElement("div");
	              el.className = "sfHitRect" + (focus && t !== focus ? " sfHitMuted" : "");
	              el.setAttribute("data-type", t);
	              el.style.left = `${x0.toFixed(1)}px`;
	              el.style.top = `${y0.toFixed(1)}px`;
	              el.style.width = `${w.toFixed(1)}px`;
	              el.style.height = `${h.toFixed(1)}px`;

	              if (code && i === 0) {
	                const badge = document.createElement("div");
	                badge.className = "sfHitCode";
	                badge.textContent = code;
	                el.appendChild(badge);
	              }
	              overlayEl.appendChild(el);
	            });
	          });
	        };

        const typeLabel = (t) => {
          const key = String(t || "");
          const map = {
            segment: "Ð¡ÐµÐ³Ð¼ÐµÐ½Ñ‚Ñ‹",
            need: "ÐŸÐ¾Ñ‚Ñ€ÐµÐ±Ð½Ð¾ÑÑ‚Ð¸",
            feature: "Ð¤ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ñ‹Ðµ Ñ€ÐµÑˆÐµÐ½Ð¸Ñ",
            channel: "ÐšÐ°Ð½Ð°Ð»Ñ‹ Ð´Ð¸ÑÑ‚Ñ€Ð¸Ð±ÑƒÑ†Ð¸Ð¸",
            sales_best_practice: "Sales best practices",
            trigger: "Ð¢Ñ€Ð¸Ð³Ð³ÐµÑ€Ñ‹",
          };
          return map[key] || (key ? key : "Ð­Ð»ÐµÐ¼ÐµÐ½Ñ‚Ñ‹");
        };

        const normalizeType = (t) => {
          const v = String(t || "").trim();
          if (!v) return "segment";
          return v;
        };

        const setActiveType = (nextType) => {
          const next = normalizeType(nextType);
          if (next === state.activeType) return;
          state.activeType = next;
          try {
            frame.classList.add("sfTypeSwitching");
            if (state.typeTimer) window.clearTimeout(state.typeTimer);
            state.typeTimer = window.setTimeout(() => {
              state.typeTimer = null;
              try {
                frame.classList.remove("sfTypeSwitching");
              } catch (_) {}
            }, 180);
          } catch (_) {}
          renderResults();
        };

        const renderResults = () => {
          const pageInfo = getPageInfo(state.page);
          if (!pageInfo) return;
          const hits = pageInfo.hits || {};

          const found = items
            .map((item) => ({ item, hit: hits[String(item.key || "")] }))
            .filter((row) => row.hit && row.hit.count);

          const activeType = normalizeType(state.activeType);
          const visible = found.filter((row) => String((row.item && row.item.type) || "") === activeType);

          clearEl(itemsEl);
          clearEl(tbodyEl);
          clearArrows();
          clearOverlay();

          const addTag = (el, text) => {
            if (!el) return;
            const span = document.createElement("span");
            span.className = "sfTag";
            span.textContent = text;
            el.appendChild(span);
          };

          if (listTitleEl) listTitleEl.textContent = `${typeLabel(activeType)} Ð½Ð° ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ðµ`;

          if (!visible.length) {
            if (itemsEl) {
              const span = document.createElement("span");
              span.className = "help";
              span.textContent = "ÐÐµÑ‚ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² Ð½Ð° ÑÑ‚Ð¾Ð¹ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ðµ.";
              itemsEl.appendChild(span);
            }
          } else {
            visible.forEach(({ item, hit }) => {
              const code = item && item.code ? `${String(item.code)} ` : "";
              addTag(itemsEl, `${code}${item.label} (${hit.count})`);
            });
          }

          const addRow = ({ item, hit }) => {
            if (!tbodyEl) return;
            const tr = document.createElement("tr");
            tr.setAttribute("data-sf-analyzer-row", String(item.key || ""));
            tr.innerHTML = `
              <td><span class="sfTag">${escapeHtml(item.type || "")}</span></td>
              <td><b>${escapeHtml(item.code || "â€”")}</b></td>
              <td>${escapeHtml(item.label || "")}</td>
              <td><b>${escapeHtml(String(hit.count || 0))}</b></td>
              <td>${escapeHtml(String((item.totals && item.totals.count) || "â€”"))}</td>
            `;
            tbodyEl.appendChild(tr);
          };

          if (!visible.length) {
            if (tbodyEl) {
              const tr = document.createElement("tr");
              tr.innerHTML = `<td colspan="5" class="help">ÐÐµÑ‚ ÑÐ»ÐµÐ¼ÐµÐ½Ñ‚Ð¾Ð² Ñ‚Ð¸Ð¿Ð° ${escapeHtml(activeType)} Ð½Ð° ÑÑ‚Ð¾Ð¹ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ðµ.</td>`;
              tbodyEl.appendChild(tr);
            }
          } else {
            visible.forEach(addRow);
          }

          if (pdfOpenEl) pdfOpenEl.href = `${pdfUrl}#page=${state.page}`;
          if (pageNumEl) pageNumEl.textContent = String(state.page);
          setStatus(`Ð¡ÐºÐ°Ð½ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹ ${state.page}: ${typeLabel(activeType)} â€” ${visible.length}`);

          requestAnimationFrame(() => {
            updateTableScrollHint();
            drawArrows();
            renderOverlay(found, activeType);
          });
        };

        const updateThumbActive = () => {
          if (!thumbsEl) return;
          thumbsEl.querySelectorAll("[data-sf-docpage]").forEach((btn) => {
            const n = Number(btn.getAttribute("data-sf-docpage") || 0);
            btn.classList.toggle("sfAnalyzerThumbActive", n === state.page);
          });
        };

        const startScan = (nextPage, { animate = true } = {}) => {
          const page = clampPage(nextPage);
          state.page = page;

          if (state.timer) {
            clearTimeout(state.timer);
            state.timer = null;
          }

          updateThumbActive();
          if (pageNumEl) pageNumEl.textContent = String(state.page);
          if (pdfOpenEl) pdfOpenEl.href = `${pdfUrl}#page=${state.page}`;

          clearEl(itemsEl);
          clearEl(tbodyEl);
          clearArrows();
          clearOverlay();
          updateTableScrollHint();

          frame.classList.add("sfIsScanning");
          setStatus(`Ð¡ÐºÐ°Ð½Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñ‹ ${state.page}â€¦`);

          const pageInfo = getPageInfo(state.page);
          if (pageImg && pageInfo) pageImg.src = String(pageInfo.plain || pageInfo.marked || "");

          if (!animate) {
            frame.classList.remove("sfIsScanning");
            if (pageImg && pageInfo) pageImg.src = String(pageInfo.plain || pageInfo.marked || "");
            renderResults();
            return;
          }

          state.timer = setTimeout(() => {
            state.timer = null;
            frame.classList.remove("sfIsScanning");
            if (pageImg && pageInfo) pageImg.src = String(pageInfo.plain || pageInfo.marked || "");
            renderResults();
          }, 650);
        };

        const buildThumbs = () => {
          if (!thumbsEl) return;
          clearEl(thumbsEl);
          pages.forEach((p) => {
            const n = Number(p.page) || 0;
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "sfAnalyzerThumb";
            btn.setAttribute("data-sf-docpage", String(n));
            btn.setAttribute("aria-label", `Ð¡Ñ‚Ñ€Ð°Ð½Ð¸Ñ†Ð° ${n}`);
            btn.innerHTML = `
              <img class="sfAnalyzerThumbImg" src="${escapeHtml(String(p.plain || p.marked || ""))}" alt="Page ${n} preview" />
              <span class="sfAnalyzerThumbNum">${n}</span>
            `;
            thumbsEl.appendChild(btn);
          });
        };

        buildThumbs();

        const onClick = (e) => {
          const target = e.target;
          if (!target || typeof target.closest !== "function") return;
          const nav = target.closest("[data-sf-docnav]");
          if (nav && frame.contains(nav)) {
            const action = nav.getAttribute("data-sf-docnav") || "";
            if (action === "prev") startScan(state.page - 1);
            if (action === "next") startScan(state.page + 1);
            return;
          }
          const thumb = target.closest("[data-sf-docpage]");
          if (thumb && frame.contains(thumb)) {
            const n = Number(thumb.getAttribute("data-sf-docpage") || 0);
            if (Number.isFinite(n) && n) startScan(n);
          }
        };

        frame.addEventListener("click", onClick, { signal: abort.signal });
        window.addEventListener("resize", () => requestAnimationFrame(drawArrows), { signal: abort.signal });
        if (tableWrapEl)
          tableWrapEl.addEventListener(
            "scroll",
            () =>
              requestAnimationFrame(() => {
                updateTableScrollHint();
                drawArrows();
              }),
            { signal: abort.signal }
          );
        if (pageImg)
          pageImg.addEventListener(
            "load",
            () =>
              requestAnimationFrame(() => {
                if (!frame.classList.contains("sfIsScanning")) renderResults();
              }),
            { signal: abort.signal }
          );

        updateThumbActive();
        startScan(1, { animate: true });

        const cleanup = () => {
          abort.abort();
          if (state.timer) clearTimeout(state.timer);
          if (state.typeTimer) clearTimeout(state.typeTimer);
        };
        cleanup.setActiveType = setActiveType;
        cleanup.getActiveType = () => String(state.activeType || "");
        return cleanup;
      }

      const DOC_TRUST_MAP_DEMO = {
        bcg_activewear: "A",
        sporting_goods_2025: "B",
        time_to_move: "B",
        mckinsey_wellness: "A",
        bb_shrinking: "B",
      };

      const trustToScore = (t) => {
        const key = String(t || "").toUpperCase();
        if (key === "A") return 0.88;
        if (key === "B") return 0.72;
        if (key === "C") return 0.56;
        return 0.64;
      };

      const scoreToTrust = (s) => {
        const v = Number(s) || 0;
        if (v >= 0.82) return "A";
        if (v >= 0.66) return "B";
        return "C";
      };

      const normalizeKey = (value) => String(value || "").trim();

      const T01_CATALOG_TABS = [
        { key: "segment", label: "Ð¡ÐµÐ³Ð¼ÐµÐ½Ñ‚Ñ‹" },
        { key: "need", label: "ÐŸÐ¾Ñ‚Ñ€ÐµÐ±Ð½Ð¾ÑÑ‚Ð¸" },
        { key: "feature", label: "Ð¤ÑƒÐ½ÐºÑ†. Ñ€ÐµÑˆÐµÐ½Ð¸Ñ" },
        { key: "channel", label: "ÐšÐ°Ð½Ð°Ð»Ñ‹" },
        { key: "sales_best_practice", label: "Sales BP" },
        { key: "trigger", label: "Ð¢Ñ€Ð¸Ð³Ð³ÐµÑ€Ñ‹" },
      ];

      const normalizeT01CatalogType = (t) => {
        const v = String(t || "").trim();
        const allow = new Set(T01_CATALOG_TABS.map((x) => x.key));
        if (allow.has(v)) return v;
        return "segment";
      };

      const t01CatalogTypeLabel = (t) => {
        const k = normalizeT01CatalogType(t);
        const hit = T01_CATALOG_TABS.find((x) => x.key === k);
        return (hit && hit.label) || k;
      };

      const computeCatalogItemStatsAcrossDocs = (itemType, itemKey, analyzers) => {
        const type = normalizeT01CatalogType(itemType);
        const key = normalizeKey(itemKey);
        const out = { docs: [], docsCount: 0, totalMentions: 0, trust: "B", trustScore: 0.64 };
        if (!key || !analyzers) return out;

        let totalMentions = 0;
        let trustWeighted = 0;
        let trustWeight = 0;
        const docs = [];

        Object.entries(analyzers).forEach(([docKey, doc]) => {
          const items = Array.isArray(doc && doc.items) ? doc.items : [];
          const hit = items.find((it) => it && it.type === type && normalizeKey(it.key) === key);
          if (!hit) return;
          const mentions = Math.max(0, Number(hit.totals && hit.totals.count) || 0);
          if (!mentions) return;
          const pages = Math.max(0, Number(hit.totals && hit.totals.pages) || 0);
          const trustDoc = DOC_TRUST_MAP_DEMO[docKey] || "B";
          const trustScore = trustToScore(trustDoc);
          const w = Math.max(1, mentions);
          totalMentions += mentions;
          trustWeighted += trustScore * w;
          trustWeight += w;
          docs.push({
            key: docKey,
            title: String((doc && doc.title) || docKey || ""),
            pdfUrl: String((doc && doc.pdf_url) || ""),
            mentions,
            pages,
            trust: trustDoc,
          });
        });

        docs.sort((a, b) => b.mentions - a.mentions);
        const avg = trustWeight ? trustWeighted / trustWeight : 0.64;
        out.docs = docs;
        out.docsCount = docs.length;
        out.totalMentions = totalMentions;
        out.trustScore = avg;
        out.trust = scoreToTrust(avg);
        return out;
      };

      const computeCatalogGroupStatsAcrossDocs = (itemType, itemKeys, analyzers) => {
        const type = normalizeT01CatalogType(itemType);
        const keys = Array.isArray(itemKeys)
          ? itemKeys
              .map((k) => normalizeKey(k))
              .filter(Boolean)
              .filter((v, i, arr) => arr.indexOf(v) === i)
          : [];
        const out = { docs: [], docsCount: 0, totalMentions: 0, trust: "B", trustScore: 0.64 };
        if (!keys.length || !analyzers) return out;

        let totalMentions = 0;
        let trustWeighted = 0;
        let trustWeight = 0;
        const docs = [];

        Object.entries(analyzers).forEach(([docKey, doc]) => {
          const items = Array.isArray(doc && doc.items) ? doc.items : [];
          let mentions = 0;
          let pages = 0;

          keys.forEach((k) => {
            const hit = items.find((it) => it && it.type === type && normalizeKey(it.key) === k);
            if (!hit) return;
            const m = Math.max(0, Number(hit.totals && hit.totals.count) || 0);
            if (!m) return;
            mentions += m;
            pages += Math.max(0, Number(hit.totals && hit.totals.pages) || 0);
          });

          if (!mentions) return;
          const trustDoc = DOC_TRUST_MAP_DEMO[docKey] || "B";
          const trustScore = trustToScore(trustDoc);
          const w = Math.max(1, mentions);
          totalMentions += mentions;
          trustWeighted += trustScore * w;
          trustWeight += w;
          docs.push({
            key: docKey,
            title: String((doc && doc.title) || docKey || ""),
            pdfUrl: String((doc && doc.pdf_url) || ""),
            mentions,
            pages,
            trust: trustDoc,
          });
        });

        docs.sort((a, b) => b.mentions - a.mentions);
        const avg = trustWeight ? trustWeighted / trustWeight : 0.64;
        out.docs = docs;
        out.docsCount = docs.length;
        out.totalMentions = totalMentions;
        out.trustScore = avg;
        out.trust = scoreToTrust(avg);
        return out;
      };

      const computeSegmentStatsAcrossDocs = (segmentKey, analyzers) => computeCatalogItemStatsAcrossDocs("segment", segmentKey, analyzers);

      const normalizeLoose = (value) =>
        String(value || "")
          .trim()
          .toLowerCase()
          .replace(/[\u2010-\u2015]/g, "-")
          .replace(/[^a-z0-9]+/gi, " ")
          .replace(/\s+/g, " ")
          .trim();

      const computeSegmentGroupStatsAcrossDocs = (segmentKeys, analyzers) => computeCatalogGroupStatsAcrossDocs("segment", segmentKeys, analyzers);

      const buildT01CatalogGroups = (analyzers, itemType) => {
        const type = normalizeT01CatalogType(itemType);
        const byKey = new Map();

        Object.entries(analyzers || {}).forEach(([docKey, doc]) => {
          const items = Array.isArray(doc && doc.items) ? doc.items : [];
          items.forEach((it) => {
            if (!it || it.type !== type) return;
            const mentions = Math.max(0, Number(it.totals && it.totals.count) || 0);
            if (!mentions) return;
            const pages = Math.max(0, Number(it.totals && it.totals.pages) || 0);
            const key = normalizeKey(it.key);
            if (!key) return;
            const label = String(it.label || (it.detail && it.detail.name) || key);
            const code = String(it.code || "");
            const trustDoc = DOC_TRUST_MAP_DEMO[docKey] || "B";

            const prev = byKey.get(key) || { key, label: "", code: "", detail: null, docs: [], totalMentions: 0, totalPages: 0 };
            if (!prev.label) prev.label = label;
            if (!prev.code) prev.code = code;
            if (!prev.detail && it.detail) prev.detail = it.detail;
            prev.docs.push({
              key: docKey,
              title: String((doc && doc.title) || docKey || ""),
              pdfUrl: String((doc && doc.pdf_url) || ""),
              mentions,
              pages,
              trust: trustDoc,
            });
            prev.totalMentions += mentions;
            prev.totalPages += pages;
            byKey.set(key, prev);
          });
        });

        const groupIdSuffix = (key) => {
          const k = normalizeKey(key);
          if (!k) return "";
          const prefix =
            type === "segment"
              ? "seg_"
              : type === "need"
                ? "need_"
                : type === "feature"
                  ? "feat_"
                  : type === "channel"
                    ? "chan_"
                    : type === "sales_best_practice"
                      ? "sbp_"
                      : type === "trigger"
                        ? "trg_"
                        : "";
          return prefix && k.startsWith(prefix) ? k.slice(prefix.length) : k;
        };

        const assignGroup = (variant) => {
          const labelNorm = normalizeLoose(variant.label || variant.key);

          if (type === "segment") {
            // Gen Z / younger consumers
            if (
              labelNorm.includes("gen z") ||
              labelNorm === "z consumer" ||
              labelNorm.includes(" z consumer") ||
              labelNorm.includes("younger consumer")
            ) {
              return {
                id: "grp_segment_gen_z",
                name: "Gen Z / Younger consumers",
                description: "ÐœÐ¾Ð»Ð¾Ð´Ð¾Ð¹ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð¸Ñ‚ÐµÐ»ÑŒ: Gen Z Ð¸ Ð±Ð»Ð¸Ð·ÐºÐ¸Ðµ Ñ„Ð¾Ñ€Ð¼ÑƒÐ»Ð¸Ñ€Ð¾Ð²ÐºÐ¸ (Z consumer, Younger consumer).",
              };
            }

            // Players in wellness/health ecosystem
            if (labelNorm.includes("player") && (labelNorm.includes("wellness") || labelNorm.includes("health"))) {
              return {
                id: "grp_segment_wellness_players",
                name: "Wellness/Health ecosystem players",
                description: "Ð˜Ð³Ñ€Ð¾ÐºÐ¸ Ñ€Ñ‹Ð½ÐºÐ° wellness/health (wellness/health/mental health player Ð¸ Ñ‚.Ð¿.).",
              };
            }
          }

          if (type === "need") {
            // Mental wellbeing
            if (labelNorm.includes("mental") || labelNorm.includes("mindfulness") || labelNorm.includes("stress")) {
              return {
                id: "grp_need_mental_wellbeing",
                name: "Mental wellbeing",
                description: "ÐŸÑÐ¸Ñ…Ð¾Ð»Ð¾Ð³Ð¸Ñ‡ÐµÑÐºÐ¾Ðµ Ð±Ð»Ð°Ð³Ð¾Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ðµ: mental health / mindfulness / stressâ€‘related Ñ„Ð¾Ñ€Ð¼ÑƒÐ»Ð¸Ñ€Ð¾Ð²ÐºÐ¸.",
              };
            }

            // Weight management
            if (labelNorm.includes("weight")) {
              return {
                id: "grp_need_weight_management",
                name: "Weight management",
                description: "Ð£Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ Ð²ÐµÑÐ¾Ð¼: weight / weight loss / weight management.",
              };
            }

            // Fitness / active lifestyle / performance
            if (labelNorm.includes("fitness") || labelNorm.includes("active lifestyle") || labelNorm.includes("performance")) {
              return {
                id: "grp_need_fitness_performance",
                name: "Fitness / Active lifestyle / Performance",
                description: "Ð¤Ð¸Ñ‚Ð½ÐµÑâ€‘ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚: fitness / active lifestyle / performanceâ€‘related Ñ„Ð¾Ñ€Ð¼ÑƒÐ»Ð¸Ñ€Ð¾Ð²ÐºÐ¸.",
              };
            }

            // Wellness / health / longevity
            if (labelNorm.includes("wellness") || labelNorm === "health" || labelNorm.includes(" health") || labelNorm.includes("longevity")) {
              return {
                id: "grp_need_wellness_health",
                name: "Wellness / Health / Longevity",
                description: "ÐžÐ±Ñ‰Ð¸Ð¹ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÑ Ð¸ selfâ€‘improvement: wellness / health / longevity.",
              };
            }
          }

          const key = normalizeKey(variant.key);
          const context = String((variant.detail && variant.detail.context) || "").trim();
          const idSuffix = groupIdSuffix(key);
          return {
            id: `grp_${type}_${idSuffix || key}`,
            name: String(variant.label || key || "").trim() || key,
            description: context || "Ð“Ñ€ÑƒÐ¿Ð¿Ð° Ð±ÐµÐ· Ð¾Ð±ÑŠÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ (Ð¾Ð´Ð½Ð° Ñ„Ð¾Ñ€Ð¼ÑƒÐ»Ð¸Ñ€Ð¾Ð²ÐºÐ°).",
          };
        };

        const groupsById = new Map();
        Array.from(byKey.values()).forEach((variant) => {
          const meta = assignGroup(variant);
          const g = groupsById.get(meta.id) || { id: meta.id, type, name: meta.name, description: meta.description, variants: [] };
          if (!g.description && meta.description) g.description = meta.description;
          g.variants.push(variant);
          groupsById.set(meta.id, g);
        });

        const groups = Array.from(groupsById.values());
        groups.forEach((g) => {
          const stats = computeCatalogGroupStatsAcrossDocs(
            type,
            g.variants.map((v) => v.key),
            analyzers
          );
          g.stats = stats;
          g.docsCount = stats.docsCount;
          g.totalMentions = stats.totalMentions;
          g.trust = stats.trust;
          g.trustScore = stats.trustScore;
        });
        groups.sort((a, b) => (b.totalMentions || 0) - (a.totalMentions || 0));
        return groups;
      };

      const buildT01SegmentGroups = (analyzers) => buildT01CatalogGroups(analyzers, "segment");

      function syncT01SegmentGroups(rootEl) {
        if (!rootEl) return;
        const scope =
          rootEl && rootEl.classList && rootEl.classList.contains("doc")
            ? rootEl
            : rootEl.closest
              ? rootEl.closest(".doc")
              : null;
        const activeType = normalizeT01CatalogType((scope && scope.getAttribute && scope.getAttribute("data-sf-t01-catalog")) || "segment");
        try {
          if (scope && scope.setAttribute && !scope.getAttribute("data-sf-t01-catalog")) scope.setAttribute("data-sf-t01-catalog", activeType);
        } catch (_) {}

        const analyzers = safeGetDocAnalyzers();
        const groups = buildT01CatalogGroups(analyzers, activeType);

        try {
          rootEl.querySelectorAll("[data-sf-t01-catalog-tabs]").forEach((host) => {
            if (!host) return;
            host.innerHTML = "";
            T01_CATALOG_TABS.forEach((t) => {
              const btn = document.createElement("button");
              btn.type = "button";
              btn.className = "sfModalTab" + (String(t.key) === String(activeType) ? " active" : "");
              btn.setAttribute("data-sf-action", "set_t01_catalog_type");
              btn.setAttribute("data-sf-payload", String(t.key));
              btn.textContent = String(t.label || t.key);
              host.appendChild(btn);
            });
          });
        } catch (_) {}

        try {
          rootEl.querySelectorAll("[data-sf-seg-groups-count], [data-sf-t01-catalog-count]").forEach((el) => (el.textContent = String(groups.length)));
          rootEl.querySelectorAll("[data-sf-t01-catalog-type-label]").forEach((el) => (el.textContent = String(t01CatalogTypeLabel(activeType))));
        } catch (_) {}

        try {
          rootEl.querySelectorAll("[data-sf-seg-groups]").forEach((host) => {
            if (!host) return;
            host.innerHTML = "";

            if (!groups.length) {
              host.innerHTML = `<div class="help">ÐÐµÑ‚ Ð³Ñ€ÑƒÐ¿Ð¿ Ð´Ð»Ñ: ${escapeHtml(t01CatalogTypeLabel(activeType))} (Ð² Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼ Ð´ÐµÐ¼Ð¾).</div>`;
              return;
            }

            const trustScores = groups.map((g) => Number(g.trustScore) || 0).filter((v) => Number.isFinite(v));
            const trustMin = trustScores.length ? Math.min(...trustScores) : 0.5;
            const trustMax = trustScores.length ? Math.max(...trustScores) : 0.9;
            const trustRange = Math.max(1e-6, trustMax - trustMin);
            const maxMentions = Math.max(1, ...groups.map((g) => Number(g.totalMentions) || 0));

            const computeQuadClass = (freqNorm, trustNorm) => {
              const highFreq = Number(freqNorm) >= 0.5;
              const highTrust = Number(trustNorm) >= 0.5;
              if (highFreq && highTrust) return "sfQuadBest";
              if (highFreq && !highTrust) return "sfQuadNoisy";
              if (!highFreq && highTrust) return "sfQuadNiche";
              return "sfQuadLow";
            };

            const buckets = { A: [], B: [], C: [] };
            groups.forEach((g) => {
              const t = String(g.trust || "B").toUpperCase();
              if (t === "A") buckets.A.push(g);
              else if (t === "B") buckets.B.push(g);
              else buckets.C.push(g);
            });

            const wrap = document.createElement("div");
            wrap.className = "sfBands";

            ["A", "B", "C"].forEach((t) => {
              const list = buckets[t];
              if (!list.length) return;

              const groupEl = document.createElement("div");
              groupEl.className = "sfBandGroup";
              groupEl.innerHTML = `
                <div class="sfBandHeader">
                  <div>Trust ${escapeHtml(t)} â€¢ ${escapeHtml(t01CatalogTypeLabel(activeType))}: ${escapeHtml(String(list.length))}</div>
                  <div class="sfTagRow"><span class="sfTag">ÐºÐ»Ð¸Ðº Ð¿Ð¾ ÑÑ‚Ñ€Ð¾ÐºÐµ â†’ Ñ€Ð°ÑÐºÑ€Ñ‹Ñ‚ÑŒ Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ñ‹</span></div>
                </div>
                <div class="sfBandRows" data-role="rows"></div>
              `;

              const rowsEl = groupEl.querySelector('[data-role="rows"]');
              list
                .slice()
                .sort((a, b) => (b.totalMentions || 0) - (a.totalMentions || 0))
                .forEach((g) => {
                  const totalMentions = Math.max(0, Number(g.totalMentions) || 0);
                  const docsCount = Math.max(0, Number(g.docsCount) || 0);
                  const trustScore = Number(g.trustScore) || 0.64;
                  const trustNorm = Math.max(0, Math.min(1, (trustScore - trustMin) / trustRange));
                  const freqNorm = Math.max(0, Math.min(1, Math.log1p(totalMentions) / Math.log1p(maxMentions)));
                  const quadClass = computeQuadClass(freqNorm, trustNorm);

                  const details = document.createElement("details");
                  details.className = `sfBandDetails ${quadClass}`;

                  const summary = document.createElement("summary");
                  summary.className = `sfBandRow ${quadClass}`;
                  const w = Math.max(4, Math.min(100, 100 * (totalMentions / maxMentions)));
                  summary.innerHTML = `
                    <div>
                      <div class="sfBandName">${escapeHtml(String(g.name || ""))}</div>
                      <div class="help" style="margin-top:4px;">Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ñ‹: ${escapeHtml(String((g.variants || []).length))} â€¢ docs: ${escapeHtml(
                    String(docsCount)
                  )}</div>
                    </div>
                    <div class="sfBandBar"><div class="sfBandBarFill" style="width:${w.toFixed(1)}%"></div></div>
                    <div class="sfBandMeta">
                      <span class="sfTag">Î£ ${escapeHtml(String(totalMentions))}</span>
                      <span class="sfTag">trust ${escapeHtml(String(g.trust || "B"))}</span>
                      <span class="sfTag sfExpandCaret">â–¾</span>
                      <button type="button" class="sfInlineBtn" data-sf-action="open_catalog_group_detail" data-sf-payload="${escapeHtml(
                        `${String(activeType)}|${String(g.id || "")}`
                      )}">ÐšÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ°</button>
                    </div>
                  `;
                  details.appendChild(summary);

                  const body = document.createElement("div");
                  body.className = "sfGroupBody";

                  if (g.description) {
                    const desc = document.createElement("div");
                    desc.className = "help";
                    desc.textContent = String(g.description);
                    body.appendChild(desc);
                  }

                  const actions = document.createElement("div");
                  actions.className = "sfSourceActions";
                  actions.innerHTML = `<a class="sfInlineLink" href="#" data-sf-action="open_catalog_group_detail" data-sf-payload="${escapeHtml(
                    `${String(activeType)}|${String(g.id || "")}`
                  )}">ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÑƒ</a>`;
                  body.appendChild(actions);

                  (g.variants || [])
                    .slice()
                    .sort((a, b) => (b.totalMentions || 0) - (a.totalMentions || 0))
                    .forEach((v) => {
                      const row = document.createElement("div");
                      row.className = "sfVariantRow";

                      const left = document.createElement("div");
                      left.innerHTML = `<div class="sfVariantName">${escapeHtml(
                        (v.code ? `${String(v.code)} ` : "") + String(v.label || v.key || "")
                      )}</div>`;
                      row.appendChild(left);

                      const meta = document.createElement("div");
                      meta.className = "sfVariantMeta";
                      (v.docs || [])
                        .slice()
                        .sort((a, b) => (b.mentions || 0) - (a.mentions || 0))
                        .forEach((d) => {
                          const tag = document.createElement("span");
                          tag.className = "sfTag";
                          const label = String(d.title || d.key || "");
                          const short = label.length > 18 ? label.slice(0, 18) + "â€¦" : label;
                          tag.textContent = `${short} (${Number(d.mentions) || 0})`;
                          meta.appendChild(tag);
                        });
                      row.appendChild(meta);

                      body.appendChild(row);
                    });

                  details.appendChild(body);
                  rowsEl && rowsEl.appendChild(details);
                });

              wrap.appendChild(groupEl);
            });

            host.appendChild(wrap);

            // Hide legacy table in this card (demo leftovers).
            try {
              const card = host.closest && host.closest(".chartCard");
              const legacy = card && card.querySelector ? card.querySelector(".sfScrollY") : null;
              if (legacy) legacy.style.display = "none";
            } catch (_) {}
          });
        } catch (_) {}
      }

      function syncT01SegmentGroupVisuals(rootEl) {
        if (!rootEl) return;
        const analyzers = safeGetDocAnalyzers();
        const scope =
          rootEl && rootEl.classList && rootEl.classList.contains("doc")
            ? rootEl
            : rootEl.closest
              ? rootEl.closest(".doc")
              : null;
        const activeType = normalizeT01CatalogType((scope && scope.getAttribute && scope.getAttribute("data-sf-t01-catalog")) || "segment");
        try {
          if (scope && scope.setAttribute && !scope.getAttribute("data-sf-t01-catalog")) scope.setAttribute("data-sf-t01-catalog", activeType);
        } catch (_) {}

        const groups = buildT01CatalogGroups(analyzers, activeType);
        const count = String(groups.length);

        const viz = "constellation";

        try {
          rootEl.querySelectorAll("[data-sf-seg-viz-count], [data-sf-t01-catalog-viz-count]").forEach((el) => (el.textContent = count));
          // Back-compat (older templates).
          rootEl.querySelectorAll("[data-sf-seg-bubbles-count]").forEach((el) => (el.textContent = count));
          rootEl.querySelectorAll("[data-sf-seg-bands-count]").forEach((el) => (el.textContent = count));
          rootEl.querySelectorAll("[data-sf-seg-cards-count]").forEach((el) => (el.textContent = count));
        } catch (_) {}

        // Hide legacy Block 4 (static matrix with demo points).
        try {
          rootEl.querySelectorAll("[data-sf-segment-matrix]").forEach((el) => {
            const card = el && el.closest ? el.closest(".chartCard") : null;
            if (card) card.style.display = "none";
          });
        } catch (_) {}

        // Keep viz buttons in sync.
        try {
          rootEl.querySelectorAll('[data-sf-action="set_t01_seg_viz"]').forEach((btn) => {
            if (!btn || typeof btn.getAttribute !== "function") return;
            btn.classList.toggle("activeTab", String(btn.getAttribute("data-sf-payload") || "") === viz);
          });
        } catch (_) {}

        // Back-compat (older templates).
        try {
          rootEl.querySelectorAll('[data-sf-action="set_t01_seg_view"]').forEach((btn) => {
            if (!btn || typeof btn.getAttribute !== "function") return;
            const p = String(btn.getAttribute("data-sf-payload") || "");
            const mapped = p === "cards" ? "quadrant_deck" : "constellation";
            btn.classList.toggle("activeTab", mapped === viz);
          });
        } catch (_) {}

        const clearVizHosts = () => {
          try {
            rootEl.querySelectorAll("[data-sf-seg-viz]").forEach((host) => {
              if (!host) return;
              try {
                if (typeof host.__sfSegVizCleanup === "function") host.__sfSegVizCleanup();
              } catch (_) {}
              host.__sfSegVizCleanup = null;
              host.innerHTML = "";
            });
          } catch (_) {}
        };

        if (!groups.length) {
          clearVizHosts();
          return;
        }

        const maxMentions = Math.max(1, ...groups.map((g) => Number(g.totalMentions) || 0));
        const maxDocs = Math.max(1, ...groups.map((g) => Number(g.docsCount) || 0));
        const trustScores = groups
          .map((g) => Number(g.trustScore) || 0)
          .filter((v) => Number.isFinite(v));
        const trustMin = trustScores.length ? Math.min(...trustScores) : 0.5;
        const trustMax = trustScores.length ? Math.max(...trustScores) : 0.9;
        const trustRange = Math.max(1e-6, trustMax - trustMin);

        const computeQuadClass = (freqNorm, trustNorm) => {
          const highFreq = Number(freqNorm) >= 0.5;
          const highTrust = Number(trustNorm) >= 0.5;
          if (highFreq && highTrust) return "sfQuadBest";
          if (highFreq && !highTrust) return "sfQuadNoisy";
          if (!highFreq && highTrust) return "sfQuadNiche";
          return "sfQuadLow";
        };

        const groupRecords = groups.map((g, idx) => {
          const totalMentions = Math.max(0, Number(g.totalMentions) || 0);
          const docsCount = Math.max(0, Number(g.docsCount) || 0);
          const trustScore = Number(g.trustScore) || 0.64;
          const trustNorm = Math.max(0, Math.min(1, (trustScore - trustMin) / trustRange));
          const freqNorm = Math.max(0, Math.min(1, Math.log1p(totalMentions) / Math.log1p(maxMentions)));
          const xPct = 8 + 88 * freqNorm;
          const yPct = 10 + 80 * (1 - trustNorm);
          const bubbleSize = 14 + 22 * Math.sqrt(docsCount / maxDocs);
          const quadClass = computeQuadClass(freqNorm, trustNorm);
          const tooltip = [
            g.name || "Group",
            `Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ñ‹: ${(g.variants || []).length}`,
            `docs: ${docsCount}`,
            `Î£ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ð¹: ${totalMentions}`,
            `trust: ${g.trust || "B"} (proxy)`,
          ].join("\n");

          return {
            id: String(g.id || `grp_${idx + 1}`),
            type: activeType,
            name: String(g.name || ""),
            desc: String(g.description || ""),
            code: `G${String(idx + 1).padStart(2, "0")}`,
            totalMentions,
            docsCount,
            trust: String(g.trust || "B"),
            trustScore,
            trustNorm,
            freqNorm,
            xPct,
            yPct,
            bubbleSize,
            quadClass,
            tooltip,
          };
        });

        const applyGroupAttrs = (el, rec) => {
          if (!el) return;
          el.setAttribute("data-sf-action", "open_catalog_group_detail");
          el.setAttribute("data-sf-payload", `${String(rec.type || "segment")}|${String(rec.id || "")}`);
          el.setAttribute("data-sf-name", String(rec.name || ""));
          el.setAttribute("data-sf-docs-count", String(rec.docsCount || 0));
          el.setAttribute("data-sf-mentions-total", String(rec.totalMentions || 0));
          el.setAttribute("data-sf-trust", String(rec.trust || ""));
        };

        const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

        const quadStroke = (quadClass) => {
          if (quadClass === "sfQuadBest") return "rgba(52, 168, 83, 0.72)";
          if (quadClass === "sfQuadNoisy") return "rgba(245, 158, 11, 0.72)";
          if (quadClass === "sfQuadNiche") return "rgba(26, 115, 232, 0.72)";
          return "rgba(234, 67, 53, 0.72)";
        };

	        const attachAutoLayout = (el, fn) => {
	          if (!el || typeof fn !== "function") return () => {};
	          const abort = new AbortController();
	          let fallback = false;
	          let ro = null;
	          try {
	            if (typeof ResizeObserver === "function") {
	              ro = new ResizeObserver(() => {
                try {
                  window.requestAnimationFrame(() => fn());
                } catch (_) {
                  try {
                    fn();
                  } catch (_) {}
                }
              });
              ro.observe(el);
            }
          } catch (_) {}

          const onResize = () => {
            try {
              window.requestAnimationFrame(() => fn());
            } catch (_) {
              try {
                fn();
              } catch (_) {}
            }
	          };
	          try {
	            window.addEventListener("resize", onResize, { signal: abort.signal });
	          } catch (_) {
	            try {
	              window.addEventListener("resize", onResize);
	              fallback = true;
	            } catch (_) {}
	          }

	          return () => {
	            try {
	              abort.abort();
	            } catch (_) {}
	            if (fallback) {
	              try {
	                window.removeEventListener("resize", onResize);
	              } catch (_) {}
	            }
	            try {
	              if (ro) ro.disconnect();
	            } catch (_) {}
	          };
	        };

	        const renderConstellation = (host) => {
	          const plot = document.createElement("div");
	          plot.className = "sfConstellationPlot";
	          plot.innerHTML = `
	            <svg class="sfConstellationLinks" data-role="links" aria-hidden="true" preserveAspectRatio="none"></svg>
	            <div class="sfMatrixLegend">
	              <button type="button" class="sfMatrixLegendItem sfQuadBest" data-sf-action="open_t01_seg_quad_help" data-sf-payload="best">Ð¡Ð¸Ð»ÑŒÐ½Ñ‹Ðµ</button>
	              <button type="button" class="sfMatrixLegendItem sfQuadNoisy" data-sf-action="open_t01_seg_quad_help" data-sf-payload="noisy">Ð¨ÑƒÐ¼</button>
	              <button type="button" class="sfMatrixLegendItem sfQuadNiche" data-sf-action="open_t01_seg_quad_help" data-sf-payload="niche">ÐÐ¸ÑˆÐ°</button>
	              <button type="button" class="sfMatrixLegendItem sfQuadLow" data-sf-action="open_t01_seg_quad_help" data-sf-payload="low">Ð¡Ð»Ð°Ð±Ñ‹Ðµ</button>
	            </div>
	            <div class="matrixAxisX"><span>Ð ÐµÐ´ÐºÐ¾ (Î£)</span><span>Ð§Ð°ÑÑ‚Ð¾ (Î£)</span></div>
	            <div class="matrixAxisY"><span>Ð’Ñ‹ÑÐ¾ÐºÐ¾Ðµ (Ð´Ð¾Ð²ÐµÑ€Ð¸Ðµ)</span><span>ÐÐ¸Ð·ÐºÐ¾Ðµ (Ð´Ð¾Ð²ÐµÑ€Ð¸Ðµ)</span></div>
	          `;

	          const links = plot.querySelector('[data-role="links"]');
	          const chips = [];
	          const lineById = new Map();

	          groupRecords.forEach((rec) => {
	            const point = document.createElement("button");
	            point.type = "button";
	            point.className = `matrixPoint sfConstellationPoint ${rec.quadClass}`;
	            point.style.left = `${rec.xPct.toFixed(1)}%`;
	            point.style.top = `${rec.yPct.toFixed(1)}%`;
	            point.setAttribute("data-tooltip", rec.tooltip || "");
	            point.setAttribute("data-id", String(rec.id || ""));
	            applyGroupAttrs(point, rec);
	            plot.appendChild(point);

	            const chip = document.createElement("button");
	            chip.type = "button";
	            chip.className = `sfConstellationChip ${rec.quadClass}`;
	            chip.style.left = `${rec.xPct.toFixed(1)}%`;
	            chip.style.top = `${rec.yPct.toFixed(1)}%`;
	            chip.style.setProperty("--sfDot", `${clamp(Math.round(6 + 10 * (rec.docsCount / maxDocs)), 6, 16)}px`);
	            chip.setAttribute("data-tooltip", rec.tooltip || "");
	            chip.setAttribute("data-anchor-x", `${rec.xPct}`);
	            chip.setAttribute("data-anchor-y", `${rec.yPct}`);
	            chip.setAttribute("data-id", String(rec.id || ""));
	            applyGroupAttrs(chip, rec);
	            const title = `${rec.code || ""} ${rec.name || ""}`.trim();
	            const short = title.length > 46 ? title.slice(0, 46) + "â€¦" : title;
	            chip.innerHTML = `
	              <span class="sfConstellationDot" aria-hidden="true"></span>
	              <span class="sfConstellationLabel">${escapeHtml(short)}</span>
	              <span class="sfConstellationMeta">Î£ ${escapeHtml(String(rec.totalMentions || 0))}</span>
	            `;
	            plot.appendChild(chip);
	            chips.push(chip);

	            if (links && rec.id) {
	              const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
	              line.setAttribute("data-id", String(rec.id));
	              line.setAttribute("stroke", quadStroke(rec.quadClass));
	              line.setAttribute("stroke-width", "2");
	              line.setAttribute("stroke-linecap", "round");
	              line.setAttribute("opacity", "0.35");
	              links.appendChild(line);
	              lineById.set(String(rec.id), line);
	            }
	          });

		          host.appendChild(plot);

		          const layout = () => {
		            const rect = plot.getBoundingClientRect();
		            const w = rect.width || 0;
		            const h = rect.height || 0;
		            if (!w || !h) return;

		            if (links) {
		              links.setAttribute("viewBox", `0 0 ${w} ${h}`);
		              links.setAttribute("width", `${w}`);
		              links.setAttribute("height", `${h}`);
		            }

		            const pad = 14;
		            const gap = 10;
		            const clampBox = (n) => {
		              n.x = clamp(n.x, pad + n.w / 2, w - pad - n.w / 2);
		              n.y = clamp(n.y, pad + n.h / 2, h - pad - n.h / 2);
		            };

		            const obstacles = [];
		            const addObstacle = (el, extraPad) => {
		              if (!el) return;
		              const r = el.getBoundingClientRect();
		              if (!r.width || !r.height) return;
		              const x = r.left - rect.left + r.width / 2;
		              const y = r.top - rect.top + r.height / 2;
		              obstacles.push({
		                x,
		                y,
		                w: r.width + (Number(extraPad) || 0),
		                h: r.height + (Number(extraPad) || 0),
		              });
		            };
		            addObstacle(plot.querySelector(".sfMatrixLegend"), 14);
		            addObstacle(plot.querySelector(".matrixAxisX"), 10);
		            addObstacle(plot.querySelector(".matrixAxisY"), 10);
		            try {
		              plot.querySelectorAll(".sfConstellationPoint").forEach((el) => addObstacle(el, 26));
		            } catch (_) {}

		            const nodes = chips
		              .map((el, idx) => {
		                const bwRaw = Number(el.offsetWidth) || 140;
		                const bhRaw = Number(el.offsetHeight) || 34;
		                const bw = clamp(bwRaw, 120, Math.max(140, w - pad * 2));
		                const bh = clamp(bhRaw, 28, Math.max(28, h - pad * 2));
		                const axPct = clamp(Number(el.getAttribute("data-anchor-x")) || 50, 0, 100);
		                const ayPct = clamp(Number(el.getAttribute("data-anchor-y")) || 50, 0, 100);
		                const ax = clamp((w * axPct) / 100, pad + bw / 2, w - pad - bw / 2);
		                const ay = clamp((h * ayPct) / 100, pad + bh / 2, h - pad - bh / 2);
		                const id = String(el.getAttribute("data-id") || "");
		                return { el, idx, id, w: bw, h: bh, axPct, ayPct, ax, ay, x: ax, y: ay };
		              })
		              .sort((a, b) => b.w * b.h - a.w * a.h);

		            const signOr = (v, fallback) => {
		              const s = Math.sign(v);
		              return s === 0 ? fallback : s;
		            };

		            const isOverlap = (a, b) => {
		              const dx = b.x - a.x;
		              const dy = b.y - a.y;
		              const ox = a.w / 2 + b.w / 2 + gap - Math.abs(dx);
		              const oy = a.h / 2 + b.h / 2 + gap - Math.abs(dy);
		              return ox > 0 && oy > 0 ? { ox, oy, dx, dy } : null;
		            };

		            const anyOverlap = () => {
		              for (let i = 0; i < nodes.length; i += 1) {
		                for (let j = i + 1; j < nodes.length; j += 1) {
		                  if (isOverlap(nodes[i], nodes[j])) return true;
		                }
		              }
		              for (const n of nodes) {
		                for (const o of obstacles) {
		                  if (isOverlap(n, o)) return true;
		                }
		              }
		              return false;
		            };

		            for (let iter = 0; iter < 220; iter += 1) {
		              for (let i = 0; i < nodes.length; i += 1) {
		                for (let j = i + 1; j < nodes.length; j += 1) {
		                  const a = nodes[i];
		                  const b = nodes[j];
		                  const hit = isOverlap(a, b);
		                  if (!hit) continue;
		                  if (hit.ox < hit.oy) {
		                    const sx = signOr(hit.dx, a.idx < b.idx ? -1 : 1);
		                    a.x -= (sx * hit.ox) / 2;
		                    b.x += (sx * hit.ox) / 2;
		                  } else {
		                    const sy = signOr(hit.dy, a.idx < b.idx ? -1 : 1);
		                    a.y -= (sy * hit.oy) / 2;
		                    b.y += (sy * hit.oy) / 2;
		                  }
		                  clampBox(a);
		                  clampBox(b);
		                }
		              }

		              for (const n of nodes) {
		                for (const o of obstacles) {
		                  const hit = isOverlap(n, o);
		                  if (!hit) continue;
		                  if (hit.ox < hit.oy) {
		                    const sx = signOr(hit.dx, -1);
		                    n.x -= sx * hit.ox;
		                  } else {
		                    const sy = signOr(hit.dy, -1);
		                    n.y -= sy * hit.oy;
		                  }
		                  clampBox(n);
		                }
		              }

		              nodes.forEach((n) => {
		                n.x += (n.ax - n.x) * 0.03;
		                n.y += (n.ay - n.y) * 0.03;
		                clampBox(n);
		              });

		              if (!anyOverlap()) break;
		            }

		            nodes.forEach((n) => {
		              n.el.style.left = `${n.x.toFixed(1)}px`;
		              n.el.style.top = `${n.y.toFixed(1)}px`;
		              if (links && n.id) {
		                const line = lineById.get(String(n.id));
		                if (line) {
		                  const x1 = (w * n.axPct) / 100;
		                  const y1 = (h * n.ayPct) / 100;
		                  line.setAttribute("x1", x1.toFixed(1));
		                  line.setAttribute("y1", y1.toFixed(1));
		                  line.setAttribute("x2", n.x.toFixed(1));
		                  line.setAttribute("y2", n.y.toFixed(1));
		                }
		              }
		            });
		          };

	          let hoverId = "";
	          const setHoverId = (nextId) => {
	            const id = String(nextId || "");
	            if (id === hoverId) return;
	            hoverId = id;

	            plot.classList.toggle("sfHasHover", Boolean(id));
	            try {
	              plot.querySelectorAll('[data-id]').forEach((el) => {
	                const same = id && String(el.getAttribute("data-id") || "") === id;
	                el.classList.toggle("sfHover", Boolean(same));
	              });
	            } catch (_) {}
	            try {
	              if (links) links.querySelectorAll("line[data-id]").forEach((el) => el.classList.toggle("sfHover", id && String(el.getAttribute("data-id") || "") === id));
	            } catch (_) {}
	          };

	          const onMouseOver = (e) => {
	            const t = e && e.target && e.target.closest ? e.target.closest("[data-id]") : null;
	            if (!t || !plot.contains(t)) return;
	            const id = String(t.getAttribute("data-id") || "");
	            if (id) setHoverId(id);
	          };
	          const onMouseLeave = () => setHoverId("");

	          try {
	            plot.addEventListener("mouseover", onMouseOver);
	            plot.addEventListener("mouseleave", onMouseLeave);
	          } catch (_) {}

	          const cleanup = attachAutoLayout(plot, layout);
	          const cleanupHover = () => {
	            try {
	              plot.removeEventListener("mouseover", onMouseOver);
	              plot.removeEventListener("mouseleave", onMouseLeave);
	            } catch (_) {}
	          };
	          try {
	            layout();
	          } catch (_) {}
	          return () => {
	            try {
	              cleanupHover();
	            } catch (_) {}
	            try {
	              if (typeof cleanup === "function") cleanup();
	            } catch (_) {}
	          };
	        };

        const renderQuadrantDeck = (host) => {
          const wrap = document.createElement("div");
          wrap.className = "sfQuadDeck";

          const quads = [
            { key: "sfQuadNiche", title: "ÐÐ¸ÑˆÐ°", subtitle: "Ñ€ÐµÐ´ÐºÐ¾ + Ð´Ð¾Ð²ÐµÑ€Ð¸Ðµ" },
            { key: "sfQuadBest", title: "Ð¡Ð¸Ð»ÑŒÐ½Ñ‹Ðµ", subtitle: "Ñ‡Ð°ÑÑ‚Ð¾ + Ð´Ð¾Ð²ÐµÑ€Ð¸Ðµ" },
            { key: "sfQuadLow", title: "Ð¡Ð»Ð°Ð±Ñ‹Ðµ", subtitle: "Ñ€ÐµÐ´ÐºÐ¾ + Ð½Ð¸Ð·Ðº. Ð´Ð¾Ð²ÐµÑ€Ð¸Ðµ" },
            { key: "sfQuadNoisy", title: "Ð¨ÑƒÐ¼", subtitle: "Ñ‡Ð°ÑÑ‚Ð¾ + Ð½Ð¸Ð·Ðº. Ð´Ð¾Ð²ÐµÑ€Ð¸Ðµ" },
          ];

          const byQuad = new Map(quads.map((q) => [q.key, []]));
          groupRecords.forEach((r) => {
            const k = String(r.quadClass || "");
            if (!byQuad.has(k)) byQuad.set(k, []);
            byQuad.get(k).push(r);
          });

          quads.forEach((q) => {
            const list = (byQuad.get(q.key) || [])
              .slice()
              .sort((a, b) => (b.totalMentions || 0) - (a.totalMentions || 0));

            const panel = document.createElement("div");
            panel.className = `sfQuadPanel ${q.key}`;
            panel.innerHTML = `
              <div class="sfQuadPanelHeader">
                <div>
                  <div class="sfQuadTitle">${escapeHtml(q.title)}</div>
                  <div class="sfQuadSubtitle">${escapeHtml(q.subtitle)}</div>
                </div>
                <div class="sfTagRow"><span class="sfTag">${list.length} Ð³Ñ€ÑƒÐ¿Ð¿</span></div>
              </div>
              <div class="sfQuadPanelList" data-role="list"></div>
            `;

            const listEl = panel.querySelector('[data-role="list"]');
            list.forEach((rec) => {
              const card = document.createElement("button");
              card.type = "button";
              card.className = `sfQuadCard ${rec.quadClass}`;
              applyGroupAttrs(card, rec);
              card.innerHTML = `
                <div class="sfQuadCardTitle">${escapeHtml(`${rec.code} ${rec.name}`)}</div>
                <div class="sfTagRow" style="margin-top:6px;">
                  <span class="sfTag">trust ${escapeHtml(rec.trust || "B")}</span>
                  <span class="sfTag">docs ${escapeHtml(String(rec.docsCount || 0))}</span>
                  <span class="sfTag">Î£ ${escapeHtml(String(rec.totalMentions || 0))}</span>
                </div>
              `;
              listEl && listEl.appendChild(card);
            });

            wrap.appendChild(panel);
          });

          host.appendChild(wrap);
          return null;
        };

        const renderBump = (host) => {
          const wrap = document.createElement("div");
          wrap.className = "sfBump";

          const byTrust = groupRecords
            .slice()
            .sort((a, b) => (b.trustScore || 0) - (a.trustScore || 0) || (b.totalMentions || 0) - (a.totalMentions || 0));
          const byMentions = groupRecords
            .slice()
            .sort((a, b) => (b.totalMentions || 0) - (a.totalMentions || 0) || (b.trustScore || 0) - (a.trustScore || 0));

          wrap.innerHTML = `
            <div class="sfBumpHeader">
              <div>Ð Ð°Ð½Ð³ Ð¿Ð¾ Ð´Ð¾Ð²ÐµÑ€Ð¸ÑŽ</div>
              <div>Ð Ð°Ð½Ð³ Ð¿Ð¾ Ñ‡Ð°ÑÑ‚Ð¾Ñ‚Ðµ (Î£)</div>
            </div>
            <div class="sfBumpBody">
              <svg class="sfBumpSvg" data-role="svg" aria-hidden="true"></svg>
              <div class="sfBumpCol" data-role="left"></div>
              <div class="sfBumpCol" data-role="right"></div>
            </div>
          `;

          const body = wrap.querySelector(".sfBumpBody");
          const left = wrap.querySelector('[data-role="left"]');
          const right = wrap.querySelector('[data-role="right"]');
          const svg = wrap.querySelector('[data-role="svg"]');
          if (!body || !left || !right || !svg) {
            host.appendChild(wrap);
            return null;
          }

          const renderItem = (rec, side) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = `sfBumpItem ${rec.quadClass}`;
            btn.setAttribute("data-id", rec.id);
            btn.setAttribute("data-side", side);
            applyGroupAttrs(btn, rec);
            btn.innerHTML = `
              <div class="sfBumpItemMain">
                <div class="sfBumpItemTitle">${escapeHtml(`${rec.code} ${rec.name}`)}</div>
                <div class="sfBumpItemSub">trust ${escapeHtml(rec.trust || "B")} â€¢ docs ${escapeHtml(String(rec.docsCount || 0))}</div>
              </div>
              <div class="sfBumpMetric">${side === "trust" ? escapeHtml(String((rec.trustScore || 0).toFixed(2))) : escapeHtml(String(rec.totalMentions || 0))}</div>
            `;
            return btn;
          };

          byTrust.forEach((r) => left.appendChild(renderItem(r, "trust")));
          byMentions.forEach((r) => right.appendChild(renderItem(r, "mentions")));

          host.appendChild(wrap);

          const draw = () => {
            const r = body.getBoundingClientRect();
            const w = r.width || 0;
            const h = r.height || 0;
            if (!w || !h) return;

            svg.setAttribute("viewBox", `0 0 ${w} ${h}`);
            svg.setAttribute("width", `${w}`);
            svg.setAttribute("height", `${h}`);
            svg.innerHTML = "";

            const leftById = new Map(Array.from(left.querySelectorAll("[data-id]")).map((el) => [String(el.getAttribute("data-id") || ""), el]));
            const rightById = new Map(Array.from(right.querySelectorAll("[data-id]")).map((el) => [String(el.getAttribute("data-id") || ""), el]));

            groupRecords.forEach((rec) => {
              const l = leftById.get(String(rec.id)) || null;
              const rr = rightById.get(String(rec.id)) || null;
              if (!l || !rr) return;

              const bl = l.getBoundingClientRect();
              const br = rr.getBoundingClientRect();
              const x1 = (bl.right - r.left) + 6;
              const y1 = bl.top - r.top + bl.height / 2;
              const x2 = (br.left - r.left) - 6;
              const y2 = br.top - r.top + br.height / 2;
              const cx = x1 + (x2 - x1) * 0.5;

              const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
              path.setAttribute("d", `M ${x1.toFixed(1)} ${y1.toFixed(1)} C ${cx.toFixed(1)} ${y1.toFixed(1)}, ${cx.toFixed(1)} ${y2.toFixed(1)}, ${x2.toFixed(1)} ${y2.toFixed(1)}`);
              path.setAttribute("fill", "none");
              path.setAttribute("stroke", quadStroke(rec.quadClass));
              path.setAttribute("stroke-width", "2");
              path.setAttribute("opacity", "0.7");
              svg.appendChild(path);
            });
          };

          const cleanup = attachAutoLayout(body, draw);
          try {
            draw();
          } catch (_) {}
          return cleanup;
        };

        const renderSwarm = (host) => {
          const plot = document.createElement("div");
          plot.className = "sfSwarmPlot";
          plot.innerHTML = `
            <div class="sfSwarmLaneLabel" style="top:14%;">Trust A</div>
            <div class="sfSwarmLaneLabel" style="top:48%;">Trust B</div>
            <div class="sfSwarmLaneLabel" style="top:82%;">Trust C</div>
            <div class="matrixAxisX"><span>Ð ÐµÐ´ÐºÐ¾ (Î£)</span><span>Ð§Ð°ÑÑ‚Ð¾ (Î£)</span></div>
          `;

          const dots = [];
          groupRecords.forEach((rec) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = `matrixPoint sfSwarmDot ${rec.quadClass}`;
            btn.style.setProperty("--sfSize", `${clamp(Math.round(10 + 14 * (rec.docsCount / maxDocs)), 10, 24)}px`);
            btn.setAttribute("data-tooltip", rec.tooltip || "");
            btn.setAttribute("data-trust", String(rec.trust || "B").toUpperCase());
            btn.setAttribute("data-freq", `${rec.freqNorm}`);
            applyGroupAttrs(btn, rec);
            plot.appendChild(btn);
            dots.push({ el: btn, rec });
          });

          host.appendChild(plot);

          const layout = () => {
            const rect = plot.getBoundingClientRect();
            const w = rect.width || 0;
            const h = rect.height || 0;
            if (!w || !h) return;

            const padX = 18;
            const lanePadY = 18;
            const lanes = {
              A: { y: h * 0.18, top: h * 0.04, bottom: h * 0.32, placed: [] },
              B: { y: h * 0.50, top: h * 0.36, bottom: h * 0.64, placed: [] },
              C: { y: h * 0.82, top: h * 0.68, bottom: h * 0.96, placed: [] },
            };

            const getR = (el) => (Number.parseFloat(String(el.style.getPropertyValue("--sfSize") || "").replace("px", "")) || 14) / 2;
            const collide = (a, b) => {
              const dx = a.x - b.x;
              const dy = a.y - b.y;
              const rr = a.r + b.r + 3;
              return dx * dx + dy * dy < rr * rr;
            };

            // Reset placed buckets.
            Object.values(lanes).forEach((l) => (l.placed = []));

            dots
              .slice()
              .sort((a, b) => (a.rec.freqNorm || 0) - (b.rec.freqNorm || 0))
              .forEach((d) => {
                const trust = String(d.el.getAttribute("data-trust") || "B");
                const lane = lanes[trust] || lanes.B;
                const freq = clamp(Number(d.rec.freqNorm) || 0, 0, 1);
                const x = padX + freq * (w - padX * 2);
                const r = getR(d.el);
                const y0 = clamp(lane.y, lane.top + lanePadY, lane.bottom - lanePadY);
                const step = 14;

                let yBest = y0;
                for (let i = 0; i < 32; i += 1) {
                  const ring = i === 0 ? 0 : Math.ceil(i / 2);
                  const sign = i % 2 === 1 ? 1 : -1;
                  const y = clamp(y0 + sign * ring * step, lane.top + r + 6, lane.bottom - r - 6);
                  const candidate = { x, y, r };
                  if (!lane.placed.some((p) => collide(candidate, p))) {
                    yBest = y;
                    lane.placed.push(candidate);
                    break;
                  }
                  if (i === 31) {
                    lane.placed.push(candidate);
                    yBest = y;
                  }
                }

                d.el.style.left = `${x.toFixed(1)}px`;
                d.el.style.top = `${yBest.toFixed(1)}px`;
              });
          };

          const cleanup = attachAutoLayout(plot, layout);
          try {
            layout();
          } catch (_) {}
          return cleanup;
        };

        const renderTreemap = (host) => {
          const wrap = document.createElement("div");
          wrap.className = "sfTreemap";
          wrap.innerHTML = `
            <div class="sfTreemapLegend">
              <span class="sfTag">Area = Î£ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ð¹</span>
              <span class="sfTag">Color = trust (A/B/C proxy)</span>
            </div>
          `;

          const items = groupRecords
            .slice()
            .map((r) => ({ rec: r, value: Math.max(1, Number(r.totalMentions) || 0) }))
            .sort((a, b) => b.value - a.value);

          host.appendChild(wrap);

          const squarify = (values, rect) => {
            const out = [];
            const total = values.reduce((s, it) => s + it.value, 0) || 1;
            const list = values.map((it) => ({ ...it, area: (it.value / total) * rect.w * rect.h }));

            const worst = (row, w) => {
              const s = row.reduce((acc, it) => acc + it.area, 0) || 1;
              const maxA = Math.max(...row.map((it) => it.area));
              const minA = Math.min(...row.map((it) => it.area));
              const w2 = w * w;
              return Math.max((w2 * maxA) / (s * s), (s * s) / (w2 * minA));
            };

            const layoutRow = (row, rect) => {
              const s = row.reduce((acc, it) => acc + it.area, 0) || 0;
              const horizontal = rect.w >= rect.h;
              if (horizontal) {
                const rowH = s / rect.w;
                let x = rect.x;
                row.forEach((it) => {
                  const w = it.area / rowH;
                  out.push({ rec: it.rec, x, y: rect.y, w, h: rowH });
                  x += w;
                });
                return { x: rect.x, y: rect.y + rowH, w: rect.w, h: rect.h - rowH };
              }
              const rowW = s / rect.h;
              let y = rect.y;
              row.forEach((it) => {
                const h = it.area / rowW;
                out.push({ rec: it.rec, x: rect.x, y, w: rowW, h });
                y += h;
              });
              return { x: rect.x + rowW, y: rect.y, w: rect.w - rowW, h: rect.h };
            };

            let row = [];
            let remaining = { ...rect };
            let w = Math.min(remaining.w, remaining.h);
            while (list.length) {
              const it = list[0];
              if (!row.length) {
                row.push(it);
                list.shift();
              } else {
                const w1 = worst(row, w);
                const w2 = worst(row.concat([it]), w);
                if (w2 <= w1) {
                  row.push(it);
                  list.shift();
                } else {
                  remaining = layoutRow(row, remaining);
                  row = [];
                  w = Math.min(remaining.w, remaining.h);
                }
              }
            }
            if (row.length) layoutRow(row, remaining);
            return out;
          };

          const layout = () => {
            const rect = wrap.getBoundingClientRect();
            const w = rect.width || 0;
            const h = rect.height || 0;
            if (!w || !h) return;

            // Clear old tiles (keep legend).
            Array.from(wrap.querySelectorAll(".sfTreeTile")).forEach((el) => el.remove());

            const tiles = squarify(items, { x: 10, y: 42, w: Math.max(1, w - 20), h: Math.max(1, h - 52) });
            tiles.forEach((t) => {
              const rec = t.rec;
              const tile = document.createElement("button");
              tile.type = "button";
              tile.className = `sfTreeTile ${rec.quadClass}`;
              tile.setAttribute("data-trust", String(rec.trust || "B").toUpperCase());
              applyGroupAttrs(tile, rec);
              tile.style.left = `${t.x.toFixed(1)}px`;
              tile.style.top = `${t.y.toFixed(1)}px`;
              tile.style.width = `${Math.max(0, t.w).toFixed(1)}px`;
              tile.style.height = `${Math.max(0, t.h).toFixed(1)}px`;

              const title = `${rec.code} ${rec.name}`.trim();
              tile.innerHTML = `
                <div class="sfTreeTitle">${escapeHtml(title)}</div>
                <div class="sfTagRow" style="margin-top:8px;">
                  <span class="sfTag">trust ${escapeHtml(String(rec.trust || "B"))}</span>
                  <span class="sfTag">docs ${escapeHtml(String(rec.docsCount || 0))}</span>
                  <span class="sfTag">Î£ ${escapeHtml(String(rec.totalMentions || 0))}</span>
                </div>
              `;

              wrap.appendChild(tile);
            });
          };

          const cleanup = attachAutoLayout(wrap, layout);
          try {
            layout();
          } catch (_) {}
          return cleanup;
        };

        const renderByViz = (host) => {
          if (!host) return;
          try {
            if (typeof host.__sfSegVizCleanup === "function") host.__sfSegVizCleanup();
          } catch (_) {}
          host.__sfSegVizCleanup = null;
          host.innerHTML = "";

          const fn =
            viz === "quadrant_deck"
              ? renderQuadrantDeck
              : viz === "bump"
                ? renderBump
                : viz === "swarm"
                  ? renderSwarm
                  : viz === "treemap"
                    ? renderTreemap
                    : renderConstellation;
          const cleanup = fn(host);
          if (typeof cleanup === "function") host.__sfSegVizCleanup = cleanup;
        };

        try {
          const hosts = Array.from(rootEl.querySelectorAll("[data-sf-seg-viz]"));
          if (!hosts.length) return;
          hosts.forEach((host) => renderByViz(host));
        } catch (_) {}

        // Back-compat: still fill Confidence Bands if present.
        try {
          rootEl.querySelectorAll("[data-sf-seg-bands]").forEach((host) => {
            if (!host) return;
            host.innerHTML = "";

            const wrap = document.createElement("div");
            wrap.className = "sfBands";

            const buckets = { A: [], B: [], C: [] };
            groupRecords.forEach((r) => {
              const t = String(r.trust || "").toUpperCase();
              if (t === "A") buckets.A.push(r);
              else if (t === "B") buckets.B.push(r);
              else buckets.C.push(r);
            });

            ["A", "B", "C"].forEach((t) => {
              const list = buckets[t];
              if (!list.length) return;

              const g = document.createElement("div");
              g.className = "sfBandGroup";
              g.innerHTML = `
                <div class="sfBandHeader">
                  <div>Trust ${escapeHtml(t)} â€¢ Ð³Ñ€ÑƒÐ¿Ð¿Ñ‹: ${list.length}</div>
                  <div class="sfTagRow"><span class="sfTag">ÑÐ¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²ÐºÐ°: Î£ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ð¹</span></div>
                </div>
                <div class="sfBandRows" data-role="rows"></div>
              `;

              const rowsEl = g.querySelector('[data-role="rows"]');
              list
                .slice()
                .sort((a, b) => (b.totalMentions || 0) - (a.totalMentions || 0))
                .forEach((rec) => {
                  const row = document.createElement("button");
                  row.type = "button";
                  row.className = `sfBandRow ${rec.quadClass}`;
                  applyGroupAttrs(row, rec);

                  const w = Math.max(4, Math.min(100, 100 * (rec.totalMentions / maxMentions)));
                  row.innerHTML = `
                    <div>
                      <div class="sfBandName">${escapeHtml(rec.code || "")} ${escapeHtml(rec.name || "")}</div>
                      <div class="help" style="margin-top:4px;">docs: ${escapeHtml(String(rec.docsCount))}</div>
                    </div>
                    <div class="sfBandBar"><div class="sfBandBarFill" style="width:${w.toFixed(1)}%"></div></div>
                    <div class="sfBandMeta">
                      <span class="sfTag">Î£ ${escapeHtml(String(rec.totalMentions))}</span>
                      <span class="sfTag">trust ${escapeHtml(String(rec.trust || ""))}</span>
                    </div>
                  `;
                  rowsEl && rowsEl.appendChild(row);
                });

              wrap.appendChild(g);
            });

            host.appendChild(wrap);
          });
        } catch (_) {}
      }

      function syncT01FromDocAnalyzer(rootEl, analyzerKey) {
        if (!rootEl) return;
        const analyzers = safeGetDocAnalyzers();
        const key = normalizeKey(analyzerKey);
        const analyzer = analyzers && analyzers[key];
        if (!analyzer) return;

        const items = Array.isArray(analyzer.items) ? analyzer.items : [];
        const segItems = items.filter((it) => it && it.type === "segment");

        try {
          const count = String(segItems.length);
          rootEl.querySelectorAll("[data-sf-segments-count]").forEach((el) => (el.textContent = count));
          rootEl.querySelectorAll("[data-sf-segment-matrix-count]").forEach((el) => (el.textContent = count));
          rootEl.querySelectorAll("[data-sf-seg-bubbles-count]").forEach((el) => (el.textContent = count));
          rootEl.querySelectorAll("[data-sf-seg-bands-count]").forEach((el) => (el.textContent = count));
          rootEl.querySelectorAll("[data-sf-seg-cards-count]").forEach((el) => (el.textContent = count));
        } catch (_) {}

        const statsByKey = new Map(segItems.map((s) => [normalizeKey(s.key), computeSegmentStatsAcrossDocs(s.key, analyzers)]));
        const maxMentions = Math.max(1, ...segItems.map((s) => (statsByKey.get(normalizeKey(s.key)) || {}).totalMentions || 0));
        const maxDocs = Math.max(1, ...segItems.map((s) => (statsByKey.get(normalizeKey(s.key)) || {}).docsCount || 0));

        const trustScores = segItems
          .map((s) => {
            const st = statsByKey.get(normalizeKey(s.key)) || {};
            return Number(st.trustScore) || 0;
          })
          .filter((v) => Number.isFinite(v));
        const trustMin = trustScores.length ? Math.min(...trustScores) : 0;
        const trustMax = trustScores.length ? Math.max(...trustScores) : 1;
        const trustRange = Math.max(1e-6, trustMax - trustMin);

        const applySegmentAttrs = (el, rec) => {
          if (!el) return;
          el.setAttribute("data-sf-action", "open_segment_detail");
          el.setAttribute("data-sf-payload", String(rec.payload || rec.key || ""));
          el.setAttribute("data-sf-name", String(rec.name || ""));
          el.setAttribute("data-sf-mentions", String(rec.docMentions || 0));
          el.setAttribute("data-sf-context", String(rec.context || ""));
          el.setAttribute("data-sf-evidence", String(rec.evidence || ""));
          el.setAttribute("data-sf-doc-key", key);
          el.setAttribute("data-sf-docs-count", String(rec.docsCount || 0));
          el.setAttribute("data-sf-mentions-total", String(rec.totalMentions || 0));
          el.setAttribute("data-sf-trust", String(rec.trust || ""));
        };

        const computeQuadClass = (xPct, trustNorm) => {
          const highFreq = Number(xPct) >= 50;
          const highTrust = Number(trustNorm) >= 0.5;
          if (highFreq && highTrust) return "sfQuadBest";
          if (highFreq && !highTrust) return "sfQuadNoisy";
          if (!highFreq && highTrust) return "sfQuadNiche";
          return "sfQuadLow";
        };

        const segRecords = segItems
          .map((seg) => {
            const detail = seg.detail || {};
            const segKey = normalizeKey(seg.key);
            const name = String(detail.name || seg.label || "");
            const payload = String(detail.payload || seg.key || "");
            const docMentions = Math.max(0, Number(seg.totals && seg.totals.count) || 0);
            const context = String(detail.context || "");
            const evidence = String(detail.evidence || "PDF extract");
            const stats = statsByKey.get(segKey) || computeSegmentStatsAcrossDocs(segKey, analyzers);
            const totalMentions = Math.max(0, Number(stats.totalMentions) || 0);
            const docsCount = Math.max(0, Number(stats.docsCount) || 0);
            const trustScore = Number(stats.trustScore) || 0;
            const trustNorm = Math.max(0, Math.min(1, (trustScore - trustMin) / trustRange));
            const freqNorm = Math.max(0, Math.min(1, Math.log1p(Math.max(0, totalMentions)) / Math.log1p(maxMentions)));
            const xPct = 10 + 80 * freqNorm;
            const yPct = 10 + 80 * (1 - trustNorm);
            const quadClass = computeQuadClass(xPct, trustNorm);
            const bubbleSize = 14 + 22 * Math.sqrt(Math.max(0, docsCount) / maxDocs);
            const tooltip = [
              `${String(seg.code || "").trim()} ${String(name || "").trim()}`.trim(),
              `Ð² PDF: ${docMentions} â€¢ Î£ ${totalMentions} (docs ${docsCount})`,
              `trust: ${stats.trust || ""} (proxy)`,
            ]
              .filter(Boolean)
              .join("\n");

            return {
              key: String(seg.key || ""),
              segKey,
              payload,
              code: String(seg.code || ""),
              name,
              docMentions,
              totalMentions,
              docsCount,
              trust: String(stats.trust || ""),
              trustScore,
              trustNorm,
              freqNorm,
              xPct,
              yPct,
              quadClass,
              bubbleSize,
              context,
              evidence,
              tooltip,
            };
          })
          .sort((a, b) => b.totalMentions - a.totalMentions);

        try {
          rootEl.querySelectorAll("[data-sf-segments-tbody]").forEach((tbody) => {
            if (!tbody) return;
            while (tbody.firstChild) tbody.removeChild(tbody.firstChild);

            if (!segItems.length) {
              const tr = document.createElement("tr");
              tr.innerHTML = `<td colspan="4" style="color:rgba(15,23,42,0.70);">ÐÐµÑ‚ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð² Ð² ÑÑ‚Ð¾Ð¼ PDF (Ð¿Ð¾ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼Ñƒ extractorâ€‘Ð´ÐµÐ¼Ð¾).</td>`;
              tbody.appendChild(tr);
              return;
            }

            segItems
              .slice()
              .sort((a, b) => (Number(b.totals && b.totals.count) || 0) - (Number(a.totals && a.totals.count) || 0))
              .forEach((seg) => {
                const detail = seg.detail || {};
                const name = String(detail.name || seg.label || "");
                const docMentions = Math.max(0, Number(seg.totals && seg.totals.count) || 0);
                const stats = computeSegmentStatsAcrossDocs(seg.key, analyzers);
                const context = String(detail.context || "");
                const evidence = String(detail.evidence || "PDF extract");

                const tr = document.createElement("tr");
                tr.className = "sfRowLink";
                tr.setAttribute("data-sf-action", "open_segment_detail");
                tr.setAttribute("data-sf-payload", String(detail.payload || seg.key || ""));
                tr.setAttribute("data-sf-name", name);
                tr.setAttribute("data-sf-mentions", String(docMentions));
                tr.setAttribute("data-sf-context", context);
                tr.setAttribute("data-sf-evidence", evidence);
                tr.setAttribute("data-sf-doc-key", key);
                tr.setAttribute("data-sf-docs-count", String(stats.docsCount));
                tr.setAttribute("data-sf-mentions-total", String(stats.totalMentions));
                tr.setAttribute("data-sf-trust", String(stats.trust || ""));

                const corpusNote = stats.docsCount ? `Î£ ${stats.totalMentions} â€¢ docs ${stats.docsCount} â€¢ trust ${stats.trust}` : "â€”";
                tr.innerHTML = `
                  <td><b>${escapeHtml(seg.code || "")} ${escapeHtml(name)}</b></td>
                  <td><b>${escapeHtml(String(docMentions))}</b><div class="help" style="margin-top:4px;">${escapeHtml(corpusNote)}</div></td>
                  <td>${escapeHtml(context || "â€”")}</td>
                  <td><span class="sfTag">${escapeHtml(evidence)}</span> <span class="sfTag">trust: ${escapeHtml(stats.trust)}</span></td>
                `;
                tbody.appendChild(tr);
              });
          });
        } catch (_) {}

        try {
          rootEl.querySelectorAll("[data-sf-seg-bubbles]").forEach((host) => {
            if (!host) return;
            host.innerHTML = "";

            if (!segRecords.length) {
              host.innerHTML = `<div class="help">ÐÐµÑ‚ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð² Ð´Ð»Ñ Ð²Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ (Ð¿Ð¾ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼Ñƒ extractorâ€‘Ð´ÐµÐ¼Ð¾).</div>`;
              return;
            }

            const plot = document.createElement("div");
            plot.className = "sfBubblePlot";
            plot.innerHTML = `
              <div class="sfMatrixLegend">
                <span class="sfMatrixLegendItem sfQuadBest">Ð¡Ð¸Ð»ÑŒÐ½Ñ‹Ðµ</span>
                <span class="sfMatrixLegendItem sfQuadNoisy">Ð¨ÑƒÐ¼</span>
                <span class="sfMatrixLegendItem sfQuadNiche">ÐÐ¸ÑˆÐ°</span>
                <span class="sfMatrixLegendItem sfQuadLow">Ð¡Ð»Ð°Ð±Ñ‹Ðµ</span>
              </div>
              <div class="matrixAxisX"><span>Ð ÐµÐ´ÐºÐ¾ (Î£ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ð¹)</span><span>Ð§Ð°ÑÑ‚Ð¾ (Î£ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ð¹)</span></div>
              <div class="matrixAxisY"><span>Ð’Ñ‹ÑÐ¾ÐºÐ¾Ðµ (Ð´Ð¾Ð²ÐµÑ€Ð¸Ðµ)</span><span>ÐÐ¸Ð·ÐºÐ¾Ðµ (Ð´Ð¾Ð²ÐµÑ€Ð¸Ðµ)</span></div>
            `;

            segRecords.forEach((rec) => {
              const btn = document.createElement("button");
              btn.type = "button";
              btn.className = `matrixPoint sfBubblePoint ${rec.quadClass}`;
              btn.style.left = `${rec.xPct.toFixed(1)}%`;
              btn.style.top = `${rec.yPct.toFixed(1)}%`;
              btn.style.setProperty("--sfSize", `${rec.bubbleSize.toFixed(0)}px`);
              btn.setAttribute("data-label", String(rec.code || rec.name || "").slice(0, 16));
              btn.setAttribute("data-tooltip", rec.tooltip || "");
              applySegmentAttrs(btn, rec);
              plot.appendChild(btn);
            });

            host.appendChild(plot);
          });
        } catch (_) {}

        try {
          rootEl.querySelectorAll("[data-sf-seg-bands]").forEach((host) => {
            if (!host) return;
            host.innerHTML = "";
            if (!segRecords.length) {
              host.innerHTML = `<div class="help">ÐÐµÑ‚ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð² Ð´Ð»Ñ Ð²Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ (Ð¿Ð¾ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼Ñƒ extractorâ€‘Ð´ÐµÐ¼Ð¾).</div>`;
              return;
            }

            const wrap = document.createElement("div");
            wrap.className = "sfBands";

            const groups = { A: [], B: [], C: [] };
            segRecords.forEach((r) => {
              const t = String(r.trust || "").toUpperCase();
              if (t === "A") groups.A.push(r);
              else if (t === "B") groups.B.push(r);
              else groups.C.push(r);
            });

            const groupOrder = ["A", "B", "C"];
            groupOrder.forEach((t) => {
              const list = groups[t];
              if (!list.length) return;

              const g = document.createElement("div");
              g.className = "sfBandGroup";
              g.innerHTML = `
                <div class="sfBandHeader">
                  <div>Trust ${escapeHtml(t)} â€¢ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ñ‹: ${list.length}</div>
                  <div class="sfTagRow"><span class="sfTag">ÑÐ¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²ÐºÐ°: Î£ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ð¹</span></div>
                </div>
                <div class="sfBandRows" data-role="rows"></div>
              `;

              const rowsEl = g.querySelector('[data-role="rows"]');
              list.forEach((rec) => {
                const row = document.createElement("button");
                row.type = "button";
                row.className = `sfBandRow ${rec.quadClass}`;
                applySegmentAttrs(row, rec);

                const w = Math.max(4, Math.min(100, 100 * rec.freqNorm));
                row.innerHTML = `
                  <div>
                    <div class="sfBandName">${escapeHtml(rec.code || "")} ${escapeHtml(rec.name || "")}</div>
                    <div class="help" style="margin-top:4px;">Ð² PDF: ${escapeHtml(String(rec.docMentions))} â€¢ docs: ${escapeHtml(String(rec.docsCount))}</div>
                  </div>
                  <div class="sfBandBar"><div class="sfBandBarFill" style="width:${w.toFixed(1)}%"></div></div>
                  <div class="sfBandMeta">
                    <span class="sfTag">Î£ ${escapeHtml(String(rec.totalMentions))}</span>
                    <span class="sfTag">trust ${escapeHtml(String(rec.trust || ""))}</span>
                  </div>
                `;
                rowsEl && rowsEl.appendChild(row);
              });

              wrap.appendChild(g);
            });

            host.appendChild(wrap);
          });
        } catch (_) {}

        try {
          rootEl.querySelectorAll("[data-sf-seg-cards]").forEach((host) => {
            if (!host) return;
            host.innerHTML = "";
            if (!segRecords.length) {
              host.innerHTML = `<div class="help">ÐÐµÑ‚ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð² Ð´Ð»Ñ Ð²Ð¸Ð·ÑƒÐ°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸ (Ð¿Ð¾ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼Ñƒ extractorâ€‘Ð´ÐµÐ¼Ð¾).</div>`;
              return;
            }

            const grid = document.createElement("div");
            grid.className = "sfSegCardGrid";

            segRecords.forEach((rec) => {
              const card = document.createElement("button");
              card.type = "button";
              card.className = `sfSegCard ${rec.quadClass}`;
              applySegmentAttrs(card, rec);
              card.innerHTML = `
                <div class="sfSegCardTop">
                  <div class="sfTagRow">
                    ${rec.code ? `<span class="sfTag">${escapeHtml(rec.code)}</span>` : ""}
                    ${rec.trust ? `<span class="sfTag">trust: ${escapeHtml(rec.trust)} (proxy)</span>` : ""}
                    <span class="sfTag">docs: ${escapeHtml(String(rec.docsCount))}</span>
                  </div>
                  <div class="sfTagRow" style="justify-content:flex-end;">
                    <span class="sfTag">Ð² PDF: ${escapeHtml(String(rec.docMentions))}</span>
                    <span class="sfTag">Î£: ${escapeHtml(String(rec.totalMentions))}</span>
                  </div>
                </div>
                <div class="sfSegCardTitle">${escapeHtml(rec.name || rec.payload || "")}</div>
                <div class="sfSegCardContext">${escapeHtml(rec.context || "â€”")}</div>
              `;
              grid.appendChild(card);
            });

            host.appendChild(grid);
          });
        } catch (_) {}

        try {
          rootEl.querySelectorAll("[data-sf-segment-matrix]").forEach((matrix) => {
            if (!matrix) return;
            matrix.querySelectorAll(".matrixPoint").forEach((el) => el.remove());

            if (!segItems.length) return;

            segItems.forEach((seg) => {
              const detail = seg.detail || {};
              const segKey = normalizeKey(seg.key);
              const name = String(detail.name || seg.label || "");
              const context = String(detail.context || "");
              const evidence = String(detail.evidence || "PDF extract");
              const docMentions = Math.max(0, Number(seg.totals && seg.totals.count) || 0);
              const stats = statsByKey.get(segKey) || computeSegmentStatsAcrossDocs(segKey, analyzers);

              const x = 10 + (85 * Math.log1p(Math.max(0, stats.totalMentions))) / Math.log1p(maxMentions);
              const y = 10 + 80 * (1 - Math.max(0, Math.min(1, stats.trustScore)));

              const btn = document.createElement("button");
              btn.type = "button";
              btn.className = "matrixPoint";
              btn.style.left = `${x.toFixed(1)}%`;
              btn.style.top = `${y.toFixed(1)}%`;
              const highFreq = x >= 50;
              const highTrust = y <= 50;
              if (highFreq && highTrust) btn.classList.add("sfQuadBest");
              else if (highFreq && !highTrust) btn.classList.add("sfQuadNoisy");
              else if (!highFreq && highTrust) btn.classList.add("sfQuadNiche");
              else btn.classList.add("sfQuadLow");
              const tooltip = [
                `${String(seg.code || "").trim()} ${String(name || "").trim()}`.trim(),
                `Ð² PDF: ${docMentions} â€¢ Î£ ${stats.totalMentions} (docs ${stats.docsCount})`,
                `trust: ${stats.trust} (proxy)`,
              ]
                .filter(Boolean)
                .join("\n");
              btn.setAttribute("data-label", String(seg.code || name || "").slice(0, 16));
              btn.setAttribute("data-tooltip", tooltip);
              btn.setAttribute("data-sf-action", "open_segment_detail");
              btn.setAttribute("data-sf-payload", String(detail.payload || seg.key || ""));
              btn.setAttribute("data-sf-name", name);
              btn.setAttribute("data-sf-mentions", String(docMentions));
              btn.setAttribute("data-sf-context", context);
              btn.setAttribute("data-sf-evidence", evidence);
              btn.setAttribute("data-sf-doc-key", key);
              btn.setAttribute("data-sf-docs-count", String(stats.docsCount));
              btn.setAttribute("data-sf-mentions-total", String(stats.totalMentions));
              btn.setAttribute("data-sf-trust", String(stats.trust || ""));
              matrix.appendChild(btn);
            });
          });
        } catch (_) {}
      }

      function MarkdownViewer({ md, onAction }) {
        const rootRef = useRef(null);
        const html = useMemo(() => mdToHtml(md || ""), [md]);

        useEffect(() => {
          const rootEl = rootRef.current;
          if (!rootEl) return;
          renderMathInDom(rootEl);
        }, [html]);

        useEffect(() => {
          const rootEl = rootRef.current;
          if (!rootEl) return;
          if (typeof onAction !== "function") return;

          const onClick = (e) => {
            try {
              const target = e.target;
              if (!target || typeof target.closest !== "function") return;
              const el = target.closest("[data-sf-action]");
              if (!el || !rootEl.contains(el)) return;
              const action = el.getAttribute("data-sf-action") || "";
              const payload = el.getAttribute("data-sf-payload") || "";
              e.preventDefault();
              onAction(action, payload, el);
            } catch (_) {}
          };

          rootEl.addEventListener("click", onClick);
          return () => rootEl.removeEventListener("click", onClick);
        }, [html, onAction]);

        useEffect(() => {
          const rootEl = rootRef.current;
          if (!rootEl) return;

          const renderSegmentNeedMatrix = (container) => {
            const heatClass = (score) => {
              const s = Number(score) || 0;
              if (s < 15) return "heat0";
              if (s < 30) return "heat1";
              if (s < 45) return "heat2";
              if (s < 60) return "heat3";
              if (s < 80) return "heat4";
              return "heat5";
            };

            const clamp = (v, min, max) => Math.min(max, Math.max(min, v));

            const hash32 = (str) => {
              const s = String(str || "");
              let h = 2166136261;
              for (let i = 0; i < s.length; i += 1) {
                h ^= s.charCodeAt(i);
                h = Math.imul(h, 16777619);
              }
              return h >>> 0;
            };

            const extractCatalogTable = (sel, rowMap) => {
              const table = rootEl.querySelector(sel);
              if (!table) return [];
              const rows = Array.from(table.querySelectorAll("tbody tr"));
              const out = [];
              rows.forEach((tr) => {
                const cells = Array.from(tr.querySelectorAll("td"));
                if (!cells.length) return;
                const item = rowMap(cells, tr);
                if (item) out.push(item);
              });
              return out;
            };

            const analyzers = safeGetDocAnalyzers();
            const segGroupsRaw = buildT01CatalogGroups(analyzers, "segment");
            const needGroupsRaw = buildT01CatalogGroups(analyzers, "need");

            const codeNum = (code) => {
              const m = String(code || "").match(/(\d+)/);
              const n = m ? Number(m[1]) : Number.NaN;
              return Number.isFinite(n) ? n : 9999;
            };

            const groupIdFromName = (prefix, name) =>
              `${prefix}_${String(name || "")
                .trim()
                .toLowerCase()
                .replace(/\s+/g, "_")}`;

            const segCatalogByCode = new Map();
            const needCatalogByCode = new Map();

            segGroupsRaw.forEach((g) => {
              const meta = {
                id: String(g && g.id ? g.id : groupIdFromName("grp_segment", g && g.name)),
                name: String(g && g.name ? g.name : "â€”"),
                description: String(g && g.description ? g.description : ""),
              };
              (g && Array.isArray(g.variants) ? g.variants : []).forEach((v) => {
                const code = String(v && v.code ? v.code : "").trim();
                if (!code || !/^S\d{2}$/.test(code)) return;
                const key = String(v && v.key ? v.key : "").trim();
                const name = String((v && v.detail && v.detail.name) || (v && v.label) || key || "").trim();
                const evidence = String((v && v.detail && v.detail.evidence) || "").trim();
                const contextRaw = String((v && v.detail && v.detail.context) || "").trim();
                const desc = String(meta.description || "").trim();
                const ctx =
                  contextRaw && !contextRaw.toLowerCase().includes("Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¾ Ð¸Ð· pdf")
                    ? contextRaw
                    : desc && !desc.toLowerCase().includes("Ð³Ñ€ÑƒÐ¿Ð¿Ð° Ð±ÐµÐ· Ð¾Ð±ÑŠÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ") && !desc.toLowerCase().includes("Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¾ Ð¸Ð· pdf")
                      ? desc
                      : "";
                if (!segCatalogByCode.has(code)) segCatalogByCode.set(code, { code, key, name, context: ctx, evidence, group: meta });
              });
            });

            needGroupsRaw.forEach((g) => {
              const meta = {
                id: String(g && g.id ? g.id : groupIdFromName("grp_need", g && g.name)),
                name: String(g && g.name ? g.name : "â€”"),
                description: String(g && g.description ? g.description : ""),
              };
              (g && Array.isArray(g.variants) ? g.variants : []).forEach((v) => {
                const code = String(v && v.code ? v.code : "").trim();
                if (!code || !/^N\d{2}$/.test(code)) return;
                const key = String(v && v.key ? v.key : "").trim();
                const name = String((v && v.detail && v.detail.name) || (v && v.label) || key || "").trim();
                const meaning = String(meta.description || "").trim();
                if (!needCatalogByCode.has(code)) needCatalogByCode.set(code, { code, key, name, meaning, group: meta });
              });
            });

	            const segListFromAnalyzers = Array.from(segCatalogByCode.values()).sort((a, b) => codeNum(a.code) - codeNum(b.code));
	            const needListFromAnalyzers = Array.from(needCatalogByCode.values()).sort((a, b) => codeNum(a.code) - codeNum(b.code));
	
	            const cleanNarrativeText = (value) => {
	              const raw = String(value || "").trim();
	              if (!raw) return "";
	              const norm = raw.toLowerCase();
	              if (norm.includes("Ð¸Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¾ Ð¸Ð· pdf")) return "";
	              return raw.replace(/\s+/g, " ").trim();
	            };
	
	            const shortVariantList = (variants, max = 3) => {
	              const list = (Array.isArray(variants) ? variants : [])
	                .map((v) => String(v && (v.label || v.key) ? (v.label || v.key) : "").trim())
	                .filter(Boolean);
	              const uniq = Array.from(new Set(list));
	              const shown = uniq.slice(0, Math.max(1, max));
	              if (!shown.length) return "";
	              const tail = uniq.length > shown.length ? "â€¦" : "";
	              return `${shown.join(", ")}${tail}`;
	            };
	
	            const narrativeForGroup = (group) => {
	              const desc = cleanNarrativeText(group && group.description);
	              if (desc && !desc.toLowerCase().includes("Ð³Ñ€ÑƒÐ¿Ð¿Ð° Ð±ÐµÐ· Ð¾Ð±ÑŠÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ")) return desc;
	              const variantCtx = (Array.isArray(group && group.variants) ? group.variants : [])
	                .map((v) => cleanNarrativeText(v && v.detail && v.detail.context))
	                .filter(Boolean)
	                .sort((a, b) => b.length - a.length)[0];
	              if (variantCtx) return variantCtx;
	              const vars = shortVariantList(group && group.variants, 3);
	              if (vars) return `ÐžÐ±ÑŠÐµÐ´Ð¸Ð½ÑÐµÑ‚ Ñ„Ð¾Ñ€Ð¼ÑƒÐ»Ð¸Ñ€Ð¾Ð²ÐºÐ¸: ${vars}`;
	              return "â€”";
	            };
	
	            const renderT02CatalogTables = () => {
	              const segTbody =
	                rootEl.querySelector("[data-sf-t02-segments-tbody]") ||
	                (rootEl.querySelector("[data-sf-t02-segments-table]") && rootEl.querySelector("[data-sf-t02-segments-table]").querySelector("tbody"));
	              const needTbody =
	                rootEl.querySelector("[data-sf-t02-needs-tbody]") ||
	                (rootEl.querySelector("[data-sf-t02-needs-table]") && rootEl.querySelector("[data-sf-t02-needs-table]").querySelector("tbody"));

	              if (segTbody) {
	                while (segTbody.firstChild) segTbody.removeChild(segTbody.firstChild);
	                if (!segGroupsRaw.length) {
	                  const tr = document.createElement("tr");
	                  tr.innerHTML = `<td colspan=\"5\" class=\"help\">ÐÐµÑ‚ Ð³Ñ€ÑƒÐ¿Ð¿ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð² Ð² Ð´ÐµÐ¼Ð¾â€‘ÐºÐ¾Ñ€Ð¿ÑƒÑÐµ.</td>`;
	                  segTbody.appendChild(tr);
	                } else {
	                  segGroupsRaw.forEach((group, idx) => {
	                    const stats = group.stats || { docs: [], docsCount: 0, totalMentions: 0, trust: "B" };
	                    const top = stats.docs && stats.docs.length ? stats.docs[0] : null;
	                    const ctx = narrativeForGroup(group);
	                    const n = idx + 1;

	                    const tr = document.createElement("tr");
	                    tr.className = "sfRowLink";
	                    tr.setAttribute("data-sf-action", "open_catalog_group_detail");
	                    tr.setAttribute("data-sf-payload", `segment|${String(group.id || "")}`);
	                    tr.setAttribute("data-sf-name", String(group.name || ""));
	                    tr.setAttribute("data-sf-context", ctx);
	                    tr.setAttribute("data-sf-docs-count", String(stats.docsCount || 0));
	                    tr.setAttribute("data-sf-mentions-total", String(stats.totalMentions || 0));
	                    tr.setAttribute("data-sf-trust", String(stats.trust || ""));
	                    if (top && top.key) {
	                      tr.setAttribute("data-sf-doc-key", String(top.key));
	                      tr.setAttribute("data-sf-mentions", String(top.mentions || 0));
	                    }

	                    const corpusNote = stats.docsCount ? `docs ${stats.docsCount} â€¢ trust ${stats.trust}` : "â€”";
	                    tr.innerHTML = `
	                      <td><b>${escapeHtml(String(n))}</b></td>
	                      <td><b>${escapeHtml(group.name || "â€”")}</b></td>
	                      <td><b>${escapeHtml(String(stats.totalMentions || 0))}</b><div class=\"help\" style=\"margin-top:4px;\">${escapeHtml(corpusNote)}</div></td>
	                      <td>${escapeHtml(ctx)}</td>
	                      <td><span class=\"sfTag\">variants: ${escapeHtml(String((group.variants || []).length))}</span> <span class=\"sfTag\">trust: ${escapeHtml(
	                        String(stats.trust || "B")
	                      )}</span></td>
	                    `;
	                    segTbody.appendChild(tr);
	                  });
	                }
	              }

	              if (needTbody) {
	                while (needTbody.firstChild) needTbody.removeChild(needTbody.firstChild);
	                if (!needGroupsRaw.length) {
	                  const tr = document.createElement("tr");
	                  tr.innerHTML = `<td colspan=\"4\" class=\"help\">ÐÐµÑ‚ Ð³Ñ€ÑƒÐ¿Ð¿ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð½Ð¾ÑÑ‚ÐµÐ¹ Ð² Ð´ÐµÐ¼Ð¾â€‘ÐºÐ¾Ñ€Ð¿ÑƒÑÐµ.</td>`;
	                  needTbody.appendChild(tr);
	                } else {
	                  needGroupsRaw.forEach((group, idx) => {
	                    const stats = group.stats || { docsCount: 0, totalMentions: 0, trust: "B" };
	                    const meaning = narrativeForGroup(group);
	                    const corpusNote = stats.docsCount ? `docs ${stats.docsCount} â€¢ trust ${stats.trust}` : "â€”";
	                    const n = idx + 1;

	                    const tr = document.createElement("tr");
	                    tr.className = "sfRowLink";
	                    tr.setAttribute("data-sf-action", "open_catalog_group_detail");
	                    tr.setAttribute("data-sf-payload", `need|${String(group.id || "")}`);
	                    tr.innerHTML = `
	                      <td><b>${escapeHtml(String(n))}</b></td>
	                      <td><b>${escapeHtml(group.name || "â€”")}</b></td>
	                      <td><b>${escapeHtml(String(stats.totalMentions || 0))}</b><div class=\"help\" style=\"margin-top:4px;\">${escapeHtml(corpusNote)}</div></td>
	                      <td>${escapeHtml(meaning)}</td>
	                    `;
	                    needTbody.appendChild(tr);
	                  });
	                }
	              }
            };

            try {
              renderT02CatalogTables();
            } catch (_) {}

	            const segments = segListFromAnalyzers.length
	              ? segListFromAnalyzers
	              : extractCatalogTable("[data-sf-t02-segments-table]", (cells) => {
	                  const nRaw = String(cells[0] && cells[0].textContent ? cells[0].textContent : "")
	                    .trim()
	                    .replace(/\s+/g, " ");
	                  const n = Math.max(1, Number(nRaw) || 0);
	                  const code = `S${String(n).padStart(2, "0")}`;
	                  const name = String(cells[1] && cells[1].textContent ? cells[1].textContent : "").trim();
	                  const context = String(cells[3] && cells[3].textContent ? cells[3].textContent : "").trim();
	                  if (!name) return null;
	                  return { code, name, context };
	                });

	            const needs = needListFromAnalyzers.length
	              ? needListFromAnalyzers
	              : extractCatalogTable("[data-sf-t02-needs-table]", (cells) => {
	                  const nRaw = String(cells[0] && cells[0].textContent ? cells[0].textContent : "")
	                    .trim()
	                    .replace(/\s+/g, " ");
	                  const n = Math.max(1, Number(nRaw) || 0);
	                  const code = `N${String(n).padStart(2, "0")}`;
	                  const name = String(cells[1] && cells[1].textContent ? cells[1].textContent : "").trim();
	                  const meaning = String(cells[3] && cells[3].textContent ? cells[3].textContent : "").trim();
	                  if (!name) return null;
	                  return { code, name, meaning };
	                });

            // Fallback to numeric ranges if tables are not present (template safety).
            const rowsCount = Math.max(1, Math.min(200, Number(container.getAttribute("data-sf-rows") || 0) || 21));
            const colsCount = Math.max(1, Math.min(200, Number(container.getAttribute("data-sf-cols") || 0) || 52));

	            const segList =
	              segments.length
	                ? segments
	                : 
	              Array.from({ length: rowsCount }).map((_, i) => ({
	                code: `S${String(i + 1).padStart(2, "0")}`,
	                name: `Segment ${i + 1}`,
	                context: "",
	              }));
	            const needList =
	              needs.length
	                ? needs
	                : 
	              Array.from({ length: colsCount }).map((_, i) => ({
	                code: `N${String(i + 1).padStart(2, "0")}`,
	                name: `Need ${i + 1}`,
	                meaning: "",
	              }));

            const segmentGroupFor = (seg) => {
              if (seg && seg.group && seg.group.id) return seg.group;
              if (seg && seg.groupName) {
                const gName = String(seg.groupName || "").trim();
                if (gName) return { id: groupIdFromName("grp_segment", gName), name: gName, description: "" };
              }
              const norm = normalizeLoose(`${seg.name || ""} ${seg.context || ""}`);
              if (norm.includes("ÑÐºÐ¸Ð´") || norm.includes("Ð²Ñ‹Ð³Ð¾Ð´") || norm.includes("Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½")) return { id: "seg_value", name: "Ð¦ÐµÐ½Ð° / Ð¿Ñ€Ð¾Ð¼Ð¾" };
              if (norm.includes("Ñ‚Ñ€ÐµÐ½Ð´") || norm.includes("Ð¸Ð¼Ð¿ÑƒÐ»ÑŒÑ") || norm.includes("Ð½Ð¾Ð²Ð¸Ð½")) return { id: "seg_trend", name: "Ð¢Ñ€ÐµÐ½Ð´Ñ‹ / Ð²Ð´Ð¾Ñ…Ð½Ð¾Ð²ÐµÐ½Ð¸Ðµ" };
              if (norm.includes("Ð¾Ð½Ð»Ð°Ð¹Ð½") || norm.includes("Ð¾Ñ„Ñ„Ð»Ð°Ð¹Ð½") || norm.includes("click") || norm.includes("collect") || norm.includes("Ð´ÐµÐ´Ð»Ð°Ð¹Ð½"))
                return { id: "seg_channel", name: "ÐšÐ°Ð½Ð°Ð» / ÑƒÐ´Ð¾Ð±ÑÑ‚Ð²Ð¾" };
              if (norm.includes("Ñ€Ð°Ð·Ð¼ÐµÑ€") || norm.includes("ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾") || norm.includes("Ð½ÑƒÐ¶Ð½Ð¾ Ð´Ð¾Ð²ÐµÑ€Ð¸Ðµ") || norm.includes("Ð´Ð¾Ð²ÐµÑ€Ð¸Ðµ") || norm.includes("Ð¿Ð»ÑŽÑ"))
                return { id: "seg_assurance", name: "Ð£Ð²ÐµÑ€ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ (fit/quality/trust)" };
              if (norm.includes("ÑÐµÐ¼ÐµÐ¹Ð½") || norm.includes("Ð¿Ð¾Ð´Ð°Ñ€") || norm.includes("ÑÐµÐ·Ð¾Ð½") || norm.includes("Ð°ÐºÑÐµÑÑ"))
                return { id: "seg_family", name: "Ð¡ÐµÐ¼ÑŒÑ / Ð¿Ð¾Ð´Ð°Ñ€ÐºÐ¸ / ÑÐµÐ·Ð¾Ð½" };
              if (norm.includes("Ð»Ð¾ÑÐ»ÑŒ")) return { id: "seg_loyal", name: "Ð›Ð¾ÑÐ»ÑŒÐ½Ñ‹Ðµ" };
              if (norm.includes("ÑÐºÐ¾") || norm.includes("ÑƒÑÑ‚Ð¾Ð¹Ñ‡Ð¸Ð²")) return { id: "seg_sustain", name: "Sustainability" };
              if (norm.includes("gen z") || norm.includes("millennial") || norm.includes("Ð¿Ð¾ÐºÐ¾Ð»")) return { id: "seg_demo", name: "ÐŸÐ¾ÐºÐ¾Ð»ÐµÐ½Ð¸Ñ" };
              return { id: "seg_other", name: "Ð”Ñ€ÑƒÐ³Ð¾Ðµ" };
            };

            const needGroupFor = (need) => {
              if (need && need.group && need.group.id) return need.group;
              if (need && need.groupName) {
                const gName = String(need.groupName || "").trim();
                if (gName) return { id: groupIdFromName("grp_need", gName), name: gName, description: "" };
              }
              const norm = normalizeLoose(`${need.name || ""} ${need.meaning || ""}`);
              if (norm.includes("Ñ†ÐµÐ½Ð°") || norm.includes("ÑÐºÐ¸Ð´") || norm.includes("ÐºÑÑˆÐ±") || norm.includes("Ð±Ð¾Ð½ÑƒÑ") || norm.includes("Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½"))
                return { id: "need_value", name: "Ð¦ÐµÐ½Ð° / Ð¿Ñ€Ð¾Ð¼Ð¾" };
              if (norm.includes("Ð´Ð¾ÑÑ‚Ð°Ð²") || norm.includes("ÑÑ€Ð¾Ðº") || norm.includes("Ð¿Ð²Ð·") || norm.includes("ÑÐ°Ð¼Ð¾Ð²Ñ‹Ð²Ð¾Ð·") || norm.includes("Ñ‚Ñ€ÐµÐº"))
                return { id: "need_logistics", name: "Ð”Ð¾ÑÑ‚Ð°Ð²ÐºÐ° / Ð»Ð¾Ð³Ð¸ÑÑ‚Ð¸ÐºÐ°" };
              if (norm.includes("Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‚") || norm.includes("Ð¾Ð±Ð¼ÐµÐ½")) return { id: "need_returns", name: "Ð’Ð¾Ð·Ð²Ñ€Ð°Ñ‚Ñ‹ / Ñ€Ð¸ÑÐºÐ¸" };
              if (norm.includes("Ñ€Ð°Ð·Ð¼ÐµÑ€") || norm.includes("Ð¿Ð¾ÑÐ°Ð´Ðº") || norm.includes("fit")) return { id: "need_fit", name: "Ð Ð°Ð·Ð¼ÐµÑ€ / fit" };
              if (norm.includes("ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾") || norm === "qc" || norm.includes("Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð»")) return { id: "need_quality", name: "ÐšÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾" };
              if (norm.includes("Ð½Ð¾Ð²Ð¸Ð½") || norm.includes("Ñ‚Ñ€ÐµÐ½Ð´") || norm.includes("Ð´Ñ€Ð¾Ð¿")) return { id: "need_trends", name: "ÐÐ¾Ð²Ð¸Ð½ÐºÐ¸ / Ñ‚Ñ€ÐµÐ½Ð´Ñ‹" };
              if (norm.includes("Ð¿Ð¾Ð¸ÑÐº") || norm.includes("Ñ„Ð¸Ð»ÑŒÑ‚Ñ€") || norm.includes("Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´Ð°Ñ†")) return { id: "need_discovery", name: "ÐŸÐ¾Ð¸ÑÐº / discovery" };
              if (norm.includes("Ð¾Ñ‚Ð·Ñ‹Ð²") || norm.includes("Ð´Ð¾ÐºÐ°Ð·") || norm.includes("Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶")) return { id: "need_trust", name: "Trust / proof" };
              if (norm.includes("ÑÑ‚Ð¸Ð»ÑŒ") || norm.includes("Ð¾Ð±Ñ€Ð°Ð·") || norm.includes("ÑÐ¾Ð²ÐµÑ‚")) return { id: "need_style", name: "Ð¡Ñ‚Ð¸Ð»ÑŒ / Ð¿Ð¾Ð¼Ð¾Ñ‰ÑŒ" };
              if (norm.includes("Ð¿Ð¾Ð´Ð°Ñ€") || norm.includes("ÑƒÐ¿Ð°ÐºÐ¾Ð²")) return { id: "need_gift", name: "ÐŸÐ¾Ð´Ð°Ñ€ÐºÐ¸" };
              if (norm.includes("Ð»Ð¾ÑÐ»ÑŒ") || norm.includes("ÐºÐ»ÑƒÐ±")) return { id: "need_loyalty", name: "Ð›Ð¾ÑÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ" };
              if (norm.includes("ÑÐºÐ¾") || norm.includes("ÑƒÑÑ‚Ð¾Ð¹Ñ‡Ð¸Ð²")) return { id: "need_sustain", name: "Sustainability" };
              return { id: "need_other", name: "Ð”Ñ€ÑƒÐ³Ð¾Ðµ" };
            };

	            const segItems = segList
	              .map((s) => {
	                const group = segmentGroupFor(s);
	                const key = s && s.key ? String(s.key) : "";
	                const stats = key ? computeCatalogItemStatsAcrossDocs("segment", key, analyzers) : { docsCount: 0, totalMentions: 0, trust: "B" };
	                const ctx = String(s && s.context ? s.context : (group && group.description) || "").trim();
	                const evidence = String((s && s.evidence) || "PDF extract");
	                return { ...s, key, group, stats, context: ctx, evidence };
	              })
	              .filter((s) => s && s.code);
	            const needItems = needList
	              .map((n) => {
	                const group = needGroupFor(n);
	                const key = n && n.key ? String(n.key) : "";
	                const stats = key ? computeCatalogItemStatsAcrossDocs("need", key, analyzers) : { docsCount: 0, totalMentions: 0, trust: "B" };
	                const meaning = String((n && n.meaning) || (group && group.description) || "").trim();
	                return { ...n, key, group, stats, meaning };
	              })
	              .filter((n) => n && n.code);
	
	            // Focus set for Block 1/2: keep the matrix readable by showing top-trust items.
	            const focusSegMax = Math.max(1, Math.min(40, Number(container.getAttribute("data-sf-seg-max") || 0) || 12));
	            const focusNeedMax = Math.max(1, Math.min(60, Number(container.getAttribute("data-sf-need-max") || 0) || 16));
	
	            const trustRank = (t) => {
	              const key = String(t || "").toUpperCase();
	              if (key === "A") return 3;
	              if (key === "B") return 2;
	              if (key === "C") return 1;
	              return 0;
	            };
	
	            const sortByTrustAndMentions = (a, b) => {
	              const at = trustRank(a && a.stats && a.stats.trust);
	              const bt = trustRank(b && b.stats && b.stats.trust);
	              if (bt !== at) return bt - at;
	              const as = Number(a && a.stats && a.stats.trustScore) || 0;
	              const bs = Number(b && b.stats && b.stats.trustScore) || 0;
	              if (bs !== as) return bs - as;
	              const am = Number(a && a.stats && a.stats.totalMentions) || 0;
	              const bm = Number(b && b.stats && b.stats.totalMentions) || 0;
	              if (bm !== am) return bm - am;
	              return codeNum(String(a && a.code)) - codeNum(String(b && b.code));
	            };
	
	            const segFocus = segItems.slice().sort(sortByTrustAndMentions).slice(0, focusSegMax);
	            const needFocus = needItems.slice().sort(sortByTrustAndMentions).slice(0, focusNeedMax);

	            const segKind = (seg) => {
	              const label = normalizeLoose(`${(seg && seg.name) || ""} ${(seg && seg.key) || ""}`);
	              if (label.includes("gen z") || label.includes("genz")) return "gen_z";
	              if (label.includes("millennial") || label.includes("milen")) return "millennial";
	              if (label.includes("gen x") || label.includes("genx")) return "gen_x";
	              if (label.includes("boomer")) return "boomer";
	              return "other";
	            };

	            const needKind = (need) => {
	              const label = normalizeLoose(`${(need && need.name) || ""} ${(need && need.key) || ""}`);
	              if (label.includes("social media") || label.includes("social")) return "social";
	              if (label.includes("wellness")) return "wellness";
	              if (label.includes("health")) return "health";
	              if (label.includes("longevity")) return "longevity";
	              if (label.includes("value") || label.includes("price") || label.includes("deal")) return "value";
	              if (label.includes("performance")) return "performance";
	              if (label.includes("fitness")) return "fitness";
	              if (label.includes("sleep")) return "sleep";
	              if (label.includes("digital")) return "digital";
	              return "other";
	            };

	            try {
	              rootEl.querySelectorAll("[data-sf-t02-seg-count]").forEach((el) => {
	                if (!el) return;
	                el.textContent = String(segItems.length);
	              });
	              rootEl.querySelectorAll("[data-sf-t02-need-count]").forEach((el) => {
	                if (!el) return;
	                el.textContent = String(needItems.length);
	              });
	            } catch (_) {}

            const byGroup = (items) => {
              const m = new Map();
              items.forEach((it) => {
                const g = it.group || { id: "other", name: "Other" };
                const prev = m.get(g.id) || { id: g.id, name: g.name, items: [] };
                prev.items.push(it);
                m.set(g.id, prev);
              });
              return Array.from(m.values());
            };

	            const segGroups = byGroup(segFocus);
	            const needGroups = byGroup(needFocus);

            const docsIndex = Object.entries(analyzers || {}).map(([docKey, doc]) => {
              const items = Array.isArray(doc && doc.items) ? doc.items : [];
              const segCounts = new Map();
              const needCounts = new Map();
              items.forEach((it) => {
                if (!it) return;
                const type = String(it.type || "");
                const key = normalizeKey(it.key);
                if (!key) return;
                const count = Math.max(0, Number(it.totals && it.totals.count) || 0);
                if (!count) return;
                if (type === "segment") segCounts.set(key, count);
                if (type === "need") needCounts.set(key, count);
              });
              const trustDoc = DOC_TRUST_MAP_DEMO[docKey] || "B";
              const trustScore = trustToScore(trustDoc);
              return { key: docKey, segCounts, needCounts, trustScore };
            });

            const rawCooc = (segKey, needKey) => {
              const sk = normalizeKey(segKey);
              const nk = normalizeKey(needKey);
              if (!sk || !nk) return 0;
              let sum = 0;
              docsIndex.forEach((d) => {
                const a = d.segCounts.get(sk) || 0;
                const b = d.needCounts.get(nk) || 0;
                if (!a || !b) return;
                const w = 0.75 + 0.25 * (Number(d.trustScore) || 0.64);
                sum += Math.sqrt(a * b) * w;
              });
              return sum;
            };

	            let maxRaw = 0;
	            segFocus.forEach((seg) => {
	              needFocus.forEach((need) => {
	                const v = rawCooc(seg.key, need.key);
	                if (v > maxRaw) maxRaw = v;
	              });
	            });

            const importanceScore = (seg, need) => {
              const raw = rawCooc(seg && seg.key ? seg.key : "", need && need.key ? need.key : "");
              if (!maxRaw) return 0;
              const jitter = ((hash32(`${seg.code}|${need.code}`) % 5) - 2) * 0.6;
              return clamp(Math.round((raw / maxRaw) * 100 + jitter), 0, 100);
            };

            const importanceClass = (score) => {
              const s = Number(score) || 0;
              if (s >= 80) return "Core";
              if (s >= 60) return "Secondary";
              if (s >= 40) return "Niche";
              return "Irrelevant";
            };

            const topNeedNamesBySegKey = (() => {
              const m = new Map();
              try {
                segFocus.forEach((seg) => {
                  const ranked = needFocus
                    .map((need) => ({ need, score: Number(importanceScore(seg, need)) || 0 }))
                    .slice()
                    .sort((a, b) => (b.score || 0) - (a.score || 0))
                    .slice(0, 3)
                    .map((x) => String(x.need && x.need.name ? x.need.name : "").trim())
                    .filter(Boolean);
                  m.set(String(seg && (seg.key || seg.code) ? (seg.key || seg.code) : ""), ranked);
                });
              } catch (_) {}
              return m;
            })();

            const cellComment = (seg, need, score, cls) => {
              const s = Number(score) || 0;
              const klass = String(cls || "");
              const sk = segKind(seg);
              const nk = needKind(need);
              const needName = String(need && need.name ? need.name : "").trim();
              const segKey = String(seg && (seg.key || seg.code) ? (seg.key || seg.code) : "");

              const tops = topNeedNamesBySegKey.get(segKey) || [];
              const alt = tops.filter((x) => normalizeLoose(x) !== normalizeLoose(needName)).slice(0, 2);
              const altText = alt.length ? `Ð’Ð°Ð¶Ð½ÐµÐµ: ${alt.join(", ")}.` : "";

              const prefix =
                klass === "Core"
                  ? "Core Ð´Ñ€Ð°Ð¹Ð²ÐµÑ€"
                  : klass === "Secondary"
                    ? "Ð’Ð°Ð¶Ð½Ð¾"
                    : klass === "Niche"
                      ? "Ð’Ñ‚Ð¾Ñ€Ð¸Ñ‡Ð½Ð¾"
                      : "ÐÐµ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚";

              let text = "";
              if (nk === "social") {
                if (sk === "gen_z") text = `${prefix}: discovery Ñ‡ÐµÑ€ÐµÐ· creators/UGC Ð¸ selfâ€‘expression.`;
                else if (sk === "millennial") text = `${prefix}: social = research + proof Ñ‡ÐµÑ€ÐµÐ· ÐºÐ¾Ð¼ÑŒÑŽÐ½Ð¸Ñ‚Ð¸/ÑÐºÑÐ¿ÐµÑ€Ñ‚Ð¾Ð².`;
                else if (sk === "gen_x" || sk === "boomer") text = `${prefix}: ÑÐ¾Ñ†ÑÐµÑ‚Ð¸ Ñ‡Ð°Ñ‰Ðµ Ð´Ð»Ñ Ð¸ÑÑÐ»ÐµÐ´Ð¾Ð²Ð°Ð½Ð¸Ñ; Ñ€ÐµÑˆÐµÐ½Ð¸Ðµ Ñ‡ÐµÑ€ÐµÐ· ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾/Ð´Ð¾Ð²ÐµÑ€Ð¸Ðµ.`;
                else text = `${prefix}: Ð²Ð»Ð¸ÑÐµÑ‚ Ð½Ð° discovery Ð¸ social proof.`;
              } else if (nk === "wellness" || nk === "health" || nk === "longevity") {
                if (sk === "gen_z") text = `${prefix}: wellness ÐºÐ°Ðº identity Ð¸ â€œfeelâ€‘goodâ€ Ð¿Ñ€Ð¸Ð²Ñ‹Ñ‡ÐºÐ°.`;
                else if (sk === "millennial") text = `${prefix}: wellness/longâ€‘term health â€” ÑÐ´Ñ€Ð¾ Ð¼Ð¾Ñ‚Ð¸Ð²Ð°Ñ†Ð¸Ð¸.`;
                else if (sk === "gen_x" || sk === "boomer") text = `${prefix}: Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ Ñ‡ÐµÑ€ÐµÐ· ÐºÐ¾Ð¼Ñ„Ð¾Ñ€Ñ‚/ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾, Ð±ÐµÐ· Ñ…Ð°Ð¹Ð¿Ð°.`;
                else text = `${prefix}: selfâ€‘improvement Ð¸ Ð·Ð°Ð±Ð¾Ñ‚Ð° Ð¾ Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÐµ.`;
              } else if (nk === "value") {
                if (sk === "gen_z") text = `${prefix}: Ñ‡ÑƒÐ²ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ Ðº Ñ†ÐµÐ½Ðµ/Ð°ÐºÑ†Ð¸ÑÐ¼, ÑÑ€Ð°Ð²Ð½ÐµÐ½Ð¸Ðµ Ð¾Ð½Ð»Ð°Ð¹Ð½.`;
                else if (sk === "millennial") text = `${prefix}: Ð±Ð°Ð»Ð°Ð½Ñ Ñ†ÐµÐ½Ð°/ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾, value = Ñ€Ð°Ñ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð¾ÑÑ‚ÑŒ.`;
                else if (sk === "gen_x" || sk === "boomer") text = `${prefix}: value = Ð´Ð¾Ð»Ð³Ð¾Ð²ÐµÑ‡Ð½Ð¾ÑÑ‚ÑŒ Ð¸ ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾.`;
                else text = `${prefix}: price/value ÐºÐ°Ðº Ñ„Ð¸Ð»ÑŒÑ‚Ñ€ Ð²Ñ‹Ð±Ð¾Ñ€Ð°.`;
              } else if (nk === "performance" || nk === "fitness") {
                if (sk === "gen_z") text = `${prefix}: performance + Ð²Ð½ÐµÑˆÐ½Ð¸Ð¹ Ð²Ð¸Ð´; Ð²Ð°Ð¶Ð½Ð¾ â€œÐºÐ°Ðº Ð¾Ñ‰ÑƒÑ‰Ð°ÐµÑ‚ÑÑâ€.`;
                else if (sk === "millennial") text = `${prefix}: ÑÑ„Ñ„ÐµÐºÑ‚Ð¸Ð²Ð½Ð¾ÑÑ‚ÑŒ/Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚, Ñ€ÐµÐ³ÑƒÐ»ÑÑ€Ð½Ð¾ÑÑ‚ÑŒ.`;
                else if (sk === "gen_x" || sk === "boomer") text = `${prefix}: Ð²Ð°Ð¶Ð½ÐµÐµ ÐºÐ¾Ð¼Ñ„Ð¾Ñ€Ñ‚/ÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð´Ð»Ñ lowâ€‘intensity.`;
                else text = `${prefix}: Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¾Ð½Ð°Ð»ÑŒÐ½Ð°Ñ Ñ†ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ.`;
              } else if (nk === "sleep" || nk === "digital") {
                if (sk === "gen_z" || sk === "millennial") text = `${prefix}: Ñ†Ð¸Ñ„Ñ€Ð¾Ð²Ñ‹Ðµ Ð¿Ñ€Ð¸Ð²Ñ‹Ñ‡ÐºÐ¸ Ð¸ Ð¾Ð¿Ñ‚Ð¸Ð¼Ð¸Ð·Ð°Ñ†Ð¸Ñ Ñ€ÑƒÑ‚Ð¸Ð½Ñ‹.`;
                else text = `${prefix}: ÑÐºÐ¾Ñ€ÐµÐµ â€œnice to haveâ€.`;
              } else {
                text = `${prefix}: Ð¿Ñ€Ð¾ÑÐ²Ð»ÑÐµÑ‚ÑÑ Ð¿Ð¾â€‘Ñ€Ð°Ð·Ð½Ð¾Ð¼Ñƒ; ÑƒÑ‚Ð¾Ñ‡Ð½ÑÐµÐ¼ Ð¿Ð¾ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ñƒ.`;
              }

              if (s < 60 && altText) text += ` ${altText}`;
              return String(text || "").trim();
            };

	            // Store computed model for other T02 widgets (need homogeneity, detail modals).
	            try {
	              rootEl.__sfT02Model = {
	                segments: segFocus,
	                needs: needFocus,
	                segmentGroups: segGroups,
	                needGroups: needGroups,
	                segmentsAll: segItems,
	                needsAll: needItems,
	                importanceScore,
	                importanceClass,
	              };
	            } catch (_) {}

	            // Columns: segment groups first, then segments.
	            const cols = []
	              .concat(segGroups.map((g, i) => ({ kind: "group", id: g.id, code: `SG${i + 1}`, name: g.name, items: g.items })))
	              .concat(segFocus.map((s) => ({ kind: "item", id: s.code, code: s.code, name: s.name, item: s })));

	            // Rows: need groups (as group rows), then individual needs.
	            const rows = []
	              .concat(needGroups.map((g, i) => ({ kind: "group", id: g.id, code: `NG${i + 1}`, name: g.name, items: g.items })))
	              .concat(needFocus.map((n) => ({ kind: "item", id: n.code, code: n.code, name: n.name, meaning: n.meaning, item: n })));

	            const table = document.createElement("table");
	            table.className = "heatTable heatTableDemandMap";
	
	            const firstColW = 260;
	            const groupColW = 200;
	            const itemColW = 170;
	            const totalW = firstColW + cols.reduce((acc, c) => acc + (c.kind === "group" ? groupColW : itemColW), 0);
	            table.style.minWidth = String(Math.max(980, totalW)) + "px";
	
	            const colgroup = document.createElement("colgroup");
	            const firstCol = document.createElement("col");
	            firstCol.style.width = `${firstColW}px`;
	            colgroup.appendChild(firstCol);
	            cols.forEach((c) => {
	              const col = document.createElement("col");
	              col.style.width = `${c.kind === "group" ? groupColW : itemColW}px`;
	              colgroup.appendChild(col);
	            });
	            table.appendChild(colgroup);

            const thead = document.createElement("thead");
            const headRow = document.createElement("tr");
            const corner = document.createElement("th");
            corner.className = "heatRowHeader";
            corner.textContent = "Need\\Seg";
            headRow.appendChild(corner);
            for (let c = 0; c < cols.length; c += 1) {
              const col = cols[c];
              const th = document.createElement("th");
              if (col.kind === "group") th.classList.add("heatGroupHdr");
              const code = escapeHtml(String(col.code || ""));
              const name = escapeHtml(String(col.name || ""));
              th.innerHTML = `
                <div class="heatTop"><span class="heatValue">${code}</span> <span class="heatTag">${escapeHtml(col.kind === "group" ? "group" : "seg")}</span></div>
                <div class="heatNote">${name}</div>
              `;
              headRow.appendChild(th);
            }
            thead.appendChild(headRow);
            table.appendChild(thead);

            const tbody = document.createElement("tbody");
            for (let r = 0; r < rows.length; r += 1) {
              const row = rows[r];
              const tr = document.createElement("tr");
              if (row.kind === "group") tr.classList.add("heatGroupRow");
              const rowHeader = document.createElement("th");
              rowHeader.className = "heatRowHeader";
              const rhCode = escapeHtml(String(row.code || ""));
              const rhName = escapeHtml(String(row.name || ""));
              const isNeedItem = row.kind === "item" && row.item;
              const needPayload = isNeedItem ? String(row.item.code || "") : "";
              const buttonAttr = isNeedItem
                ? `data-sf-action="open_need_detail" data-sf-payload="${escapeHtml(needPayload)}"`
                : "";
              rowHeader.innerHTML = `
                <button type="button" class="heatHdrBtn" ${buttonAttr}>
                  <div class="heatTop"><span class="heatValue">${rhCode}</span> <span class="heatTag">${escapeHtml(
                    row.kind === "group" ? "group" : "need"
                  )}</span></div>
                  <div class="heatNote">${rhName}</div>
                </button>
              `;
              tr.appendChild(rowHeader);

              for (let c = 0; c < cols.length; c += 1) {
                const col = cols[c];
                let score = 0;
                if (row.kind === "item" && col.kind === "item") {
                  score = importanceScore(col.item, row.item);
                } else if (row.kind === "group" && col.kind === "item") {
                  const list = Array.isArray(row.items) ? row.items : [];
                  const sum = list.reduce((acc, n) => acc + importanceScore(col.item, n), 0);
                  score = list.length ? sum / list.length : 0;
                } else if (row.kind === "item" && col.kind === "group") {
                  const list = Array.isArray(col.items) ? col.items : [];
                  const sum = list.reduce((acc, s) => acc + importanceScore(s, row.item), 0);
                  score = list.length ? sum / list.length : 0;
                } else {
                  const ns = Array.isArray(row.items) ? row.items : [];
                  const ss = Array.isArray(col.items) ? col.items : [];
                  let sum = 0;
                  let count = 0;
                  ns.forEach((n) => {
                    ss.forEach((s) => {
                      sum += importanceScore(s, n);
                      count += 1;
                    });
                  });
                  score = count ? sum / count : 0;
                }

		                const s = clamp(Math.round(score), 0, 100);
		                const cls = importanceClass(s);
		                const clsKey = String(cls || "").trim().toLowerCase();
		                const td = document.createElement("td");
		                td.className = "heatCell " + heatClass(s);
		                if (row.kind === "group" || col.kind === "group") td.classList.add("heatGroupHdr");
		
		                const comment =
		                  row.kind === "item" && col.kind === "item" && row.item && col.item ? cellComment(col.item, row.item, s, cls) : "";
		                const commentHtml = comment
		                  ? `<div class="heatComment heatComment--${escapeHtml(clsKey)}">${escapeHtml(comment)}</div>`
		                  : "";
		                try {
		                  const rowLabel = `${row.kind === "group" ? "Need group" : "Need"}: ${String(row.name || row.code || "").trim()}`;
		                  const colLabel = `${col.kind === "group" ? "Segment group" : "Segment"}: ${String(col.name || col.code || "").trim()}`;
		                  let tip = `${rowLabel}\n${colLabel}\nimportance: ${s} (${cls})`;
	                  if (row.kind === "item" && col.kind === "item" && row.item && col.item) {
	                    const sk = normalizeKey(col.item.key);
	                    const nk = normalizeKey(row.item.key);
	                    const topDocs = docsIndex
	                      .map((d) => {
	                        const a = d.segCounts.get(sk) || 0;
	                        const b = d.needCounts.get(nk) || 0;
	                        if (!a || !b) return null;
	                        const w = 0.75 + 0.25 * (Number(d.trustScore) || 0.64);
	                        const score = Math.sqrt(a * b) * w;
	                        const doc = analyzers && analyzers[d.key];
	                        return { key: d.key, title: String((doc && doc.title) || d.key || ""), a, b, trust: scoreToTrust(d.trustScore), score };
	                      })
	                      .filter(Boolean)
	                      .sort((a, b) => (b.score || 0) - (a.score || 0))
	                      .slice(0, 2);
	                    if (topDocs.length) {
	                      const lines = topDocs.map((d) => `${d.title} â€¢ ${d.a}Ã—${d.b} â€¢ trust ${d.trust}`);
	                      tip += `\n\ndocs:\n- ${lines.join("\n- ")}`;
	                    }
	                  }
	                  td.setAttribute("title", tip);
		                } catch (_) {}
		                td.innerHTML = `
		                  <div class="heatCellInner">
		                    <div class="heatTop"><span class="heatValue">${escapeHtml(String(s))}</span> <span class="heatTag heatTag--${escapeHtml(
		                      clsKey
		                    )}">${escapeHtml(cls)}</span></div>
		                    <div class="heatBar"><span class="heatBarFill heatBarFill--${escapeHtml(clsKey)}" style="width:${escapeHtml(
		                      String(s)
		                    )}%"></span></div>
		                    ${commentHtml}
		                  </div>
		                `;
		                tr.appendChild(td);
		              }
              tbody.appendChild(tr);
            }
            table.appendChild(tbody);

            container.innerHTML = "";
            container.appendChild(table);
          };

          try {
            rootEl.querySelectorAll("[data-sf-matrix]").forEach((el) => {
              if (!el || typeof el.getAttribute !== "function") return;
              if (el.getAttribute("data-sf-rendered") === "1") return;
              const kind = el.getAttribute("data-sf-matrix") || "";
              if (kind !== "segment_need_v1") return;
              try {
                renderSegmentNeedMatrix(el);
              } catch (err) {
                const msg = err && err.message ? String(err.message) : String(err || "unknown error");
                el.innerHTML = `<div class="help">ÐžÑˆÐ¸Ð±ÐºÐ° Ñ€ÐµÐ½Ð´ÐµÑ€Ð° Ð¼Ð°Ñ‚Ñ€Ð¸Ñ†Ñ‹ SegmentÃ—Need: ${escapeHtml(msg)}</div>`;
                try {
                  console.error("SegmentÃ—Need matrix render error", err);
                } catch (_) {}
              }
              el.setAttribute("data-sf-rendered", "1");
            });
          } catch (_) {}

          try {
            const model = rootEl.__sfT02Model;
            const homogHosts = Array.from(rootEl.querySelectorAll("[data-sf-t02-need-homogeneity]"));
            const summaryHosts = Array.from(rootEl.querySelectorAll("[data-sf-t02-need-summary]"));
            if (homogHosts.length || summaryHosts.length) {
              const segs = model && Array.isArray(model.segments) ? model.segments : [];
              const needs = model && Array.isArray(model.needs) ? model.needs : [];
              const scoreFn = model && typeof model.importanceScore === "function" ? model.importanceScore : () => 0;
              const classFn = model && typeof model.importanceClass === "function" ? model.importanceClass : () => "Irrelevant";

              const calcStd = (arr) => {
                const xs = Array.isArray(arr) ? arr.map((v) => Number(v) || 0) : [];
                if (!xs.length) return 0;
                const mean = xs.reduce((a, b) => a + b, 0) / xs.length;
                const varSum = xs.reduce((acc, v) => acc + (v - mean) * (v - mean), 0);
                return Math.sqrt(varSum / xs.length);
              };

              const marketPosition = (stat) => {
                const cov = stat.coverage;
                const avg = stat.avg;
                const max = stat.max;
                if (cov >= 0.75 && avg >= 70) return { id: "common_core", label: "ÐžÐ±Ñ‰Ð°Ñ (core)", hint: "Ð²Ð°Ð¶Ð½Ð° Ð±Ð¾Ð»ÑŒÑˆÐ¸Ð½ÑÑ‚Ð²Ñƒ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð²" };
                if (cov >= 0.75) return { id: "common", label: "ÐžÐ±Ñ‰Ð°Ñ", hint: "Ð²ÑÑ‚Ñ€ÐµÑ‡Ð°ÐµÑ‚ÑÑ Ñƒ Ð¼Ð½Ð¾Ð³Ð¸Ñ… ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð²" };
                if (cov <= 0.3 && max >= 80) return { id: "diff", label: "Ð¡Ð¿ÐµÑ†Ð¸Ñ„Ð¸Ñ‡Ð½Ð°Ñ", hint: "core Ñƒ 1â€“2 ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð²" };
                if (cov <= 0.3) return { id: "niche", label: "ÐÐ¸ÑˆÐµÐ²Ð°Ñ", hint: "ÑÐ»Ð°Ð±ÐµÐµ Ð¸ Ñ€ÐµÐ´ÐºÐ¾ Ð²Ð°Ð¶Ð½Ð°" };
                return { id: "mixed", label: "Ð¡ÐµÐ³Ð¼ÐµÐ½Ñ‚Ð½Ð°Ñ", hint: "Ð²Ð°Ð¶Ð½Ð° Ñ‡Ð°ÑÑ‚Ð¸ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð²" };
              };

              const needStats = needs.map((need) => {
                const scores = segs.map((seg) => scoreFn(seg, need));
                const sum = scores.reduce((a, b) => a + (Number(b) || 0), 0);
                const avg = scores.length ? sum / scores.length : 0;
                const max = scores.length ? Math.max(...scores) : 0;
                const min = scores.length ? Math.min(...scores) : 0;
                const core = scores.filter((s) => Number(s) >= 80).length;
                const secondaryPlus = scores.filter((s) => Number(s) >= 60).length;
                const nichePlus = scores.filter((s) => Number(s) >= 40).length;
                const irrelevant = Math.max(0, scores.length - nichePlus);
                const cov = scores.length ? secondaryPlus / scores.length : 0;
                const std = calcStd(scores);
                const pos = marketPosition({ coverage: cov, avg, max });
                const topSegs = segs
                  .map((seg, i) => ({ seg, score: scores[i] }))
                  .slice()
                  .sort((a, b) => (b.score || 0) - (a.score || 0))
                  .slice(0, 3)
                  .map((x) => String(x.seg && x.seg.code ? x.seg.code : "").trim())
                  .filter(Boolean);
                return {
                  need,
                  scores,
                  sum,
                  avg,
                  max,
                  min,
                  std,
                  coreCount: core,
                  secondaryPlusCount: secondaryPlus,
                  irrelevantCount: irrelevant,
                  coverage: cov,
                  position: pos,
                  topSegCodes: topSegs,
                };
              });

              const segCount = segs.length || 1;

              homogHosts.forEach((host) => {
                if (!host || typeof host.getAttribute !== "function") return;
                if (host.getAttribute("data-sf-rendered") === "1") return;
                try {
                  if (!needs.length || !segs.length) {
                    host.innerHTML = `<div class="help">ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð´Ð»Ñ Ñ€Ð°ÑÑ‡Ñ‘Ñ‚Ð° Ð¾Ð´Ð½Ð¾Ñ€Ð¾Ð´Ð½Ð¾ÑÑ‚Ð¸ (Ð½ÑƒÐ¶Ð½Ñ‹ ÐºÐ°Ñ‚Ð°Ð»Ð¾Ð³Ð¸ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð²/Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð½Ð¾ÑÑ‚ÐµÐ¹).</div>`;
                    host.setAttribute("data-sf-rendered", "1");
                    return;
                  }

                  const rows = needStats
                    .slice()
                    .sort((a, b) => (b.coverage || 0) - (a.coverage || 0) || (b.avg || 0) - (a.avg || 0))
                    .map((st) => {
                      const need = st.need || {};
                      const code = escapeHtml(String(need.code || ""));
                      const name = escapeHtml(String(need.name || ""));
                      const pos = st.position || { label: "â€”", hint: "" };
                      const covPct = Math.round(100 * (st.coverage || 0));
                      const covText = `${escapeHtml(String(st.secondaryPlusCount || 0))}/${escapeHtml(String(segCount))} (${covPct}%)`;
                      const top = st.topSegCodes.length ? st.topSegCodes.map((c) => `<span class="sfTag">${escapeHtml(c)}</span>`).join("") : "â€”";
                      return `
                        <tr class="sfRowLink" data-sf-action="open_need_detail" data-sf-payload="${code}">
                          <td><b>${code}</b> ${name}</td>
                          <td><span class="sfTag">${escapeHtml(pos.label)}</span></td>
                          <td>${covText}</td>
                          <td><b>${escapeHtml(String(Math.round(st.avg || 0)))}</b></td>
                          <td><span class="sfTag">Core: ${escapeHtml(String(st.coreCount || 0))}</span> <span class="sfTag">Irrel: ${escapeHtml(
                        String(st.irrelevantCount || 0)
                      )}</span></td>
                          <td>${top}</td>
                        </tr>
                      `;
                    })
                    .join("");

                  host.innerHTML = `
                    <div class="sfScrollY">
                      <table class="sfTable">
                        <thead>
                          <tr>
                            <th>ÐŸÐ¾Ñ‚Ñ€ÐµÐ±Ð½Ð¾ÑÑ‚ÑŒ</th>
                            <th>ÐŸÐ¾Ð·Ð¸Ñ†Ð¸Ñ</th>
                            <th>Coverage (â‰¥60)</th>
                            <th>Avg</th>
                            <th>Mix</th>
                            <th>Top segments</th>
                          </tr>
                        </thead>
                        <tbody>${rows}</tbody>
                      </table>
                    </div>
                    <div class="chartNote" style="margin-top:10px;">Coverage = Ð´Ð¾Ð»Ñ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð², Ð³Ð´Ðµ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð½Ð¾ÑÑ‚ÑŒ â‰¥ Secondary (score â‰¥ 60). ÐšÐ»Ð¸Ðº Ð¿Ð¾ ÑÑ‚Ñ€Ð¾ÐºÐµ â†’ Ð´ÐµÑ‚Ð°Ð»Ð¸: Ð²Ð°Ð¶Ð½Ð¾ÑÑ‚ÑŒ Ð¿Ð¾ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð°Ð¼ + Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ñ Ð² Ñ€Ñ‹Ð½ÐºÐµ.</div>
                  `;
                  host.setAttribute("data-sf-rendered", "1");
                } catch (err) {
                  const msg = err && err.message ? String(err.message) : String(err || "unknown error");
                  host.innerHTML = `<div class="help">ÐžÑˆÐ¸Ð±ÐºÐ° Ñ€ÐµÐ½Ð´ÐµÑ€Ð° Ð±Ð»Ð¾ÐºÐ° Ð¾Ð´Ð½Ð¾Ñ€Ð¾Ð´Ð½Ð¾ÑÑ‚Ð¸: ${escapeHtml(msg)}</div>`;
                  host.setAttribute("data-sf-rendered", "1");
                  try {
                    console.error("T02 need homogeneity render error", err);
                  } catch (_) {}
                }
              });

              summaryHosts.forEach((host) => {
                if (!host || typeof host.getAttribute !== "function") return;
                if (host.getAttribute("data-sf-rendered") === "1") return;
                try {
                  if (!needs.length || !segs.length) {
                    host.innerHTML = `<div class="help">ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð´Ð»Ñ summary.</div>`;
                    host.setAttribute("data-sf-rendered", "1");
                    return;
                  }

                  const common = needStats
                    .slice()
                    .sort((a, b) => (b.coverage || 0) - (a.coverage || 0) || (b.avg || 0) - (a.avg || 0))
                    .slice(0, 6);
                  const diff = needStats
                    .filter((st) => (st.coverage || 0) <= 0.3 && (st.max || 0) >= 80)
                    .slice()
                    .sort((a, b) => (b.max || 0) - (a.max || 0) || (b.std || 0) - (a.std || 0))
                    .slice(0, 6);

                  const asBtn = (st) => {
                    const need = st.need || {};
                    const code = escapeHtml(String(need.code || ""));
                    const name = escapeHtml(String(need.name || ""));
                    const covPct = Math.round(100 * (st.coverage || 0));
                    return `<button type="button" class="sfLegendRow" data-sf-action="open_need_detail" data-sf-payload="${code}">
                      <span class="sfLegendSwatch" style="background:rgba(255,255,255,0.08);"></span>
                      <div class="sfLegendText">
                        <div class="sfLegendMain"><b>${code}</b> ${name}</div>
                        <div class="sfLegendDesc">coverage: ${escapeHtml(String(st.secondaryPlusCount || 0))}/${escapeHtml(String(segCount))} (${covPct}%) â€¢ avg: ${escapeHtml(
                        String(Math.round(st.avg || 0))
                      )}</div>
                      </div>
                    </button>`;
                  };

                  host.innerHTML = `
                    <div class="sfSummary">
                      <div class="sfTagRow" style="margin-bottom:10px;">
                        <span class="sfTag">segments: ${escapeHtml(String(segs.length))}</span>
                        <span class="sfTag">needs: ${escapeHtml(String(needs.length))}</span>
                        <span class="sfTag">need groups: ${escapeHtml(String((model && model.needGroups && model.needGroups.length) || 0))}</span>
                      </div>

                      <div style="font-weight:950;margin-top:4px;">Ð¢Ð¾Ð¿ â€œÐ¾Ð±Ñ‰Ð¸Ðµâ€ (coverageâ†‘)</div>
                      <div class="sfLegend" style="margin-top:6px;">${common.map(asBtn).join("")}</div>

                      <div style="font-weight:950;margin-top:14px;">Ð¢Ð¾Ð¿ â€œÑÐ¿ÐµÑ†Ð¸Ñ„Ð¸Ñ‡Ð½Ñ‹Ðµâ€ (coverageâ†“, maxâ†‘)</div>
                      <div class="sfLegend" style="margin-top:6px;">${diff.length ? diff.map(asBtn).join("") : `<div class="help">Ð’ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼ Ð´ÐµÐ¼Ð¾ Ð½ÐµÑ‚ ÑÑ€ÐºÐ¾ â€œÑƒÐ½Ð¸ÐºÐ°Ð»ÑŒÐ½Ñ‹Ñ…â€ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð½Ð¾ÑÑ‚ÐµÐ¹ Ð¿Ð¾ ÐºÑ€Ð¸Ñ‚ÐµÑ€Ð¸ÑÐ¼.</div>`}</div>

                      <div class="chartNote" style="margin-top:12px;">ÐšÐ°Ðº Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ: â€œÐ¾Ð±Ñ‰Ð¸Ðµâ€ â†’ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ð¹ proofâ€‘ÑÐ»Ð¾Ð¹ Ð¸ friction fixes; â€œÑÐ¿ÐµÑ†Ð¸Ñ„Ð¸Ñ‡Ð½Ñ‹Ðµâ€ â†’ Ð³Ð¸Ð¿Ð¾Ñ‚ÐµÐ·Ñ‹ Ð´Ð»Ñ Ñ‚Ð°Ñ€Ð³ÐµÑ‚â€‘ÐºÐ°Ð¼Ð¿Ð°Ð½Ð¸Ð¹ Ð¸ Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¹.</div>
                    </div>
                  `;
                  host.setAttribute("data-sf-rendered", "1");
                } catch (err) {
                  const msg = err && err.message ? String(err.message) : String(err || "unknown error");
                  host.innerHTML = `<div class="help">ÐžÑˆÐ¸Ð±ÐºÐ° Ñ€ÐµÐ½Ð´ÐµÑ€Ð° summary: ${escapeHtml(msg)}</div>`;
                  host.setAttribute("data-sf-rendered", "1");
                  try {
                    console.error("T02 need summary render error", err);
                  } catch (_) {}
                }
              });
            }
          } catch (_) {}

          try {
            rootEl.querySelectorAll(".matrix2x2 .matrixPoint").forEach((el) => {
              if (!el || !el.style) return;
              try {
                if (!el.getAttribute("data-tooltip")) el.setAttribute("data-tooltip", el.getAttribute("data-label") || "");
              } catch (_) {}
              const left = Number.parseFloat(String(el.style.left || "").replace("%", ""));
              const top = Number.parseFloat(String(el.style.top || "").replace("%", ""));
              if (!Number.isFinite(left) || !Number.isFinite(top)) return;

              el.classList.remove("sfQuadBest", "sfQuadNoisy", "sfQuadNiche", "sfQuadLow");
              const highFreq = left >= 50;
              const highEvidence = top <= 50;
              if (highFreq && highEvidence) el.classList.add("sfQuadBest");
              else if (highFreq && !highEvidence) el.classList.add("sfQuadNoisy");
              else if (!highFreq && highEvidence) el.classList.add("sfQuadNiche");
              else el.classList.add("sfQuadLow");
            });
          } catch (_) {}

          try {
            const analyzers = safeGetDocAnalyzers();
            rootEl.querySelectorAll("[data-sf-doc-analyzer]").forEach((el) => {
              if (!el || typeof el.getAttribute !== "function") return;
              if (el.getAttribute("data-sf-rendered") === "1") return;
              const key = String(el.getAttribute("data-sf-doc-analyzer") || "");
              if (!key) return;
              const analyzer = analyzers && analyzers[key];
              if (!analyzer) return;
              const cleanup = mountDocAnalyzer(el, analyzer, { activeType: "segment" });
              el.__sfDocAnalyzerCleanup = cleanup;
              el.setAttribute("data-sf-rendered", "1");
              syncT01FromDocAnalyzer(rootEl, key);
            });
          } catch (_) {}

          try {
            syncT01SegmentGroups(rootEl);
          } catch (_) {}

          try {
            syncT01SegmentGroupVisuals(rootEl);
          } catch (_) {}

          const escapeSelector = (value) => {
            const raw = String(value || "");
            try {
              if (window.CSS && typeof window.CSS.escape === "function") return window.CSS.escape(raw);
            } catch (_) {}
            return raw.replaceAll('"', '\\"');
          };

          const clearActive = () => {
            try {
              rootEl.querySelectorAll(".sfActive").forEach((el) => el.classList.remove("sfActive"));
            } catch (_) {}
          };

          const setActiveSourceSegment = (payload) => {
            clearActive();
            const key = String(payload || "");
            if (!key) return;
            const q = `[data-sf-payload="${escapeSelector(key)}"]`;
            try {
              rootEl.querySelectorAll(`.sfLegendRow${q}, .sfPieSeg${q}`).forEach((el) => el.classList.add("sfActive"));
            } catch (_) {}
          };

          const onPointerOver = (e) => {
            try {
              const target = e.target;
              if (!target || typeof target.closest !== "function") return;
              const el = target.closest('[data-sf-action="open_source_segment"]');
              if (!el || !rootEl.contains(el)) return;
              const payload = el.getAttribute("data-sf-payload") || "";
              setActiveSourceSegment(payload);
            } catch (_) {}
          };

          const onPointerOut = (e) => {
            try {
              const target = e.target;
              if (!target || typeof target.closest !== "function") return;
              const el = target.closest('[data-sf-action="open_source_segment"]');
              if (!el || !rootEl.contains(el)) return;
              const related = e.relatedTarget;
              if (related && el.contains(related)) return;
              clearActive();
            } catch (_) {}
          };

          const onPointerLeave = () => clearActive();

          rootEl.addEventListener("pointerover", onPointerOver);
          rootEl.addEventListener("pointerout", onPointerOut);
          rootEl.addEventListener("pointerleave", onPointerLeave);
          return () => {
            try {
              rootEl.querySelectorAll("[data-sf-doc-analyzer]").forEach((el) => {
                const cleanup = el && el.__sfDocAnalyzerCleanup;
                if (typeof cleanup !== "function") return;
                try {
                  cleanup();
                } catch (_) {}
                el.__sfDocAnalyzerCleanup = null;
              });
            } catch (_) {}
            rootEl.removeEventListener("pointerover", onPointerOver);
            rootEl.removeEventListener("pointerout", onPointerOut);
            rootEl.removeEventListener("pointerleave", onPointerLeave);
          };
        }, [html]);

        return React.createElement("div", {
          ref: rootRef,
          className: "md",
          dangerouslySetInnerHTML: { __html: html },
        });
      }

      function DocModal({ open, title, md, onClose }) {
        useEffect(() => {
          if (!open) return;
          const onKeyDown = (e) => {
            if (e.key === "Escape") onClose();
          };
          window.addEventListener("keydown", onKeyDown);
          return () => window.removeEventListener("keydown", onKeyDown);
        }, [open, onClose]);

        if (!open) return null;

        return React.createElement(
          "div",
          { className: "modalOverlay", onMouseDown: (e) => (e.target === e.currentTarget ? onClose() : null) },
          React.createElement(
            "div",
            { className: "modal" },
            React.createElement(
              "div",
              { className: "modalHeader" },
              React.createElement("div", { className: "modalTitle" }, title || ""),
              React.createElement("button", { className: "btn primary", onClick: onClose }, "Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ")
            ),
            React.createElement("div", { className: "modalBody" }, React.createElement("div", { className: "doc" }, React.createElement(MarkdownViewer, { md })))
          )
        );
      }

      function DocAnalyzerModal({ open, docKey, tab, onChangeTab, onClose }) {
        const hostRef = useRef(null);
        const cleanupRef = useRef(null);

        useEffect(() => {
          if (!open) return;
          const onKeyDown = (e) => {
            if (e.key === "Escape") onClose();
          };
          window.addEventListener("keydown", onKeyDown);
          return () => window.removeEventListener("keydown", onKeyDown);
        }, [open, onClose]);

        const analyzers = useMemo(() => safeGetDocAnalyzers(), [open]);

        useEffect(() => {
          if (!open) return;
          const hostEl = hostRef.current;
          if (!hostEl) return;

          const key = String(docKey || "").trim();
          const analyzer = analyzers && key ? analyzers[key] : null;

          try {
            const prev = cleanupRef.current;
            if (typeof prev === "function") prev();
          } catch (_) {}
          cleanupRef.current = null;

          if (!analyzer) {
            hostEl.innerHTML = `<div class="help">ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð°Ð½Ð°Ð»Ð¸Ð·Ð°Ñ‚Ð¾Ñ€Ð° Ð´Ð»Ñ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð°: ${escapeHtml(key || "â€”")}</div>`;
            return;
          }

          const cleanup = mountDocAnalyzer(hostEl, analyzer, { activeType: String(tab || "segment") });
          cleanupRef.current = cleanup;

          return () => {
            try {
              const prev = cleanupRef.current;
              if (typeof prev === "function") prev();
            } catch (_) {}
            cleanupRef.current = null;
          };
        }, [open, analyzers, docKey]);

        useEffect(() => {
          if (!open) return;
          const cleanup = cleanupRef.current;
          if (cleanup && typeof cleanup.setActiveType === "function") cleanup.setActiveType(tab);
        }, [open, tab]);

        if (!open) return null;

        const key = String(docKey || "");
        const analyzer = analyzers && key ? analyzers[key] : null;
        const title = analyzer ? `Document Analyzer â€” ${String(analyzer.title || key || "")}` : "Document Analyzer";

        const tabs = [
          { key: "segment", label: "Ð¡ÐµÐ³Ð¼ÐµÐ½Ñ‚Ñ‹" },
          { key: "need", label: "ÐŸÐ¾Ñ‚Ñ€ÐµÐ±Ð½Ð¾ÑÑ‚Ð¸" },
          { key: "feature", label: "Ð¤ÑƒÐ½ÐºÑ†. Ñ€ÐµÑˆÐµÐ½Ð¸Ñ" },
          { key: "channel", label: "ÐšÐ°Ð½Ð°Ð»Ñ‹" },
          { key: "sales_best_practice", label: "Sales BP" },
          { key: "trigger", label: "Ð¢Ñ€Ð¸Ð³Ð³ÐµÑ€Ñ‹" },
        ];
        const tabButtons = tabs.map((t) =>
          React.createElement(
            "button",
            {
              key: t.key,
              className: "sfModalTab" + (String(t.key) === String(tab) ? " active" : ""),
              onClick: () => onChangeTab && onChangeTab(t.key),
            },
            t.label
          )
        );

        return React.createElement(
          "div",
          { className: "modalOverlay", onMouseDown: (e) => (e.target === e.currentTarget ? onClose() : null) },
          React.createElement(
            "div",
            { className: "modal modalXL" },
            React.createElement(
              "div",
              { className: "modalHeader" },
              React.createElement(
                "div",
                null,
                React.createElement("div", { className: "modalTitle" }, title),
                React.createElement("div", { className: "help", style: { marginTop: 4 } }, "ÐŸÐµÑ€ÐµÐºÐ»ÑŽÑ‡Ð°Ð¹ Ð²ÐºÐ»Ð°Ð´ÐºÐ¸. Ð­Ñ‚Ð¾ Ð´ÐµÐ¼Ð¾ extractorâ€™Ð°: trust/evidence â€” proxy.")
              ),
              React.createElement("button", { className: "btn primary", onClick: onClose }, "Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ")
            ),
            React.createElement(
              "div",
              { className: "modalBody" },
              React.createElement("div", { className: "sfModalTabs" }, tabButtons),
              React.createElement(
                "div",
                { style: { marginTop: 12 } },
                React.createElement("div", { className: "doc" }, React.createElement("div", { className: "md", ref: hostRef }))
              )
            )
          )
        );
      }

      function SourcesRegistryModal({ open, title, sources, mix, repoUrl, initialTypeKey, onClose }) {
        const [query, setQuery] = useState("");
        const [typeKey, setTypeKey] = useState("");

        useEffect(() => {
          if (!open) return;
          setQuery("");
          setTypeKey(String(initialTypeKey || ""));
        }, [open, initialTypeKey]);

        useEffect(() => {
          if (!open) return;
          const onKeyDown = (e) => {
            if (e.key === "Escape") onClose();
          };
          window.addEventListener("keydown", onKeyDown);
          return () => window.removeEventListener("keydown", onKeyDown);
        }, [open, onClose]);

        const options = useMemo(() => {
          const all = { key: "", label: "Ð’ÑÐµ", count: Array.isArray(sources) ? sources.length : 0 };
          return [all].concat(Array.isArray(mix) ? mix : []);
        }, [mix, sources]);

        const filtered = useMemo(() => {
          const list = Array.isArray(sources) ? sources : [];
          const q = String(query || "").trim().toLowerCase();
          return list.filter((s) => {
            if (typeKey && String(s.type_key) !== typeKey) return false;
            if (!q) return true;
            const hay = `${s.title || ""} ${s.url || ""}`.toLowerCase();
            return hay.includes(q);
          });
        }, [sources, typeKey, query]);

        if (!open) return null;

        const headerTitle = (() => {
          if (!typeKey) return title || "Ð ÐµÐµÑÑ‚Ñ€ Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¾Ð²";
          const hit = (Array.isArray(mix) ? mix : []).find((m) => String(m.key) === typeKey);
          if (hit) return `${title || "Ð˜ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¸"} â€¢ ${hit.label}`;
          return `${title || "Ð˜ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¸"} â€¢ ${typeKey}`;
        })();

        const rows = filtered.slice(0, 500).map((s) =>
          React.createElement(
            "tr",
            { key: s.id || String(s.index || Math.random()) },
            React.createElement("td", null, React.createElement("span", { className: "sfTag" }, s.type_key || "")),
            React.createElement(
              "td",
              null,
              React.createElement("div", { style: { fontWeight: 850, lineHeight: 1.25 } }, s.title || ""),
              React.createElement(
                "div",
                { style: { marginTop: 6 } },
                React.createElement("a", { href: s.url || "#", target: "_blank", rel: "noopener noreferrer" }, String(s.url || "").replace(/^https?:\/\//, ""))
              )
            ),
            React.createElement("td", null, s.published_at || ""),
            React.createElement(
              "td",
              null,
              React.createElement("span", { className: "sfTag" }, s.freshness || ""),
              React.createElement("span", { className: "sfTag", style: { marginLeft: 6 } }, `${String(s.days_ago || 0)}d`)
            ),
            React.createElement("td", null, React.createElement("span", { className: "sfTag" }, s.trust || ""))
          )
        );

        return React.createElement(
          "div",
          { className: "modalOverlay", onMouseDown: (e) => (e.target === e.currentTarget ? onClose() : null) },
          React.createElement(
            "div",
            { className: "modal" },
            React.createElement(
              "div",
              { className: "modalHeader" },
              React.createElement(
                "div",
                null,
                React.createElement("div", { className: "modalTitle" }, headerTitle),
                React.createElement("div", { className: "help", style: { marginTop: 4 } }, `ÐŸÐ¾ÐºÐ°Ð·Ð°Ð½Ð¾: ${Math.min(filtered.length, 500)} Ð¸Ð· ${filtered.length}. Ð’ÑÐµÐ³Ð¾ Ð² ÐºÐ¾Ñ€Ð¿ÑƒÑÐµ: ${(Array.isArray(sources) ? sources.length : 0)}.`)
              ),
              React.createElement("button", { className: "btn primary", onClick: onClose }, "Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ")
            ),
            React.createElement(
              "div",
              { className: "modalBody" },
              React.createElement(
                "div",
                { style: { display: "flex", gap: 8, flexWrap: "wrap", alignItems: "center" } },
                options.map((o) =>
                  React.createElement(
                    "button",
                    { key: String(o.key), className: "btn" + (String(o.key) === typeKey ? " activeTab" : ""), onClick: () => setTypeKey(String(o.key)) },
                    `${o.label} (${o.count})`
                  )
                )
              ),
              React.createElement(
                "div",
                { style: { display: "flex", gap: 10, flexWrap: "wrap", alignItems: "center", marginTop: 10 } },
                React.createElement("input", { className: "input", value: query, onChange: (e) => setQuery(e.target.value), placeholder: "ÐŸÐ¾Ð¸ÑÐº Ð¿Ð¾ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÑŽ Ð¸Ð»Ð¸ URL" }),
                repoUrl ? React.createElement("a", { className: "btn", href: repoUrl, target: "_blank", rel: "noopener noreferrer" }, "Ð¥Ñ€Ð°Ð½Ð¸Ð»Ð¸Ñ‰Ðµ") : null
              ),
              React.createElement(
                "div",
                { className: "doc", style: { marginTop: 12 } },
                React.createElement(
                  "div",
                  { className: "md" },
                  React.createElement(
                    "table",
                    { className: "sfTable" },
                    React.createElement(
                      "thead",
                      null,
                      React.createElement("tr", null, React.createElement("th", null, "Type"), React.createElement("th", null, "Source"), React.createElement("th", null, "Published"), React.createElement("th", null, "Freshness"), React.createElement("th", null, "Trust"))
                    ),
                    React.createElement("tbody", null, rows)
                  )
                )
              )
            )
          )
        );
      }

      function LeadContextModal({ open, lead, setLead, briefMd, onLoadExample, onClear, onClose }) {
        const [tab, setTab] = useState("context");

        useEffect(() => {
          if (!open) return;
          setTab("context");
          const onKeyDown = (e) => {
            if (e.key === "Escape") onClose();
          };
          window.addEventListener("keydown", onKeyDown);
          return () => window.removeEventListener("keydown", onKeyDown);
        }, [open, onClose]);

        if (!open) return null;

        const briefApplied = applyLeadPlaceholders(String(briefMd || ""), lead);

        return React.createElement(
          "div",
          { className: "modalOverlay", onMouseDown: (e) => (e.target === e.currentTarget ? onClose() : null) },
          React.createElement(
            "div",
            { className: "modal" },
            React.createElement(
              "div",
              { className: "modalHeader" },
              React.createElement("div", { className: "modalTitle" }, "T00 â€” ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ (Ð¿Ð¾ÑÐ»Ðµ Ð²ÑÑ‚Ñ€ÐµÑ‡Ð¸)"),
              React.createElement(
                "div",
                { style: { display: "flex", gap: 8, flexWrap: "wrap", justifyContent: "flex-end" } },
                React.createElement("button", { className: "btn" + (tab === "context" ? " activeTab" : ""), onClick: () => setTab("context") }, "Ð¢ÐµÐ³Ð¸"),
                React.createElement("button", { className: "btn" + (tab === "brief" ? " activeTab" : ""), onClick: () => setTab("brief") }, "Ð”Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚"),
                React.createElement("button", { className: "btn", onClick: onLoadExample }, "ÐŸÑ€Ð¸Ð¼ÐµÑ€"),
                React.createElement("button", { className: "btn", onClick: onClear }, "ÐžÑ‡Ð¸ÑÑ‚Ð¸Ñ‚ÑŒ"),
                React.createElement("button", { className: "btn primary", onClick: onClose }, "Ð“Ð¾Ñ‚Ð¾Ð²Ð¾")
              )
            ),
            React.createElement(
              "div",
              { className: "modalBody" },
              tab === "brief"
                ? React.createElement("div", { className: "doc", style: { marginTop: 4 } }, React.createElement(MarkdownViewer, { md: briefApplied }))
                : React.createElement(
                    "div",
                    { className: "formGrid" },
                    React.createElement("input", { className: "input", value: lead.company || "", onChange: (e) => setLead({ ...lead, company: e.target.value }), placeholder: "ÐšÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ñ" }),
                    React.createElement("input", { className: "input", value: lead.product || "", onChange: (e) => setLead({ ...lead, product: e.target.value }), placeholder: "ÐŸÑ€Ð¾Ð´ÑƒÐºÑ‚ / Ð¾Ñ„Ñ„ÐµÑ€" }),
                    React.createElement("input", { className: "input", value: lead.geo || "", onChange: (e) => setLead({ ...lead, geo: e.target.value }), placeholder: "Ð“ÐµÐ¾Ð³Ñ€Ð°Ñ„Ð¸Ñ" }),
                    React.createElement("input", { className: "input", value: lead.industry || "", onChange: (e) => setLead({ ...lead, industry: e.target.value }), placeholder: "Ð˜Ð½Ð´ÑƒÑÑ‚Ñ€Ð¸Ñ / ÐºÐ°Ñ‚ÐµÐ³Ð¾Ñ€Ð¸Ñ" }),
                    React.createElement("textarea", { className: "input", value: lead.competitors_shortlist || "", onChange: (e) => setLead({ ...lead, competitors_shortlist: e.target.value }), placeholder: "ÐšÐ¾Ð½ÐºÑƒÑ€ÐµÐ½Ñ‚Ñ‹ (Ð¿Ð¾ Ð¾Ð´Ð½Ð¾Ð¼Ñƒ Ð½Ð° ÑÑ‚Ñ€Ð¾ÐºÑƒ)" }),
                    React.createElement("div", { className: "help" }, "Ð­Ñ‚Ð¸ Ð¿Ð¾Ð»Ñ Ð¿Ð¾Ð´ÑÑ‚Ð°Ð²Ð»ÑÑŽÑ‚ÑÑ Ð² ÑˆÐ°Ð±Ð»Ð¾Ð½Ñ‹ ÐºÐ°Ðº {{company}}, {{product}}, {{geo}}, {{industry}}, {{competitors_shortlist}}.")
                  )
            )
          )
        );
      }

      function useLocalStorageObject(key, initialValue) {
        const normalize = (obj) => {
          if (!obj || typeof obj !== "object") return initialValue;
          const out = { ...initialValue, ...obj };
          for (const [k, v] of Object.entries(out)) {
            if (typeof v !== "string") continue;
            const trimmed = v.trim();
            if (trimmed.startsWith("{{") && trimmed.endsWith("}}")) out[k] = "";
            else out[k] = trimmed;
          }
          return out;
        };

        const [value, setValue] = useState(() => {
          try {
            const raw = localStorage.getItem(key);
            if (!raw) return initialValue;
            const obj = JSON.parse(raw);
            return normalize(obj && typeof obj === "object" ? obj : initialValue);
          } catch (_) {
            return initialValue;
          }
        });

        const set = (next) => {
          const normalized = normalize(next);
          setValue(normalized);
          try {
            localStorage.setItem(key, JSON.stringify(normalized));
          } catch (_) {}
        };

        return [value, set];
      }

      function useLocalStorageBool(key, initialValue) {
        const [value, setValue] = useState(() => {
          try {
            const raw = localStorage.getItem(key);
            if (raw == null) return Boolean(initialValue);
            return raw === "1" || raw === "true";
          } catch (_) {
            return Boolean(initialValue);
          }
        });

        const set = (next) => {
          const v = Boolean(next);
          setValue(v);
          try {
            localStorage.setItem(key, v ? "1" : "0");
          } catch (_) {}
        };

        return [value, set];
      }

      function applyLeadPlaceholders(text, lead) {
        let out = String(text || "");
        const map = lead || {};
        for (const [k, v] of Object.entries(map)) {
          const val = String(v == null ? "" : v);
          out = out.replaceAll(`{{${k}}}`, val);
        }
        return out;
      }

      const T01_SOURCE_MIX = [
        { key: "web", label: "Web search", count: 146, color: "#1a73e8" },
        { key: "competitors", label: "ÐœÐ°Ñ‚ÐµÑ€Ð¸Ð°Ð»Ñ‹ ÐºÐ¾Ð½ÐºÑƒÑ€ÐµÐ½Ñ‚Ð¾Ð²", count: 86, color: "#34a853" },
        { key: "ugc", label: "ÐžÑ‚Ð·Ñ‹Ð²Ñ‹/ÑÐ¾Ð¾Ð±Ñ‰ÐµÑÑ‚Ð²Ð° (UGC)", count: 61, color: "#f9ab00" },
        { key: "video", label: "Ð’Ð¸Ð´ÐµÐ¾", count: 42, color: "#ea4335" },
        { key: "reports", label: "ÐžÑ‚Ñ‡Ñ‘Ñ‚Ñ‹/ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ°", count: 34, color: "#9334e6" },
        { key: "ads", label: "Ad libraries", count: 25, color: "#00acc1" },
        { key: "regulatory", label: "Ð ÐµÐ³ÑƒÐ»ÑÑ‚Ð¾Ñ€Ð¸ÐºÐ°", count: 16, color: "#5f6368" },
        { key: "audience", label: "Audience insights", count: 10, color: "#9aa0a6" },
      ];

      const T01_SOURCE_REPO_URL_DEMO = "https://example.com/source_repository";

      const DOC_ANALYZER_DEMOS = {}; /* legacy inline dataset (disabled):
        mckinsey_wellness: {
          key: "mckinsey_wellness",
          title: "McKinsey â€” Global wellness market (extract demo)",
          pdf_url: "Example%20researches/the-2-trillion-dollar-global-wellness-market-gets-a-millennial-and-gen-z-glow-up_final.pdf",
          page_count: 13,
          catalog_segments: 21,
          catalog_needs: 52,
          items: [
            {
              key: "seg_11",
              type: "segment",
              code: "S11",
              label: "Gen Z (Ð¿Ð¾Ð´Ñ€Ð¾ÑÑ‚ÐºÐ¸/ÑÑ‚ÑƒÐ´ÐµÐ½Ñ‚Ñ‹)",
              totals: { count: 43, pages: 13 },
              detail: {
                payload: "seg_11",
                name: "Gen Z (Ð¿Ð¾Ð´Ñ€Ð¾ÑÑ‚ÐºÐ¸/ÑÑ‚ÑƒÐ´ÐµÐ½Ñ‚Ñ‹)",
                mentions: "43",
                context: "Ð˜Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¾ Ð¸Ð· McKinsey PDF (Ð´ÐµÐ¼Ð¾) â€” ÑÐ¼. Ð¿Ð¾Ð´ÑÐ²ÐµÑ‚ÐºÑƒ Ð½Ð° ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ð°Ñ….",
                evidence: "McKinsey â€¢ PDF extract",
              },
            },
            {
              key: "seg_20",
              type: "segment",
              code: "S20",
              label: "Millennials",
              totals: { count: 33, pages: 13 },
              detail: {
                payload: "seg_20",
                name: "Millennials",
                mentions: "33",
                context: "Ð˜Ð·Ð²Ð»ÐµÑ‡ÐµÐ½Ð¾ Ð¸Ð· McKinsey PDF (Ð´ÐµÐ¼Ð¾) â€” ÑÐ¼. Ð¿Ð¾Ð´ÑÐ²ÐµÑ‚ÐºÑƒ Ð½Ð° ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ð°Ñ….",
                evidence: "McKinsey â€¢ PDF extract",
              },
            },
            { key: "need_wellness", type: "need", code: "N", label: "wellness", totals: { count: 124, pages: 13 } },
            { key: "need_glow_up", type: "need", code: "N", label: "glowâ€‘up", totals: { count: 13, pages: 13 } },
          ],
          pages: [
            {
              page: 1,
              plain: "Example%20researches/mckinsey_pages/page_01.png",
              marked: "Example%20researches/mckinsey_pages_marked/page_01.png",
              hits: {
                seg_11: { count: 1, anchor: [0.202, 0.3245] },
                seg_20: { count: 1, anchor: [0.6283, 0.274] },
                need_wellness: { count: 3, anchor: [0.8168, 0.2235] },
                need_glow_up: { count: 1, anchor: [0.4046, 0.3245] },
              },
            },
            {
              page: 2,
              plain: "Example%20researches/mckinsey_pages/page_02.png",
              marked: "Example%20researches/mckinsey_pages_marked/page_02.png",
              hits: {
                seg_11: { count: 2, anchor: [0.383, 0.1152] },
                seg_20: { count: 2, anchor: [0.2818, 0.1152] },
                need_wellness: { count: 16, anchor: [0.4464, 0.1155] },
                need_glow_up: { count: 1, anchor: [0.8606, 0.9759] },
              },
            },
            {
              page: 3,
              plain: "Example%20researches/mckinsey_pages/page_03.png",
              marked: "Example%20researches/mckinsey_pages_marked/page_03.png",
              hits: {
                seg_11: { count: 1, anchor: [0.8228, 0.9759] },
                seg_20: { count: 1, anchor: [0.7596, 0.9759] },
                need_wellness: { count: 12, anchor: [0.2885, 0.0549] },
                need_glow_up: { count: 1, anchor: [0.8606, 0.9759] },
              },
            },
            {
              page: 4,
              plain: "Example%20researches/mckinsey_pages/page_04.png",
              marked: "Example%20researches/mckinsey_pages_marked/page_04.png",
              hits: {
                seg_11: { count: 7, anchor: [0.2555, 0.1319] },
                seg_20: { count: 7, anchor: [0.5937, 0.1319] },
                need_wellness: { count: 13, anchor: [0.6357, 0.1155] },
                need_glow_up: { count: 1, anchor: [0.8606, 0.9759] },
              },
            },
            {
              page: 5,
              plain: "Example%20researches/mckinsey_pages/page_05.png",
              marked: "Example%20researches/mckinsey_pages_marked/page_05.png",
              hits: {
                seg_11: { count: 5, anchor: [0.3077, 0.1155] },
                seg_20: { count: 4, anchor: [0.3925, 0.1155] },
                need_wellness: { count: 8, anchor: [0.4589, 0.1155] },
                need_glow_up: { count: 1, anchor: [0.8606, 0.9759] },
              },
            },
            {
              page: 6,
              plain: "Example%20researches/mckinsey_pages/page_06.png",
              marked: "Example%20researches/mckinsey_pages_marked/page_06.png",
              hits: {
                seg_11: { count: 5, anchor: [0.2453, 0.1483] },
                seg_20: { count: 4, anchor: [0.3981, 0.474] },
                need_wellness: { count: 7, anchor: [0.7494, 0.247] },
                need_glow_up: { count: 1, anchor: [0.8606, 0.9759] },
              },
            },
            {
              page: 7,
              plain: "Example%20researches/mckinsey_pages/page_07.png",
              marked: "Example%20researches/mckinsey_pages_marked/page_07.png",
              hits: {
                seg_11: { count: 6, anchor: [0.5189, 0.1155] },
                seg_20: { count: 4, anchor: [0.7652, 0.1813] },
                need_wellness: { count: 21, anchor: [0.4206, 0.1813] },
                need_glow_up: { count: 1, anchor: [0.8606, 0.9759] },
              },
            },
            {
              page: 8,
              plain: "Example%20researches/mckinsey_pages/page_08.png",
              marked: "Example%20researches/mckinsey_pages_marked/page_08.png",
              hits: {
                seg_11: { count: 2, anchor: [0.4489, 0.7271] },
                seg_20: { count: 2, anchor: [0.5322, 0.7271] },
                need_wellness: { count: 14, anchor: [0.7125, 0.1155] },
                need_glow_up: { count: 1, anchor: [0.8606, 0.9759] },
              },
            },
            {
              page: 9,
              plain: "Example%20researches/mckinsey_pages/page_09.png",
              marked: "Example%20researches/mckinsey_pages_marked/page_09.png",
              hits: {
                seg_11: { count: 1, anchor: [0.8228, 0.9759] },
                seg_20: { count: 1, anchor: [0.7596, 0.9759] },
                need_wellness: { count: 4, anchor: [0.254, 0.1114] },
                need_glow_up: { count: 1, anchor: [0.8606, 0.9759] },
              },
            },
            {
              page: 10,
              plain: "Example%20researches/mckinsey_pages/page_10.png",
              marked: "Example%20researches/mckinsey_pages_marked/page_10.png",
              hits: {
                seg_11: { count: 6, anchor: [0.3938, 0.1649] },
                seg_20: { count: 1, anchor: [0.7596, 0.9759] },
                need_wellness: { count: 6, anchor: [0.4754, 0.1155] },
                need_glow_up: { count: 1, anchor: [0.8606, 0.9759] },
              },
            },
            {
              page: 11,
              plain: "Example%20researches/mckinsey_pages/page_11.png",
              marked: "Example%20researches/mckinsey_pages_marked/page_11.png",
              hits: {
                seg_11: { count: 3, anchor: [0.6179, 0.5756] },
                seg_20: { count: 2, anchor: [0.3739, 0.6412] },
                need_wellness: { count: 9, anchor: [0.456, 0.1152] },
                need_glow_up: { count: 1, anchor: [0.8606, 0.9759] },
              },
            },
            {
              page: 12,
              plain: "Example%20researches/mckinsey_pages/page_12.png",
              marked: "Example%20researches/mckinsey_pages_marked/page_12.png",
              hits: {
                seg_11: { count: 2, anchor: [0.4521, 0.77] },
                seg_20: { count: 2, anchor: [0.5353, 0.77] },
                need_wellness: { count: 3, anchor: [0.254, 0.1126] },
                need_glow_up: { count: 1, anchor: [0.8606, 0.9759] },
              },
            },
            {
              page: 13,
              plain: "Example%20researches/mckinsey_pages/page_13.png",
              marked: "Example%20researches/mckinsey_pages_marked/page_13.png",
              hits: {
                seg_11: { count: 2, anchor: [0.5199, 0.3374] },
                seg_20: { count: 2, anchor: [0.2983, 0.3456] },
                need_wellness: { count: 8, anchor: [0.2733, 0.3292] },
                need_glow_up: { count: 1, anchor: [0.8606, 0.9759] },
              },
            },
          ],
        },
      }; */

      window.SEGFLOW_DOC_ANALYZERS = window.SEGFLOW_DOC_ANALYZERS || DOC_ANALYZER_DEMOS;

      function createRng(seed) {
        let state = Number(seed) || 0;
        return () => {
          state = (1664525 * state + 1013904223) % 4294967296;
          return state / 4294967296;
        };
      }

      function toIsoDate(d) {
        if (!(d instanceof Date)) return "";
        return d.toISOString().slice(0, 10);
      }

      function freshnessLabel(daysAgo) {
        if (daysAgo <= 90) return "fresh";
        if (daysAgo <= 270) return "ok";
        return "stale";
      }

      function trustFromRand(typeKey, r) {
        const x = Number(r) || 0;
        const dist = {
          web: [
            ["B", 0.55],
            ["C", 1.0],
          ],
          competitors: [
            ["B", 0.7],
            ["C", 1.0],
          ],
          ugc: [
            ["B", 0.2],
            ["C", 1.0],
          ],
          video: [
            ["B", 0.3],
            ["C", 1.0],
          ],
          reports: [
            ["A", 0.7],
            ["B", 1.0],
          ],
          ads: [
            ["B", 0.65],
            ["C", 1.0],
          ],
          regulatory: [
            ["A", 0.8],
            ["B", 1.0],
          ],
          audience: [
            ["B", 0.8],
            ["C", 1.0],
          ],
        };
        const list = dist[typeKey] || [
          ["B", 0.6],
          ["C", 1.0],
        ];
        for (const [val, threshold] of list) {
          if (x <= threshold) return val;
        }
        return list[list.length - 1][0];
      }

      function buildT01DemoSources() {
        const now = new Date();
        const sources = [];
        let globalIndex = 1;

        for (let typeIndex = 0; typeIndex < T01_SOURCE_MIX.length; typeIndex += 1) {
          const t = T01_SOURCE_MIX[typeIndex];
          const rand = createRng(1337 + typeIndex * 997);

          for (let i = 0; i < t.count; i += 1) {
            const daysAgo = Math.floor(rand() * 540);
            const publishedAt = new Date(now.getTime() - daysAgo * 86400000);
            const trust = trustFromRand(t.key, rand());
            const freshness = freshnessLabel(daysAgo);
            const id = `${t.key}-${String(i + 1).padStart(3, "0")}`;
            const domainStub = `${t.key}.example.com`;

            sources.push({
              index: globalIndex,
              id,
              type_key: t.key,
              type_label: t.label,
              title: `${t.label} â€” Ð¼Ð°Ñ‚ÐµÑ€Ð¸Ð°Ð» #${String(i + 1)}`,
              url: `https://${domainStub}/sources/${encodeURIComponent(id)}`,
              published_at: toIsoDate(publishedAt),
              days_ago: daysAgo,
              freshness,
              trust,
            });
            globalIndex += 1;
          }
        }

        sources.sort((a, b) => String(b.published_at).localeCompare(String(a.published_at)));
        return sources;
      }

      const T01_SOURCES_DEMO = buildT01DemoSources();

      function TouchViewer({ touch, bundle, lead, isDemoMode, expertMode, onCopyTelegram }) {
        const [tab, setTab] = useState("report");
        const [sourcesModal, setSourcesModal] = useState({ open: false, typeKey: "" });
        const [docAnalyzerModal, setDocAnalyzerModal] = useState({ open: false, key: "", tab: "segment" });
        const [segmentModal, setSegmentModal] = useState({ open: false, title: "", md: "" });
        const [creativeModal, setCreativeModal] = useState({ open: false, title: "", md: "" });

        useEffect(() => {
          setTab("report");
          setSourcesModal({ open: false, typeKey: "" });
          setDocAnalyzerModal({ open: false, key: "", tab: "segment" });
          setSegmentModal({ open: false, title: "", md: "" });
          setCreativeModal({ open: false, title: "", md: "" });
        }, [touch && touch.id]);

        if (!touch) return React.createElement("div", { className: "empty" }, "Ð’Ñ‹Ð±ÐµÑ€Ð¸ ÐºÐ°ÑÐ°Ð½Ð¸Ðµ ÑÐ²ÐµÑ€Ñ…Ñƒ.");

        const reportPath = (isDemoMode && touch.demo_report_path) || touch.report_path;
        const telegramPath = (isDemoMode && touch.demo_telegram_path) || touch.telegram_path;
        const reportRaw = bundle[reportPath] || "";
        const telegramRaw = bundle[telegramPath] || "";
        const report = applyLeadPlaceholders(reportRaw, lead);
        const telegram = applyLeadPlaceholders(telegramRaw, lead);
        const reportView = expertMode ? report : filterMarkdownHideJsonBlocks(report);
        const telegramView = expertMode ? telegram : filterMarkdownHideJsonBlocks(telegram);

        const onReportAction = (action, payload, el) => {
          if (!touch) return;
          if (action === "open_sources_registry") {
            setSourcesModal({ open: true, typeKey: "" });
            return;
          }
          if (action === "open_source_segment") {
            setSourcesModal({ open: true, typeKey: String(payload || "") });
            return;
          }
          if (action === "open_doc_analyzer") {
            const key = String(payload || "").trim();
            const nextTabRaw = (el && el.getAttribute && el.getAttribute("data-sf-tab")) || "";
            const nextTab = normalizeT01CatalogType(nextTabRaw || "segment");
            setDocAnalyzerModal((prev) => ({
              open: true,
              key: key || prev.key || "mckinsey_wellness",
              tab: nextTabRaw ? nextTab : prev.tab || "segment",
            }));
            return;
          }
          if (action === "set_t01_catalog_type") {
            const next = normalizeT01CatalogType(payload);
            try {
              const scope = (el && el.closest && el.closest(".doc")) || document;
              if (scope && scope.setAttribute) scope.setAttribute("data-sf-t01-catalog", next);
              syncT01SegmentGroups(scope);
              syncT01SegmentGroupVisuals(scope);
            } catch (_) {}
            return;
          }
          if (action === "set_t01_seg_view") {
            const next = String(payload || "").trim().toLowerCase();
            const view = next === "cards" ? "cards" : "bubbles";
            try {
              const scope = (el && el.closest && el.closest(".doc")) || document;
              if (scope && scope.setAttribute) scope.setAttribute("data-sf-seg-view", view);
              syncT01SegmentGroupVisuals(scope);
            } catch (_) {}
            return;
          }
          if (action === "set_t01_seg_viz") {
            const next = String(payload || "").trim().toLowerCase();
            const allow = new Set(["constellation", "quadrant_deck", "bump", "swarm", "treemap"]);
            const viz = allow.has(next) ? next : "constellation";
            try {
              const scope = (el && el.closest && el.closest(".doc")) || document;
              if (scope && scope.setAttribute) scope.setAttribute("data-sf-seg-viz", viz);
              syncT01SegmentGroupVisuals(scope);
            } catch (_) {}
            return;
          }
          if (action === "open_t01_seg_quad_help") {
            const key = String(payload || "").trim().toLowerCase();
            const map = {
              best: {
                title: "Ð¡Ð¸Ð»ÑŒÐ½Ñ‹Ðµ",
                meaning: "Ð§Ð°ÑÑ‚Ð¾ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°ÑŽÑ‚ÑÑ + Ð²Ñ‹ÑÐ¾ÐºÐ¸Ð¹ trust (proxy).",
                hint: "ÐšÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚Ñ‹ Ð² Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚: ÑƒÐ¶Ðµ â€œÐ¿Ð¾Ð´Ð´ÐµÑ€Ð¶Ð°Ð½Ñ‹â€ ÐºÐ¾Ñ€Ð¿ÑƒÑÐ¾Ð¼ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð². Ð”Ð°Ð»ÑŒÑˆÐµ â€” Ð¿Ñ€Ð¾Ð²ÐµÑ€ÑÑ‚ÑŒ fit Ð½Ð° Ð²Ð°ÑˆÐµÐ¼ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ðµ/Ð³ÐµÐ¾.",
              },
              noisy: {
                title: "Ð¨ÑƒÐ¼",
                meaning: "Ð§Ð°ÑÑ‚Ð¾ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°ÑŽÑ‚ÑÑ + Ð½Ð¸Ð·ÐºÐ¸Ð¹ trust (proxy).",
                hint: "ÐœÐ¾Ð¶ÐµÑ‚ Ð±Ñ‹Ñ‚ÑŒ Ñ…Ð°Ð¹Ð¿/Ð¼Ð°Ñ€ÐºÐµÑ‚Ð¸Ð½Ð³Ð¾Ð²Ð°Ñ Ñ„Ð¾Ñ€Ð¼ÑƒÐ»Ð¸Ñ€Ð¾Ð²ÐºÐ°/ÑÐ»Ð°Ð±Ñ‹Ðµ Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¸. ÐÑƒÐ¶Ð½Ð° Ð²ÐµÑ€Ð¸Ñ„Ð¸ÐºÐ°Ñ†Ð¸Ñ: ÐºÐ°ÐºÐ¸Ðµ Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¸, Ð³Ð´Ðµ Ð¸Ð¼ÐµÐ½Ð½Ð¾ Ð²ÑÑ‚Ñ€ÐµÑ‡Ð°ÐµÑ‚ÑÑ, Ð¿Ð¾Ð²Ñ‚Ð¾Ñ€ÑÐµÐ¼Ð¾ÑÑ‚ÑŒ.",
              },
              niche: {
                title: "ÐÐ¸ÑˆÐ°",
                meaning: "Ð ÐµÐ´ÐºÐ¾ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°ÑŽÑ‚ÑÑ + Ð²Ñ‹ÑÐ¾ÐºÐ¸Ð¹ trust (proxy).",
                hint: "Ð£Ð·ÐºÐ¸Ðµ, Ð½Ð¾ â€œÑ‡ÐµÑÑ‚Ð½Ñ‹Ðµâ€ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ñ‹. Ð¥Ð¾Ñ€Ð¾ÑˆÐ¾ Ð´Ð»Ñ Ñ†ÐµÐ»ÐµÐ²Ñ‹Ñ… ÑÐºÑÐ¿ÐµÑ€Ð¸Ð¼ÐµÐ½Ñ‚Ð¾Ð²/Ð¿Ð°ÐºÐµÑ‚Ð¾Ð²/Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¹.",
              },
              low: {
                title: "Ð¡Ð»Ð°Ð±Ñ‹Ðµ",
                meaning: "Ð ÐµÐ´ÐºÐ¾ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°ÑŽÑ‚ÑÑ + Ð½Ð¸Ð·ÐºÐ¸Ð¹ trust (proxy).",
                hint: "ÐŸÐ¾ÐºÐ° Ð½Ðµ Ñ‚Ñ€Ð°Ñ‚Ð¸Ð¼ Ð²Ñ€ÐµÐ¼Ñ: Ð²Ð¾Ð·Ð²Ñ€Ð°Ñ‰Ð°ÐµÐ¼ÑÑ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ ÐµÑÐ»Ð¸ Ð²ÑÐ¿Ð»Ñ‹Ð²Ð°ÐµÑ‚ Ð² Ð´Ñ€ÑƒÐ³Ð¸Ñ… Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ°Ñ… Ð¸Ð»Ð¸ ÐµÑÑ‚ÑŒ Ð±Ð¸Ð·Ð½ÐµÑ-Ð³Ð¸Ð¿Ð¾Ñ‚ÐµÐ·Ð°.",
              },
            };
            const item = map[key] || map.best;
            const md = [
              `<h3>${escapeHtml(item.title)}</h3>`,
              `<div class="sfDetailsBody"><b>Ð§Ñ‚Ð¾ Ð·Ð½Ð°Ñ‡Ð¸Ñ‚:</b> ${escapeHtml(item.meaning)}</div>`,
              `<div class="sfDetailsBody" style="margin-top:10px;"><b>ÐšÐ°Ðº Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ:</b> ${escapeHtml(item.hint)}</div>`,
              `<div class="chartNote" style="margin-top:10px;">X = Î£ ÑƒÐ¿Ð¾Ð¼Ð¸Ð½Ð°Ð½Ð¸Ð¹ (Ð² PDFâ€‘ÐºÐ¾Ñ€Ð¿ÑƒÑÐµ), Y = trust/evidence (proxy). ÐšÐ»Ð¸Ðº Ð¿Ð¾ Ð³Ñ€ÑƒÐ¿Ð¿Ðµ Ð½Ð° ÐºÐ°Ñ€Ñ‚Ðµ â†’ ÐºÐ°Ñ€Ñ‚Ð¾Ñ‡ÐºÐ° Ñ Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ð°Ð¼Ð¸ Ð¸ Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ°Ð¼Ð¸.</div>`,
            ].join("\n");
            setCreativeModal({ open: true, title: "ÐšÐ°Ðº Ñ‡Ð¸Ñ‚Ð°Ñ‚ÑŒ ÐºÐ²Ð°Ð´Ñ€Ð°Ð½Ñ‚Ñ‹", md });
            return;
          }
          if (action === "open_catalog_group_detail") {
            const raw = String(payload || "").trim();
            if (!raw) return;
            const parts = raw.split("|");
            const type = normalizeT01CatalogType(parts[0]);
            const groupId = String(parts.length > 1 ? parts.slice(1).join("|") : raw).trim();
            if (!groupId) return;

            const analyzers = safeGetDocAnalyzers();
            const groups = buildT01CatalogGroups(analyzers, type);
            const group = (Array.isArray(groups) ? groups : []).find((g) => String(g && g.id) === groupId);
            if (!group) return;

            const title = group.name ? `${t01CatalogTypeLabel(type)} â€” ${group.name}` : t01CatalogTypeLabel(type);

            const tag = (t) => `<span class="sfTag">${escapeHtml(t)}</span>`;
            const tags = []
              .concat([tag(`Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ñ‹: ${(group.variants || []).length}`)])
              .concat([tag(`docs: ${group.docsCount || 0}`), tag(`Î£ ÑƒÐ¿.: ${group.totalMentions || 0}`)])
              .concat([tag(`trust: ${group.trust || "B"} (proxy)`)])
              .concat([tag(`type: ${t01CatalogTypeLabel(type)}`)]);

            const findFirstHitPageForAny = (doc, itemKeys) => {
              const keys = Array.isArray(itemKeys) ? itemKeys.map((k) => String(k || "")) : [];
              const pages = Array.isArray(doc && doc.pages) ? doc.pages : [];
              for (const p of pages) {
                const hits = p && p.hits;
                if (!hits) continue;
                for (const k of keys) {
                  if (hits[k] && hits[k].count) return Number(p.page) || 1;
                }
              }
              return 1;
            };

            const variantRows = (group.variants || [])
              .slice()
              .sort((a, b) => (b.totalMentions || 0) - (a.totalMentions || 0))
              .map((v) => {
                const docs = (v.docs || [])
                  .slice()
                  .sort((a, b) => (b.mentions || 0) - (a.mentions || 0))
                  .map((d) => {
                    const label = String(d.title || d.key || "");
                    const short = label.length > 20 ? label.slice(0, 20) + "â€¦" : label;
                    return tag(`${short} (${Number(d.mentions) || 0})`);
                  })
                  .join(" ");
                const name = (v.code ? `${String(v.code)} ` : "") + String(v.label || v.key || "");
                return `
                  <tr>
                    <td><b>${escapeHtml(name)}</b></td>
                    <td>${docs || "â€”"}</td>
                    <td>${escapeHtml(String(v.totalMentions || 0))}</td>
                  </tr>
                `;
              })
              .join("");

            const variantsTable = `
              <table class="sfTable" style="margin-top:10px;">
                <thead>
                  <tr>
                    <th>Ð’Ð°Ñ€Ð¸Ð°Ð½Ñ‚ Ñ„Ð¾Ñ€Ð¼ÑƒÐ»Ð¸Ñ€Ð¾Ð²ÐºÐ¸</th>
                    <th>Ð˜ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¸</th>
                    <th>Î£ ÑƒÐ¿.</th>
                  </tr>
                </thead>
                <tbody>${variantRows || `<tr><td colspan="3" class="help">ÐÐµÑ‚ Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ð¾Ð².</td></tr>`}</tbody>
              </table>
            `;

            const stats =
              group.stats || computeCatalogGroupStatsAcrossDocs(type, (group.variants || []).map((v) => v.key), analyzers);
            const docsRows = (stats.docs || [])
              .map((d) => {
                const doc = analyzers && analyzers[d.key];
                const page = doc ? findFirstHitPageForAny(doc, (group.variants || []).map((v) => v.key)) : 1;
                const url = d.pdfUrl ? `${String(d.pdfUrl)}#page=${page}` : "";
                const link = url
                  ? `<a class="sfInlineLink" href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">PDF â€¢ ÑÑ‚Ñ€. ${page}</a>`
                  : "â€”";
                const da = `<a class="sfInlineLink" href="#" data-sf-action="open_doc_analyzer" data-sf-payload="${escapeHtml(
                  String(d.key || "")
                )}" data-sf-tab="${escapeHtml(type)}">Doc Analyzer</a>`;
                return `
                  <tr>
                    <td><b>${escapeHtml(d.title || d.key)}</b></td>
                    <td>${escapeHtml(String(d.mentions || 0))}</td>
                    <td>${escapeHtml(String(d.pages || "â€”"))}</td>
                    <td>${tag(`trust: ${d.trust || "B"}`)}</td>
                    <td>${link}<div style="margin-top:6px;">${da}</div></td>
                  </tr>
                `;
              })
              .join("");

            const docsTable = stats.docsCount
              ? `
                <div class="sfDetailsBody" style="margin-top:12px;"><b>Ð”Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ñ‹:</b></div>
                <table class="sfTable" style="margin-top:10px;">
                  <thead>
                    <tr>
                      <th>Ð”Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚</th>
                      <th>Ð£Ð¿.</th>
                      <th>Ð¡Ñ‚Ñ€.</th>
                      <th>Trust</th>
                      <th>Ð¡ÑÑ‹Ð»ÐºÐ°</th>
                    </tr>
                  </thead>
                  <tbody>${docsRows}</tbody>
                </table>
                <div class="chartNote">Trust/evidence Ð·Ð´ÐµÑÑŒ â€” <b>proxy</b> (Ð´ÐµÐ¼Ð¾): Ð°Ð³Ñ€ÐµÐ³Ð¸Ñ€ÑƒÐµÐ¼ â€œÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾â€ Ð¿Ð¾ Ñ‚Ð¸Ð¿Ð°Ð¼/Ð²ÐµÑÑƒ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð², Ð½Ðµ ÐºÐ°Ðº Ñ„Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ ÑÐºÐ¾Ñ€Ð¸Ð½Ð³.</div>
              `
              : `<div class="chartNote" style="margin-top:10px;">ÐÐµÑ‚ Ð¿Ñ€Ð¸Ð²ÑÐ·ÐºÐ¸ Ðº PDFâ€‘ÐºÐ¾Ñ€Ð¿ÑƒÑÑƒ Ð´Ð»Ñ ÑÑ‚Ð¾Ð¹ Ð³Ñ€ÑƒÐ¿Ð¿Ñ‹ Ð² Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼ Ð´ÐµÐ¼Ð¾.</div>`;

            const md = [
              `<h3>${escapeHtml(group.name || "Group")}</h3>`,
              tags.length ? `<div class="sfTagRow">${tags.join("")}</div>` : "",
              group.description ? `<div class="sfDetailsBody" style="margin-top:10px;"><b>ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ:</b> ${escapeHtml(group.description)}</div>` : "",
              `<div class="sfDetailsBody" style="margin-top:12px;"><b>Ð’Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ñ‹ Ð² Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ°Ñ…:</b></div>`,
              variantsTable,
              docsTable,
            ]
              .filter(Boolean)
              .join("\n");

            setSegmentModal({ open: true, title, md });
            return;
          }
          if (action === "open_segment_group_detail") {
            const groupId = String(payload || "").trim();
            if (!groupId) return;
            const analyzers = safeGetDocAnalyzers();
            const groups = buildT01SegmentGroups(analyzers);
            const group = (Array.isArray(groups) ? groups : []).find((g) => String(g && g.id) === groupId);
            if (!group) return;

            const title = group.name ? `Ð“Ñ€ÑƒÐ¿Ð¿Ð° ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð² â€” ${group.name}` : "Ð“Ñ€ÑƒÐ¿Ð¿Ð° ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð²";

            const tag = (t) => `<span class="sfTag">${escapeHtml(t)}</span>`;
            const tags = []
              .concat([tag(`Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ñ‹: ${(group.variants || []).length}`)])
              .concat([tag(`docs: ${group.docsCount || 0}`), tag(`Î£ ÑƒÐ¿.: ${group.totalMentions || 0}`)])
              .concat([tag(`trust: ${group.trust || "B"} (proxy)`)]);

            const findFirstHitPageForAny = (doc, itemKeys) => {
              const keys = Array.isArray(itemKeys) ? itemKeys.map((k) => String(k || "")) : [];
              const pages = Array.isArray(doc && doc.pages) ? doc.pages : [];
              for (const p of pages) {
                const hits = p && p.hits;
                if (!hits) continue;
                for (const k of keys) {
                  if (hits[k] && hits[k].count) return Number(p.page) || 1;
                }
              }
              return 1;
            };

            const variantRows = (group.variants || [])
              .slice()
              .sort((a, b) => (b.totalMentions || 0) - (a.totalMentions || 0))
              .map((v) => {
                const docs = (v.docs || [])
                  .slice()
                  .sort((a, b) => (b.mentions || 0) - (a.mentions || 0))
                  .map((d) => {
                    const label = String(d.title || d.key || "");
                    const short = label.length > 20 ? label.slice(0, 20) + "â€¦" : label;
                    return tag(`${short} (${Number(d.mentions) || 0})`);
                  })
                  .join(" ");
                const name = (v.code ? `${String(v.code)} ` : "") + String(v.label || v.key || "");
                return `
                  <tr>
                    <td><b>${escapeHtml(name)}</b></td>
                    <td>${docs || "â€”"}</td>
                    <td>${escapeHtml(String(v.totalMentions || 0))}</td>
                  </tr>
                `;
              })
              .join("");

            const variantsTable = `
              <table class="sfTable" style="margin-top:10px;">
                <thead>
                  <tr>
                    <th>Ð’Ð°Ñ€Ð¸Ð°Ð½Ñ‚ Ñ„Ð¾Ñ€Ð¼ÑƒÐ»Ð¸Ñ€Ð¾Ð²ÐºÐ¸</th>
                    <th>Ð˜ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¸</th>
                    <th>Î£ ÑƒÐ¿.</th>
                  </tr>
                </thead>
                <tbody>${variantRows || `<tr><td colspan="3" class="help">ÐÐµÑ‚ Ð²Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ð¾Ð².</td></tr>`}</tbody>
              </table>
            `;

            const stats = group.stats || computeSegmentGroupStatsAcrossDocs((group.variants || []).map((v) => v.key), analyzers);
            const docsRows = (stats.docs || [])
              .map((d) => {
                const doc = analyzers && analyzers[d.key];
                const page = doc ? findFirstHitPageForAny(doc, (group.variants || []).map((v) => v.key)) : 1;
                const url = d.pdfUrl ? `${String(d.pdfUrl)}#page=${page}` : "";
                const link = url
                  ? `<a class="sfInlineLink" href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">PDF â€¢ ÑÑ‚Ñ€. ${page}</a>`
                  : "â€”";
                return `
                  <tr>
                    <td><b>${escapeHtml(d.title || d.key)}</b></td>
                    <td>${escapeHtml(String(d.mentions || 0))}</td>
                    <td>${escapeHtml(String(d.pages || "â€”"))}</td>
                    <td>${tag(`trust: ${d.trust || "B"}`)}</td>
                    <td>${link}</td>
                  </tr>
                `;
              })
              .join("");

            const docsTable = stats.docsCount
              ? `
                <div class="sfDetailsBody" style="margin-top:12px;"><b>Ð”Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ñ‹:</b></div>
                <table class="sfTable" style="margin-top:10px;">
                  <thead>
                    <tr>
                      <th>Ð”Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚</th>
                      <th>Ð£Ð¿.</th>
                      <th>Ð¡Ñ‚Ñ€.</th>
                      <th>Trust</th>
                      <th>Ð¡ÑÑ‹Ð»ÐºÐ°</th>
                    </tr>
                  </thead>
                  <tbody>${docsRows}</tbody>
                </table>
                <div class="chartNote">Trust/evidence Ð·Ð´ÐµÑÑŒ â€” <b>proxy</b> (Ð´ÐµÐ¼Ð¾): Ð°Ð³Ñ€ÐµÐ³Ð¸Ñ€ÑƒÐµÐ¼ â€œÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾â€ Ð¿Ð¾ Ñ‚Ð¸Ð¿Ð°Ð¼/Ð²ÐµÑÑƒ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð², Ð½Ðµ ÐºÐ°Ðº Ñ„Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ ÑÐºÐ¾Ñ€Ð¸Ð½Ð³.</div>
              `
              : `<div class="chartNote" style="margin-top:10px;">ÐÐµÑ‚ Ð¿Ñ€Ð¸Ð²ÑÐ·ÐºÐ¸ Ðº PDFâ€‘ÐºÐ¾Ñ€Ð¿ÑƒÑÑƒ Ð´Ð»Ñ ÑÑ‚Ð¾Ð¹ Ð³Ñ€ÑƒÐ¿Ð¿Ñ‹ Ð² Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼ Ð´ÐµÐ¼Ð¾.</div>`;

            const md = [
              `<h3>${escapeHtml(group.name || "Ð“Ñ€ÑƒÐ¿Ð¿Ð° ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð²")}</h3>`,
              tags.length ? `<div class="sfTagRow">${tags.join("")}</div>` : "",
              group.description ? `<div class="sfDetailsBody" style="margin-top:10px;"><b>ÐžÐ¿Ð¸ÑÐ°Ð½Ð¸Ðµ:</b> ${escapeHtml(group.description)}</div>` : "",
              `<div class="sfDetailsBody" style="margin-top:12px;"><b>Ð’Ð°Ñ€Ð¸Ð°Ð½Ñ‚Ñ‹ Ð² Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ°Ñ…:</b></div>`,
              variantsTable,
              docsTable,
            ]
              .filter(Boolean)
              .join("\n");

            setSegmentModal({ open: true, title, md });
            return;
          }
          if (action === "open_need_detail") {
            const raw = ((el && el.getAttribute && el.getAttribute("data-sf-payload")) || String(payload || "")).trim();
            const m = raw.match(/N\d{2}/);
            const needCode = m ? m[0] : raw;

            const scope = (el && el.closest && el.closest(".md")) || document;
            const model = scope && scope.__sfT02Model;
            const segs = model && Array.isArray(model.segments) ? model.segments : [];
            const needs = model && Array.isArray(model.needs) ? model.needs : [];
            const scoreFn = model && typeof model.importanceScore === "function" ? model.importanceScore : () => 0;
            const classFn =
              model && typeof model.importanceClass === "function"
                ? model.importanceClass
                : (s) => {
                    const x = Number(s) || 0;
                    if (x >= 80) return "Core";
                    if (x >= 60) return "Secondary";
                    if (x >= 40) return "Niche";
                    return "Irrelevant";
                  };

            const need = needs.find((n) => String(n && n.code) === String(needCode)) || null;
            if (!need || !segs.length) {
              const md = `<div class="help">ÐÐµÑ‚ Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¿Ð¾ Ð¿Ð¾Ñ‚Ñ€ÐµÐ±Ð½Ð¾ÑÑ‚Ð¸ (Ð½ÑƒÐ¶ÐµÐ½ Ñ€Ð°ÑÑ‡Ñ‘Ñ‚ SegmentÃ—Need).</div>`;
              setSegmentModal({ open: true, title: "ÐŸÐ¾Ñ‚Ñ€ÐµÐ±Ð½Ð¾ÑÑ‚ÑŒ", md });
              return;
            }

            const scores = segs
              .map((seg) => {
                const score = Number(scoreFn(seg, need)) || 0;
                return { seg, score, cls: classFn(score) };
              })
              .slice()
              .sort((a, b) => (b.score || 0) - (a.score || 0));

            const segCount = segs.length || 1;
            const sum = scores.reduce((acc, x) => acc + (x.score || 0), 0);
            const avg = segCount ? sum / segCount : 0;
            const coreCount = scores.filter((x) => (x.score || 0) >= 80).length;
            const secondaryPlusCount = scores.filter((x) => (x.score || 0) >= 60).length;
            const coverage = segCount ? secondaryPlusCount / segCount : 0;
            const max = scores.length ? scores[0].score : 0;

            const position = (() => {
              if (coverage >= 0.75 && avg >= 70) return { label: "ÐžÐ±Ñ‰Ð°Ñ (core)", hint: "Ð²Ð°Ð¶Ð½Ð° Ð±Ð¾Ð»ÑŒÑˆÐ¸Ð½ÑÑ‚Ð²Ñƒ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð² â†’ Ð±Ð°Ð·Ð¾Ð²Ñ‹Ð¹ proofâ€‘ÑÐ»Ð¾Ð¹ Ð¸ friction fixes." };
              if (coverage >= 0.75) return { label: "ÐžÐ±Ñ‰Ð°Ñ", hint: "Ð²ÑÑ‚Ñ€ÐµÑ‡Ð°ÐµÑ‚ÑÑ Ñƒ Ð¼Ð½Ð¾Ð³Ð¸Ñ… ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð² â†’ ÐºÐ°Ð½Ð´Ð¸Ð´Ð°Ñ‚ Ð² â€œÑƒÐ½Ð¸Ð²ÐµÑ€ÑÐ°Ð»ÑŒÐ½Ð¾Ðµâ€ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ." };
              if (coverage <= 0.3 && max >= 80) return { label: "Ð¡Ð¿ÐµÑ†Ð¸Ñ„Ð¸Ñ‡Ð½Ð°Ñ", hint: "core Ñƒ 1â€“2 ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð² â†’ Ñ…Ð¾Ñ€Ð¾ÑˆÐ° Ð´Ð»Ñ Ñ‚Ð°Ñ€Ð³ÐµÑ‚â€‘ÐºÐ°Ð¼Ð¿Ð°Ð½Ð¸Ð¹/Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð»Ð¸Ð·Ð°Ñ†Ð¸Ð¸." };
              if (coverage <= 0.3) return { label: "ÐÐ¸ÑˆÐµÐ²Ð°Ñ", hint: "Ð¿Ð¾ÐºÐ° Ð½Ð¸Ð·ÐºÐ¸Ð¹ Ð¿Ñ€Ð¸Ð¾Ñ€Ð¸Ñ‚ÐµÑ‚; Ð¼Ð¾Ð½Ð¸Ñ‚Ð¾Ñ€Ð¸Ð¼ Ð¸ ÑƒÑ‚Ð¾Ñ‡Ð½ÑÐµÐ¼ Ð¿Ñ€Ð¸ Ð¿Ð¾ÑÐ²Ð»ÐµÐ½Ð¸Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ñ…." };
              return { label: "Ð¡ÐµÐ³Ð¼ÐµÐ½Ñ‚Ð½Ð°Ñ", hint: "Ð²Ð°Ð¶Ð½Ð° Ñ‡Ð°ÑÑ‚Ð¸ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð¾Ð² â†’ Ð¿Ð¾Ð¼Ð¾Ð³Ð°ÐµÑ‚ Ð´Ð¸Ñ„Ñ„ÐµÑ€ÐµÐ½Ñ†Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ messaging." };
            })();

            const tag = (t) => `<span class="sfTag">${escapeHtml(t)}</span>`;
            const tags = []
              .concat([tag(`avg: ${Math.round(avg)}`)])
              .concat([tag(`coverage: ${secondaryPlusCount}/${segCount} (${Math.round(100 * coverage)}%)`)])
              .concat([tag(`core: ${coreCount}`)])
              .concat([need.group && need.group.name ? tag(`group: ${need.group.name}`) : null])
              .filter(Boolean);

            const rows = scores
              .map((x) => {
                const seg = x.seg || {};
                const segCode = escapeHtml(String(seg.code || ""));
                const segName = escapeHtml(String(seg.name || ""));
                const score = escapeHtml(String(Math.round(x.score || 0)));
                const cls = escapeHtml(String(x.cls || ""));
                return `<tr><td><b>${segCode}</b> ${segName}</td><td>${score}</td><td><span class="sfTag">${cls}</span></td></tr>`;
              })
              .join("");

            const md = [
              `<h3>${escapeHtml(String(need.code || ""))} â€” ${escapeHtml(String(need.name || "ÐŸÐ¾Ñ‚Ñ€ÐµÐ±Ð½Ð¾ÑÑ‚ÑŒ"))}</h3>`,
              tags.length ? `<div class="sfTagRow">${tags.join("")}</div>` : "",
              need.meaning ? `<div class="sfDetailsBody" style="margin-top:10px;"><b>Meaning:</b> ${escapeHtml(String(need.meaning))}</div>` : "",
              `<div class="sfDetailsBody" style="margin-top:10px;"><b>ÐŸÐ¾Ð·Ð¸Ñ†Ð¸Ñ Ð² Ñ€Ñ‹Ð½ÐºÐµ:</b> ${escapeHtml(position.label)} â€” ${escapeHtml(position.hint)}</div>`,
              `<div style="margin-top:14px;font-weight:950;">Ð’Ð°Ð¶Ð½Ð¾ÑÑ‚ÑŒ Ð¿Ð¾ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð°Ð¼</div>`,
              `<div class="sfScrollY" style="max-height:320px;">
                <table class="sfTable">
                  <thead><tr><th>Ð¡ÐµÐ³Ð¼ÐµÐ½Ñ‚</th><th>Importance</th><th>Class</th></tr></thead>
                  <tbody>${rows}</tbody>
                </table>
              </div>`,
              `<div class="chartNote" style="margin-top:10px;">Importance score (0â€“100) Ð¸ ÐºÐ»Ð°ÑÑÑ‹ Core/Secondary/Niche/Irrelevant â€” Ð´ÐµÐ¼Ð¾â€‘Ð¼Ð¾Ð´ÐµÐ»ÑŒ Ð¿Ð¾ Ð¼ÐµÑ‚Ð¾Ð´Ð¾Ð»Ð¾Ð³Ð¸Ð¸ analysis_segment_need_importance.</div>`,
            ]
              .filter(Boolean)
              .join("\\n");

            setSegmentModal({ open: true, title: `ÐŸÐ¾Ñ‚Ñ€ÐµÐ±Ð½Ð¾ÑÑ‚ÑŒ â€” ${need.name || need.code || ""}`, md });
            return;
          }
          if (action === "open_segment_detail") {
            const segName = (el && el.getAttribute && el.getAttribute("data-sf-name")) || String(payload || "");
            const segMentions = (el && el.getAttribute && el.getAttribute("data-sf-mentions")) || "";
            const segContext = (el && el.getAttribute && el.getAttribute("data-sf-context")) || "";
            const segEvidence = (el && el.getAttribute && el.getAttribute("data-sf-evidence")) || "";
            const segId = (el && el.getAttribute && el.getAttribute("data-sf-payload")) || String(payload || "");

            const title = segName ? `Ð¡ÐµÐ³Ð¼ÐµÐ½Ñ‚ â€” ${segName}` : "Ð¡ÐµÐ³Ð¼ÐµÐ½Ñ‚";
            const analyzers = safeGetDocAnalyzers();
            const stats = computeSegmentStatsAcrossDocs(segId, analyzers);

            const segDocKey = (el && el.getAttribute && el.getAttribute("data-sf-doc-key")) || "";
            const selectedDoc = segDocKey && analyzers && analyzers[segDocKey] ? analyzers[segDocKey] : null;

            const fallbackDocsCount = Number((el && el.getAttribute && el.getAttribute("data-sf-docs-count")) || 0) || 0;
            const fallbackMentionsTotal = Number((el && el.getAttribute && el.getAttribute("data-sf-mentions-total")) || 0) || 0;
            const fallbackTrust = String((el && el.getAttribute && el.getAttribute("data-sf-trust")) || "");

            const docsCount = stats.docsCount || fallbackDocsCount;
            const mentionsTotal = stats.docsCount ? stats.totalMentions : fallbackMentionsTotal;
            const trust = stats.docsCount ? stats.trust : fallbackTrust;

            const tag = (t) => `<span class="sfTag">${escapeHtml(t)}</span>`;
            const tags = []
              .concat(selectedDoc ? [tag(`PDF: ${selectedDoc.title || segDocKey}`)] : [])
              .concat(segMentions ? [tag(`Ð² PDF: ${segMentions} ÑƒÐ¿.`)] : [])
              .concat(docsCount ? [tag(`docs: ${docsCount}`), tag(`Î£ ÑƒÐ¿.: ${mentionsTotal}`)] : [])
              .concat(trust ? [tag(`trust: ${trust} (proxy)`)] : []);

            const findFirstHitPage = (doc, itemKey) => {
              const pages = Array.isArray(doc && doc.pages) ? doc.pages : [];
              const k = String(itemKey || "");
              for (const p of pages) {
                const hits = p && p.hits;
                if (hits && hits[k] && hits[k].count) return Number(p.page) || 1;
              }
              return 1;
            };

            const docsTable = (() => {
              if (!stats.docsCount) return "";
              const rows = stats.docs
                .map((d) => {
                  const doc = analyzers && analyzers[d.key];
                  const page = doc ? findFirstHitPage(doc, segId) : 1;
                  const url = d.pdfUrl ? `${String(d.pdfUrl)}#page=${page}` : "";
                  const link = url
                    ? `<a class="sfInlineLink" href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">PDF â€¢ ÑÑ‚Ñ€. ${page}</a>`
                    : "â€”";
                  return `
                    <tr>
                      <td><b>${escapeHtml(d.title || d.key)}</b></td>
                      <td>${escapeHtml(String(d.mentions || 0))}</td>
                      <td>${escapeHtml(String(d.pages || "â€”"))}</td>
                      <td>${tag(`trust: ${d.trust || "B"}`)}</td>
                      <td>${link}</td>
                    </tr>
                  `;
                })
                .join("");

              return `
                <div style="margin-top:14px;font-weight:950;">Ð“Ð´Ðµ Ð²ÑÑ‚Ñ€ÐµÑ‡Ð°ÐµÑ‚ÑÑ (PDFâ€‘ÐºÐ¾Ñ€Ð¿ÑƒÑ)</div>
                <table class="sfTable">
                  <thead>
                    <tr><th>Ð”Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚</th><th>Ð£Ð¿Ð¾Ð¼Ð¸Ð½.</th><th>Ð¡Ñ‚Ñ€.</th><th>Trust</th><th>Ð¡ÑÑ‹Ð»ÐºÐ°</th></tr>
                  </thead>
                  <tbody>${rows}</tbody>
                </table>
                <div class="chartNote">Trust/evidence Ð·Ð´ÐµÑÑŒ â€” <b>proxy</b> (Ð´ÐµÐ¼Ð¾): Ð°Ð³Ñ€ÐµÐ³Ð¸Ñ€ÑƒÐµÐ¼ â€œÐºÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾â€ Ð¿Ð¾ Ñ‚Ð¸Ð¿Ð°Ð¼/Ð²ÐµÑÑƒ Ð´Ð¾ÐºÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð², Ð½Ðµ ÐºÐ°Ðº Ñ„Ð¸Ð½Ð°Ð»ÑŒÐ½Ñ‹Ð¹ ÑÐºÐ¾Ñ€Ð¸Ð½Ð³.</div>
              `;
            })();

            const segNum = (() => {
            const m = String(segId || "").match(/seg_(\d{2})/);
              if (!m) return null;
              const n = Number(m[1]);
              return Number.isFinite(n) ? n : null;
            })();
            const shotUrl = segNum ? `Example%20researches/segment_shots/seg_${String(segNum).padStart(2, "0")}.png` : "";

            const md = [
              `<h3>${escapeHtml(segName || "Ð¡ÐµÐ³Ð¼ÐµÐ½Ñ‚")}</h3>`,
              tags.length ? `<div class="sfTagRow">${tags.join("")}</div>` : "",
              segEvidence ? `<div class="sfDetailsBody" style="margin-top:10px;"><b>Evidence:</b> ${escapeHtml(segEvidence)}</div>` : "",
              segContext ? `<div class="sfDetailsBody" style="margin-top:10px;"><b>ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ (Ð¸Ð· PDF):</b> ${escapeHtml(segContext)}</div>` : "",
              shotUrl && !stats.docsCount ? `<img class="sfEvidenceImg" src="${escapeHtml(shotUrl)}" alt="${escapeHtml(segName || "Segment")} evidence screenshot" />` : "",
              !stats.docsCount ? `<div class="chartNote">ÐÐµÑ‚ Ð¿Ñ€Ð¸Ð²ÑÐ·ÐºÐ¸ Ðº PDFâ€‘ÐºÐ¾Ñ€Ð¿ÑƒÑÑƒ Ð´Ð»Ñ ÑÑ‚Ð¾Ð³Ð¾ ÑÐµÐ³Ð¼ÐµÐ½Ñ‚Ð° Ð² Ñ‚ÐµÐºÑƒÑ‰ÐµÐ¼ Ð´ÐµÐ¼Ð¾.</div>` : "",
              docsTable,
            ]
              .filter(Boolean)
              .join("\\n");

            setSegmentModal({ open: true, title, md });
            return;
          }
          if (action === "open_creative_example") {
            const modalTitle = (el && el.getAttribute && el.getAttribute("data-sf-title")) || "ÐŸÑ€Ð¸Ð¼ÐµÑ€ ÐºÑ€ÐµÐ°Ñ‚Ð¸Ð²Ð°";
            const kicker = (el && el.getAttribute && el.getAttribute("data-sf-kicker")) || "";
            const headline = (el && el.getAttribute && el.getAttribute("data-sf-headline")) || "";
            const body = (el && el.getAttribute && el.getAttribute("data-sf-body")) || "";
            const cta = (el && el.getAttribute && el.getAttribute("data-sf-cta")) || "";
            const img = (el && el.getAttribute && el.getAttribute("data-sf-img")) || "";
            const imgAlt = (el && el.getAttribute && el.getAttribute("data-sf-img-alt")) || "";
            const url = (el && el.getAttribute && el.getAttribute("data-sf-url")) || "";
            const need = (el && el.getAttribute && el.getAttribute("data-sf-need")) || "";
            const segment = (el && el.getAttribute && el.getAttribute("data-sf-segment")) || "";
            const functionsRaw = (el && el.getAttribute && el.getAttribute("data-sf-functions")) || "";
            const functionsList = functionsRaw
              .split("|")
              .map((s) => s.trim())
              .filter(Boolean);

            const tags = []
              .concat(need ? [`<span class="sfTag">need: ${escapeHtml(need)}</span>`] : [])
              .concat(segment ? [`<span class="sfTag">segment: ${escapeHtml(segment)}</span>`] : []);
            const functionsHtml = functionsList.length ? `<ul>${functionsList.map((f) => `<li>${escapeHtml(f)}</li>`).join("")}</ul>` : "";

            const imgHtml = img ? `<img class="sfEvidenceImg" src="${escapeHtml(img)}" alt="${escapeHtml(imgAlt || modalTitle)}" />` : "";
            const mockHtml =
              kicker || headline || body || cta
                ? [
                    `<div class="sfCreativeMock">`,
                    kicker ? `<div class="sfCreativeKicker">${escapeHtml(kicker)}</div>` : "",
                    headline ? `<div class="sfCreativeHeadline">${escapeHtml(headline)}</div>` : "",
                    body ? `<div class="sfCreativeBody">${escapeHtml(body)}</div>` : "",
                    cta ? `<div class="sfCreativeCta">${escapeHtml(cta)}</div>` : "",
                    `</div>`,
                  ]
                    .filter(Boolean)
                    .join("\n")
                : "";

            const urlHtml = url
              ? `<div class="sfDetailsBody" style="margin-top:10px;"><a class="sfInlineLink" href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸Ðº</a></div>`
              : "";

            const md = [
              tags.length ? `<div class="sfTagRow">${tags.join("")}</div>` : "",
              imgHtml,
              mockHtml,
              functionsHtml ? `<div class="sfDetailsBody" style="margin-top:10px;"><b>Ð¤ÑƒÐ½ÐºÑ†Ð¸Ð¸ (performance):</b>${functionsHtml}</div>` : "",
              urlHtml,
            ]
              .filter(Boolean)
              .join("\n");

            setCreativeModal({ open: true, title: modalTitle, md });
            return;
          }
        };

        const reportEl = reportView
          ? React.createElement(MarkdownViewer, { md: reportView, onAction: onReportAction })
          : React.createElement("div", { className: "empty" }, "ÐÐµÑ‚ ÑˆÐ°Ð±Ð»Ð¾Ð½Ð° Ð¾Ñ‚Ñ‡Ñ‘Ñ‚Ð°.");
        const telegramEl = telegramView
          ? React.createElement(
              React.Fragment,
              null,
              React.createElement(
                "div",
                { style: { display: "flex", justifyContent: "space-between", gap: 10, flexWrap: "wrap", alignItems: "center" } },
                React.createElement("div", { className: "help" }, "Ð¢ÐµÐºÑÑ‚ Ð´Ð»Ñ Telegram. ÐœÐ¾Ð¶Ð½Ð¾ ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÑÑ‚ÑŒ Ð²Ð¼ÐµÑÑ‚Ðµ Ñ Ð°Ñ€Ñ‚ÐµÑ„Ð°ÐºÑ‚Ð¾Ð¼."),
                React.createElement("button", { className: "btn primary", onClick: () => onCopyTelegram(telegramView) }, "Ð¡ÐºÐ¾Ð¿Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ")
              ),
              React.createElement("div", { className: "doc" }, React.createElement(MarkdownViewer, { md: telegramView }))
            )
          : React.createElement("div", { className: "empty" }, "ÐÐµÑ‚ Ñ‚ÐµÐºÑÑ‚Ð°.");

        const sourcesModalEl =
          touch
            ? React.createElement(SourcesRegistryModal, {
                open: sourcesModal.open,
                title: "Ð ÐµÐµÑÑ‚Ñ€ Ð¸ÑÑ‚Ð¾Ñ‡Ð½Ð¸ÐºÐ¾Ð²",
                sources: T01_SOURCES_DEMO,
                mix: T01_SOURCE_MIX,
                repoUrl: T01_SOURCE_REPO_URL_DEMO,
                initialTypeKey: sourcesModal.typeKey,
                onClose: () => setSourcesModal({ open: false, typeKey: "" }),
              })
            : null;

        const docAnalyzerModalEl = React.createElement(DocAnalyzerModal, {
          open: docAnalyzerModal.open,
          docKey: docAnalyzerModal.key,
          tab: docAnalyzerModal.tab,
          onChangeTab: (tab) => setDocAnalyzerModal((prev) => ({ ...prev, tab: String(tab || "") })),
          onClose: () => setDocAnalyzerModal((prev) => ({ ...prev, open: false })),
        });

        const segmentModalEl = React.createElement(DocModal, {
          open: segmentModal.open,
          title: segmentModal.title,
          md: segmentModal.md,
          onClose: () => setSegmentModal({ open: false, title: "", md: "" }),
        });

        const creativeModalEl = React.createElement(DocModal, {
          open: creativeModal.open,
          title: creativeModal.title,
          md: creativeModal.md,
          onClose: () => setCreativeModal({ open: false, title: "", md: "" }),
        });

        return React.createElement(
          React.Fragment,
          null,
          React.createElement(
            "div",
            { className: "panelHeader", style: { borderBottom: "none", background: "transparent", padding: 0 } },
            React.createElement(
              "div",
              null,
              React.createElement("div", { style: { fontWeight: 950, fontSize: 16 } }, `${touch.id} â€” ${touch.title}`),
              null
            ),
            React.createElement(
              "div",
              { style: { display: "flex", gap: 10, flexWrap: "wrap", justifyContent: "flex-end" } },
              React.createElement("button", { className: "btn" + (tab === "report" ? " activeTab" : ""), onClick: () => setTab("report") }, "ÐÑ€Ñ‚ÐµÑ„Ð°ÐºÑ‚"),
              React.createElement("button", { className: "btn" + (tab === "telegram" ? " activeTab" : ""), onClick: () => setTab("telegram") }, "Ð¡Ð¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ")
            )
          ),
          tab === "telegram"
            ? telegramEl
            : React.createElement("div", { className: "doc" + (expertMode ? " expertMode" : "") }, reportEl)
          ,
          sourcesModalEl,
          docAnalyzerModalEl,
          segmentModalEl,
          creativeModalEl
        );
      }

      function PrintApp() {
        const data = useMemo(() => safeGetData(), []);
        const bundle = useMemo(() => safeGetBundle(), []);

        const params = useMemo(() => new URLSearchParams(window.location.search), []);
        const onlyId = params.get("touch");
        const isDemo = params.get("demo") === "1";
        const autoPrint = params.get("auto_print") === "1";

        const [storedLead] = useLocalStorageObject("segflow_sales_nurture_lead_v1", data.lead_placeholders || {});
        const demoLead = data.demo_lead || {
          company: "FitHome",
          product: "ÐŸÐ¾Ð´Ð¿Ð¸ÑÐ¾Ñ‡Ð½Ð¾Ðµ Ñ„Ð¸Ñ‚Ð½ÐµÑâ€‘Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ: Ð¿Ð¾Ñ…ÑƒÐ´ÐµÐ½Ð¸Ðµ Ð´Ð¾Ð¼Ð° Ð·Ð° 8 Ð½ÐµÐ´ÐµÐ»ÑŒ",
          geo: "Ð Ð¾ÑÑÐ¸Ñ",
          industry: "B2C Fitness (subscription)",
          competitors_shortlist: ["Nike Training Club", "Freeletics", "FitOn", "7 Minute Workout", "Adidas Training"].join("\n"),
        };
        const lead = isDemo ? demoLead : storedLead;

        useEffect(() => {
          if (!autoPrint) return;
          const t = window.setTimeout(() => {
            try {
              window.print();
            } catch (_) {}
          }, 250);
          return () => window.clearTimeout(t);
        }, [autoPrint]);

        const touches = (data.touches || []).filter((t) => !onlyId || t.id === onlyId);
        const generatedAt = useMemo(() => new Date().toLocaleString("ru-RU"), []);

        return React.createElement(
          "div",
          { className: "printRoot" },
          React.createElement(
            "div",
            { className: "printTopbar noPrint" },
            React.createElement(
              "div",
              { style: { display: "flex", gap: 12, alignItems: "center" } },
              React.createElement("img", { src: "../../logo_sgtbl.jpg", alt: "Segmentable", style: { width: 34, height: 34, borderRadius: 8 } }),
              React.createElement(
                "div",
                null,
                React.createElement("div", { className: "printTitle" }, "SegFlow â€” Sales Nurture (Ð¿Ð°ÐºÐµÑ‚)"),
                React.createElement("div", { className: "printMeta" }, `Ð¡Ð³ÐµÐ½ÐµÑ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾: ${generatedAt}. Ð¡Ð¾Ð²ÐµÑ‚Ñ‹: Â«ÐŸÐµÑ‡Ð°Ñ‚ÑŒÂ» â†’ Â«Ð¡Ð¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ ÐºÐ°Ðº PDFÂ».`)
              )
            ),
            React.createElement("button", { className: "btn primary", onClick: () => window.print() }, "ÐŸÐµÑ‡Ð°Ñ‚ÑŒ / PDF")
          ),
          React.createElement(
            "div",
            { className: "printBody" },
            React.createElement(
              "div",
              { className: "printCover" },
              React.createElement("h1", { className: "printCoverTitle" }, isDemo ? "Nurtureâ€‘Ð¿Ð°ÐºÐµÑ‚ (DEMO)" : "Nurtureâ€‘Ð¿Ð°ÐºÐµÑ‚ (teaser)"),
              React.createElement("div", { className: "printCoverSub" }, `ÐšÐ¾Ð¼Ð¿Ð°Ð½Ð¸Ñ: ${lead.company || ""} â€¢ ÐŸÑ€Ð¾Ð´ÑƒÐºÑ‚: ${lead.product || ""} â€¢ Ð“ÐµÐ¾: ${lead.geo || ""} â€¢ Ð˜Ð½Ð´ÑƒÑÑ‚Ñ€Ð¸Ñ: ${lead.industry || ""}`)
            ),
            touches.map((touch) => {
              const reportPath = isDemo && touch.demo_report_path ? touch.demo_report_path : touch.report_path;
              const telegramPath = isDemo && touch.demo_telegram_path ? touch.demo_telegram_path : touch.telegram_path;
              const reportRaw = bundle[reportPath] || "";
              const telegramRaw = bundle[telegramPath] || "";
              const report = applyLeadPlaceholders(reportRaw, lead);
              const telegram = applyLeadPlaceholders(telegramRaw, lead);
              return React.createElement(
                "section",
                { key: touch.id, className: "printTouch" },
                React.createElement("div", { className: "printSectionTitle" }, `${touch.id} â€” ${touch.title} (Ð”ÐµÐ½ÑŒ ${touch.day})`),
                React.createElement("div", { className: "doc" }, React.createElement(MarkdownViewer, { md: report })),
                React.createElement("div", { className: "printSectionTitle" }, "Telegram"),
                React.createElement("div", { className: "doc" }, React.createElement(MarkdownViewer, { md: telegram }))
              );
            })
          )
        );
      }

      function App() {
        const data = useMemo(() => safeGetData(), []);
        const bundle = useMemo(() => safeGetBundle(), []);
        const bundleBuild = useMemo(() => String(window.SEGFLOW_SALES_NURTURE_BUNDLE_BUILD || ""), []);

        const touches = data.touches || [];
        const [selectedId, setSelectedId] = useState(() => (touches[0] ? touches[0].id : null));
        const [isLeadModalOpen, setIsLeadModalOpen] = useState(false);
        const [isReadmeOpen, setIsReadmeOpen] = useState(false);
        const [isHeaderCollapsed, setIsHeaderCollapsed] = useLocalStorageBool("segflow_sales_nurture_header_collapsed_v1", false);

        const demoLead = useMemo(() => data.demo_lead || null, [data]);
        const [lead, setLead] = useLocalStorageObject("segflow_sales_nurture_lead_v1", demoLead || data.lead_placeholders || {});
        const [isDemoMode, setIsDemoMode] = useLocalStorageBool("segflow_sales_nurture_demo_mode_v1", true);
        const [isExpertMode, setIsExpertMode] = useLocalStorageBool("segflow_sales_nurture_expert_mode_v1", false);
        const [isMagazineMode, setIsMagazineMode] = useLocalStorageBool("segflow_sales_nurture_magazine_mode_v1", false);

        const selected = useMemo(() => touches.find((t) => t.id === selectedId) || null, [touches, selectedId]);
        const readmeMd = useMemo(() => bundle["README.md"] || "", [bundle]);
        const briefMd = useMemo(() => bundle["lead_brief_template.md"] || "", [bundle]);

        const flowPalette = ["#1a73e8", "#34a853", "#f9ab00", "#9334e6", "#ea4335"];
        const briefFlow = {
          id: "0",
          day: 0,
          title: "ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ (Ð¿Ð¾ÑÐ»Ðµ Ð²ÑÑ‚Ñ€ÐµÑ‡Ð¸)",
          goal: "Ð¢ÐµÐ³Ð¸: company / product / geo / ÐºÐ¾Ð½ÐºÑƒÑ€ÐµÐ½Ñ‚Ñ‹. Ð­Ñ‚Ð¾ Ð±Ð°Ð·Ð° Ð´Ð»Ñ Ð²ÑÐµÑ… ÐºÐ°ÑÐ°Ð½Ð¸Ð¹.",
          kind: "brief",
          accent: "#0ea5e9",
        };

        const flowItems = [briefFlow, ...touches.map((t, i) => ({ ...t, kind: "touch", accent: flowPalette[i % flowPalette.length] }))];

        const flowNodes = [];
        for (let i = 0; i < flowItems.length; i += 1) {
          const t = flowItems[i];
          const isActive = t.kind === "touch" && t.id === selectedId;
          const onClick = () => {
            if (t.kind === "brief") {
              setIsLeadModalOpen(true);
              return;
            }
            setSelectedId(t.id);
          };

          flowNodes.push(
            React.createElement(
              "button",
              { key: "flow_" + t.id, className: "flowNode" + (isActive ? " active" : ""), onClick, title: t.title, style: { "--flowAccent": t.accent } },
              React.createElement("div", { className: "flowNodeId" }, t.kind === "brief" ? "T00" : t.id),
              React.createElement("div", { className: "flowNodeTitle" }, t.title),
              React.createElement("div", { className: "flowNodeGoal" }, t.goal || ""),
              React.createElement("div", { className: "flowNodeDay" }, "Ð”ÐµÐ½ÑŒ " + String(t.day))
            )
          );

          if (i < flowItems.length - 1) {
            const next = flowItems[i + 1];
            const delayDays = Math.max(0, Number(next.day || 0) - Number(t.day || 0));
            flowNodes.push(
              React.createElement(
                "div",
                { key: "flow_link_" + t.id, className: "flowLink", title: `ÐŸÐ°ÑƒÐ·Ð°: ${delayDays} Ð´Ð½.`, style: { "--flowFrom": t.accent, "--flowTo": next.accent } },
                React.createElement("div", { className: "flowLinkLabel" }, `+${delayDays}Ð´`)
              )
            );
          }
        }

        const touchFlow = React.createElement(
          React.Fragment,
          null,
          React.createElement("div", { className: "flowHint" }, "Ð¢Ð°Ð¹Ð¼Ð»Ð°Ð¹Ð½ ÐºÐ°ÑÐ°Ð½Ð¸Ð¹: ÐºÐ»Ð¸Ðº Ð¿Ð¾ ÑÑ‚Ð°Ð¿Ñƒ â†’ Ð°Ñ€Ñ‚ÐµÑ„Ð°ÐºÑ‚ + Ñ‚ÐµÐºÑÑ‚. ÐÐ° ÑÑ‚Ñ€ÐµÐ»ÐºÐ°Ñ… â€” Ð¿Ð°ÑƒÐ·Ð° Ð¼ÐµÐ¶Ð´Ñƒ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ°Ð¼Ð¸."),
          React.createElement("div", { className: "flowBar" }, flowNodes)
        );

        const copyTelegram = async (text) => {
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(String(text || ""));
              return;
            }
          } catch (_) {}
          // Fallback
          try {
            const ta = document.createElement("textarea");
            ta.value = String(text || "");
            ta.style.position = "fixed";
            ta.style.left = "-9999px";
            document.body.appendChild(ta);
            ta.select();
            document.execCommand("copy");
            ta.remove();
          } catch (_) {}
        };

        const loadExample = () => {
          if (demoLead) {
            setLead(demoLead);
            setIsDemoMode(true);
            return;
          }
          setLead({
            company: "FitHome",
            product: "ÐŸÐ¾Ð´Ð¿Ð¸ÑÐ¾Ñ‡Ð½Ð¾Ðµ Ñ„Ð¸Ñ‚Ð½ÐµÑâ€‘Ð¿Ñ€Ð¸Ð»Ð¾Ð¶ÐµÐ½Ð¸Ðµ: Ð¿Ð¾Ñ…ÑƒÐ´ÐµÐ½Ð¸Ðµ Ð´Ð¾Ð¼Ð° Ð·Ð° 8 Ð½ÐµÐ´ÐµÐ»ÑŒ",
            geo: "Ð Ð¾ÑÑÐ¸Ñ",
            industry: "B2C Fitness (subscription)",
            competitors_shortlist: ["Nike Training Club", "Freeletics", "FitOn", "7 Minute Workout", "Adidas Training"].join("\n"),
          });
          setIsDemoMode(true);
        };

        const clearLead = () => {
          setLead(data.lead_placeholders || {});
          setIsDemoMode(false);
        };

        const contentPanel = React.createElement(
          "div",
          { className: "panel" },
          React.createElement(
            "div",
            { className: "panelBody" },
            React.createElement(TouchViewer, {
              touch: selected,
              bundle,
              lead,
              isDemoMode,
              expertMode: isExpertMode,
              onCopyTelegram: copyTelegram,
            })
          )
        );

        const leadModalEl = React.createElement(LeadContextModal, {
          open: isLeadModalOpen,
          lead,
          setLead,
          briefMd,
          onLoadExample: loadExample,
          onClear: clearLead,
          onClose: () => setIsLeadModalOpen(false),
        });

        const readmeModalEl = React.createElement(DocModal, {
          open: isReadmeOpen,
          title: "README",
          md: readmeMd,
          onClose: () => setIsReadmeOpen(false),
        });


        return React.createElement(
          "div",
          { className: "app" + (isMagazineMode ? " magazineMode" : "") },
          React.createElement(
            "div",
            { className: "header" + (isHeaderCollapsed ? " headerCollapsed" : "") },
            React.createElement(
              "div",
              { className: "titleRow" },
              React.createElement(
                "div",
                { className: "brand" },
                React.createElement("img", { className: "brandLogo", src: "../../logo_sgtbl.jpg", alt: "Segmentable", draggable: "false" }),
                React.createElement(
                  "div",
                  null,
                  React.createElement("div", { className: "title" }, data.title || "SegFlow â€” Sales Nurture"),
                  React.createElement(
                    "div",
                    { className: "sub" },
                    data.description || "",
                    bundleBuild ? React.createElement("span", { style: { opacity: 0.5, marginLeft: 10, fontFamily: "ui-monospace, SFMono-Regular, Menlo, monospace" } }, `build ${bundleBuild}`) : null
                  )
                )
              ),
              React.createElement(
                "div",
                { className: "toolbar" },
                isHeaderCollapsed
                  ? React.createElement(
                      React.Fragment,
                      null,
                      React.createElement(
                        "select",
                        { className: "input headerSelect", value: selectedId || "", onChange: (e) => setSelectedId(e.target.value) },
                        touches.map((t) => React.createElement("option", { key: t.id, value: t.id }, `${t.id} â€¢ Ð”ÐµÐ½ÑŒ ${t.day} â€¢ ${t.title}`))
                      ),
                      React.createElement("button", { className: "btn primary", onClick: () => setIsHeaderCollapsed(false) }, "Ð Ð°Ð·Ð²ÐµÑ€Ð½ÑƒÑ‚ÑŒ")
                    )
                  : React.createElement(
                      React.Fragment,
                      null,
                      React.createElement("button", { className: "btn", onClick: () => setIsReadmeOpen(true) }, "README"),
                      React.createElement("button", { className: "btn" + (isMagazineMode ? " activeTab" : ""), onClick: () => setIsMagazineMode(!isMagazineMode) }, "Ð–ÑƒÑ€Ð½Ð°Ð»"),
                      React.createElement("button", { className: "btn" + (isExpertMode ? " activeTab" : ""), onClick: () => setIsExpertMode(!isExpertMode) }, "Expert"),
                      React.createElement("button", { className: "btn primary", onClick: () => setIsLeadModalOpen(true) }, "ÐšÐ¾Ð½Ñ‚ÐµÐºÑÑ‚"),
                      React.createElement("button", { className: "btn", onClick: () => setIsHeaderCollapsed(true) }, "Ð¡Ð²ÐµÑ€Ð½ÑƒÑ‚ÑŒ")
                    )
              )
          ),
            isHeaderCollapsed ? null : touchFlow
          ),
          React.createElement("div", { className: "main" }, contentPanel),
          leadModalEl,
          readmeModalEl,
        );
      }

      ReactDOM.createRoot(document.getElementById("root")).render(React.createElement(App));
      try {
        const bootEl = document.getElementById("boot");
        if (bootEl) bootEl.remove();
      } catch (_) {}
    </script>
  </body>
</html>
